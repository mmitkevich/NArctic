#region Copyright
/*
This file is part of Bohrium and copyright (c) 2012 the Bohrium
team <http://www.bh107.org>.

Bohrium is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as 
published by the Free Software Foundation, either version 3 
of the License, or (at your option) any later version.

Bohrium is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the 
GNU Lesser General Public License along with Bohrium. 

If not, see <http://www.gnu.org/licenses/>.
*/
#endregion

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;


namespace NumCIL.Int8
{
    using T = System.SByte;
    using InArray = NumCIL.Generic.NdArray<System.SByte>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray : IEnumerable<InArray>
    {
        #region NdArray Mimics
        /// <summary>
        /// The value instance that gives access to values
        /// </summary>
        public InArray.ValueAccessor Value { get { return value.Value; } }
        /// <summary>
        /// A reference to the shape instance that describes this view
        /// </summary>
        public Shape Shape { get { return value.Shape; } }
        /// <summary>
        /// A reference to the underlying data storage
        /// </summary>
        public T[] AsArray() { return value.AsArray(); }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="index">The element to get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params long[] index] { get { return this.value[index]; } set { this.value[index] = value; } }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="ranges">The range get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params Range[] ranges] { get { return this.value[ranges]; } set { this.value[ranges] = value; } }
        /// <summary>
        /// Returns a flattened (1-d copy) of the current data view
        /// </summary>
        /// <returns>A flattened copy</returns>
        public OutArray Flatten() { return this.value.Flatten(); }
        /// <summary>
        /// Returns a copy of the underlying data, shaped as this view
        /// </summary>
        /// <returns>A copy of the view data</returns>
        public OutArray Clone() { return this.value.Clone(); }
        /// <summary>
        /// Generates a new view based on this array
        /// </summary>
        /// <param name="newshape">The new shape</param>
        /// <returns>The reshaped array</returns>
        public OutArray Reshape(Shape newshape) { return this.value.Reshape(newshape); }
        /// <summary>
        /// Returns a view that is a view of a single element
        /// </summary>
        /// <param name="element">The element to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(long element) { return this.value.Subview(element); }
        /// <summary>
        /// Returns a view that is a view of a range of elements
        /// </summary>
        /// <param name="range">The range to view</param>
        /// <param name="dimension">The dimension to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(Range range, long dimension) { return this.value.Subview(range, dimension); }
        /// <summary>
        /// Returnes a sliced subview of the data, optionally collapsing single element dimensions
        /// </summary>
        /// <param name="ranges">The ranges to view for each dimension</param>
        /// <param name="collapse">True if single element dimensions should be collapsed, false to retain all dimensions</param>
        /// <returns>A new view of the data</returns>
        public OutArray Subview(Range[] ranges, bool collapse) { return this.value.Subview(ranges, collapse); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<InArray> GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// A debug tag used for naming a view
        /// </summary>
        public string Name { get { return this.value.Name; } set { this.value.Name = value; } }
        /// <summary>
        /// The data accessor providing the data storage
        /// </summary>
        public NumCIL.Generic.IDataAccessor<T> DataAccessor { get { return this.value.DataAccessor; } }

        /// <summary>
        /// Constructs a NdArray that is a scalar wrapper,
        /// allows simple scalar operations on arbitrary
        /// NdArrays
        /// </summary>
        /// <param name="value">The scalar value</param>
        public NdArray(T value)
            : this(new NumCIL.Generic.DefaultAccessor<T>(new T[] { value }))
        {
        }

        /// <summary>
        /// Constructs a new NdArray with the specified shape
        /// </summary>
        /// <param name="shape">The shape of the new NdArray</param>
        public NdArray(Shape shape)
            : this(Generate.Empty(shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(T[] data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(NumCIL.Generic.IDataAccessor<T> data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="source">An existing array that will be re-shaped</param>
        /// <param name="newshape">The shape to view the array in</param>
        public NdArray(InArray source, Shape newshape)
            : this(new InArray(source, newshape))
        {
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.value.ToString();
        }

        /// <summary>
        /// Flushes pending operations on the array
        /// </summary>
        public void Flush() { this.value.Flush(); }

        /// <summary>
        /// Returns a transposed view of this array. If <paramref name="out"/> is supplied, the contents are copied into that array.
        /// </summary>
        /// <param name="out">Optional output array</param>
        /// <returns>A transposed view</returns>
        public OutArray Transpose(OutArray @out = null) { return value.Transpose(@out); }

        /// <summary>
        /// Gets or sets data in a transposed view
        /// </summary>
        public OutArray Transposed { get { return value.Transposed; } set { value.Transposed = this.value; } }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform</param>
        /// <param name="axis">The axis to repeat, if not speficied, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform in each axis</param>
        /// <param name="axis">The axis to repeat, if not specified, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long[] repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Concatenates an array onto this array, joined at the axis
        /// </summary>
        /// <param name="arg">The array to join</param>
        /// <param name="axis">The axis to join at</param>
        /// <returns>The joined array</returns>
        public OutArray Concatenate(OutArray arg, long axis = 0) { return this.value.Concatenate(arg, axis); }

        /// <summary>
        /// Sets the values viewed to the values from another array, i.e. copies the values
        /// </summary>
        /// <param name="arg">The data to copy</param>
        public void Set(OutArray arg) { this.value.Set(arg); }
        #endregion

        /// <summary>
        /// The only data member of the struct is a reference to the underlying view
        /// </summary>
        private readonly InArray value;
        /// <summary>
        /// Constructs a new typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array</param>
        public NdArray(InArray v) { this.value = v; }

        #region Implict conversion operators
        /// <summary>
        /// Implicit operator that returns a typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array to wrap</param>
        /// <returns>A wrapped array</returns>
        public static implicit operator OutArray(InArray v) { return v == null ? null : new OutArray(v); }
        /// <summary>
        /// Implicit operator that returns a basic array from a wrapped one
        /// </summary>
        /// <param name="v">The wrapper array</param>
        /// <returns>The basic array</returns>
        public static implicit operator InArray(NdArray v) { return ((object)v) == null ? null : v.value; }
        /// <summary>
        /// Implicit operator that returns a wrapped array from a scalar value
        /// </summary>
        /// <param name="v">The scalar value</param>
        /// <returns>A wrapped array representing the scalar value</returns>
        public static implicit operator OutArray(T v) { return new OutArray(v); }
        #endregion

        #region Operator implementations
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, OutArray b) { return UFunc.Apply<T, Add>(a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, OutArray b) { return UFunc.Apply<T, Sub>(a, b, null); }
        /// <summary>
        /// Calculates negation of the operand
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a) { return UFunc.Apply<T, Sub>(new OutArray((T)0), a, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, OutArray b) { return UFunc.Apply<T, Mul>(a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, OutArray b) { return UFunc.Apply<T, Div>(a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, OutArray b) { return UFunc.Apply<T, Mod>(a, b, null); }

        /// <summary>
        /// Calculates the incremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of incrementing each value</returns>
        public static OutArray operator ++(OutArray a) { return UFunc.Apply<T, Add>(a, (OutArray)1, null); }
        /// <summary>
        /// Calculates the decremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of decrementing each value</returns>
        public static OutArray operator --(OutArray a) { return UFunc.Apply<T, Sub>(a, (OutArray)1, null); }
        #endregion

        #region Common function implementations
        /// <summary>
        /// Copies all values from this NdArray to the output NdArray
        /// </summary>
        /// <param name="out">Optional target for addition, if null, a new array is created</param>
        /// <returns>An NdArray which is a copy of this array</returns>
        public OutArray Copy(OutArray @out = null) { return UFunc.Apply<T, NumCIL.CopyOp<T>>(this, @out); }
        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, op, @out); }
        /// <summary>
        /// Divides values of an NdArray with this NdArray and returns the modulo result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for modulo result, use to perform in-place modulo</param>
        /// <returns>An NdArray which is the modulo residues of dividing the two NdArrays</returns>
        public OutArray Mod(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mod>(this, op, @out); }
        /// <summary>
        /// Calculates the maximum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the max operation, use to perform in-place maximum calculation</param>
        /// <returns>An NdArray which is the maximum values of the two NdArrays</returns>
        public OutArray Max(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Max>(this, op, @out); }
        /// <summary>
        /// Calculates the minimum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the min operation, use to perform in-place minimum calculation</param>
        /// <returns>An NdArray which is the minimum values of the two NdArrays</returns>
        public OutArray Min(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Min>(this, op, @out); }

        /// <summary>
        /// Returns a new NdArray that is the result of calculating the square root for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the square root of all values</returns>
        public OutArray Sqrt(OutArray @out = null) { return UFunc.Apply<T, Sqrt>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the exponent for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the exponent of all values</returns>
        public OutArray Exp(OutArray @out = null) { return UFunc.Apply<T, Exp>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the absolute value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all absolute values</returns>
        public OutArray Abs(OutArray @out = null) { return UFunc.Apply<T, Abs>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic of all values</returns>
        public OutArray Log(OutArray @out = null) { return UFunc.Apply<T, Log>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic-10 value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic-10 of all values</returns>
        public OutArray Log10(OutArray @out = null) { return UFunc.Apply<T, Log10>(this, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the mathcing element in the operand NdArray
        /// </summary>
        /// <param name="op">The power-of values</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the values in the operand NdArray</returns>
        public OutArray Pow(NdArray op, OutArray @out = null) { return UFunc.Apply<T, Pow>(this, op, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the scalar value
        /// </summary>
        /// <param name="value">The power-of value</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the scalar value</returns>
        public OutArray Pow(T value, OutArray @out = null)
        {
            if (value == 2)
                return UFunc.Apply<T, Mul>(this, this, @out);
            else
                return UFunc.Apply<T, Pow>(this, (OutArray)value, @out);
        }
        /// <summary>
        /// Performs matrix multiplication on the two elements
        /// </summary>
        /// <param name="arg">The right-hand-side argument in matrix multiplication</param>
        /// <param name="out">Optional target for the multiplication</param>
        /// <returns>The matrix multiplication result</returns>
        public OutArray MatrixMultiply(OutArray arg, OutArray @out = null) { return UFunc.Matmul<T, Add, Mul>(this, arg, @out); }
        #endregion


        #region F# support for missing implicit operators
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(T a, OutArray b) { return UFunc.Apply<T, Add>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, T b) { return UFunc.Apply<T, Add>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(T a, OutArray b) { return UFunc.Apply<T, Sub>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, T b) { return UFunc.Apply<T, Sub>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(T a, OutArray b) { return UFunc.Apply<T, Mul>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, T b) { return UFunc.Apply<T, Mul>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(T a, OutArray b) { return UFunc.Apply<T, Div>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, T b) { return UFunc.Apply<T, Div>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(T a, OutArray b) { return UFunc.Apply<T, Mod>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, T b) { return UFunc.Apply<T, Mod>(a, (OutArray)b, null); }

        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(T op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, (OutArray)op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(T op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, (OutArray)op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(T op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, (OutArray)op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(T op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, (OutArray)op, @out); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(T a, OutArray b) { return UFunc.Apply<T, bool, Equal>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, T b) { return UFunc.Apply<T, bool, Equal>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(T a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, T b) { return UFunc.Apply<T, bool, NotEqual>(a, (OutArray)b, null); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(T a, OutArray b) { return UFunc.Apply<T, bool, LessThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, T b) { return UFunc.Apply<T, bool, LessThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(T a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, T b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, (OutArray)b, null); }
        #endregion

        #region Appliers for custom UFuncs
        /// <summary>
        /// Applies a unary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        public OutArray Apply(Func<T, T> op, OutArray @out = null) { return UFunc.Apply(op, this, @out); }
        /// <summary>
        /// Applies a binary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="b">An input operand</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        public OutArray Apply(Func<T, T, T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray @out = null) where C : struct, IUnaryOp<T> { return UFunc.Apply<T, C>(this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray b, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Apply<T, C>(this, b, @out); }
        /// <summary>
        /// Applies a nullary function to each element in this NdArray
        /// Note that Nullary functions are performed in-place
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <returns>This NdArray</returns>
        public OutArray Apply(INullaryOp<T> op) { UFunc.Apply<T>(op, this); return this; }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IUnaryOp<T> op, OutArray @out = null) { return UFunc.Apply<T>(op, this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IBinaryOp<T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }

        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <typeparam name="C">The function to apply reduction with</typeparam>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the reduction in-place</param>
        /// <returns>An NdArray that is the result of reducing the selected axis</returns>
        public OutArray Reduce<C>(long axis = 0, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Reduce<T, C>(this, axis, @out); }
        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <param name="op">The function to apply reduction with</param>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>A reduced array</returns>
        public OutArray Reduce(IBinaryOp<T> op, long axis = 0, OutArray @out = null) { return UFunc.Reduce<T>(op, this, axis, @out); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <typeparam name="C">The operation to perform</typeparam>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate<C>() where C : struct, IBinaryOp<T> { return UFunc.Aggregate<T, C>(this); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <param name="op">The operation to perform</param>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate(IBinaryOp<T> op) { return UFunc.Aggregate<T>(op, this); }

        /// <summary>
        /// Calculates the sum of all elements
        /// </summary>
        /// <returns>A scalar value that is the sum of all elements</returns>
        public T Sum() { return UFunc.Aggregate<T, Add>(this); }
        /// <summary>
        /// Calculates the maximum of all elements
        /// </summary>
        /// <returns>A scalar value that is the maximum of all elements</returns>
        public T Max() { return UFunc.Aggregate<T, Max>(this); }

        /// <summary>
        /// Calculates the minimum of all elements
        /// </summary>
        /// <returns>A scalar value that is the minimum of all elements</returns>
        public T Min() { return UFunc.Aggregate<T, Min>(this); }
        #endregion

		#region Conversion operators
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Double"/></returns>
        public static implicit operator OutArray(NumCIL.Double.NdArray a) { return UFunc.Apply<double, T, ToInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Single"/></returns>
        public static implicit operator OutArray(NumCIL.Float.NdArray a) { return UFunc.Apply<float, T, ToInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int16"/></returns>
        public static implicit operator OutArray(NumCIL.Int16.NdArray a) { return UFunc.Apply<short, T, ToInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int32"/></returns>
        public static implicit operator OutArray(NumCIL.Int32.NdArray a) { return UFunc.Apply<int, T, ToInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int64"/></returns>
        public static implicit operator OutArray(NumCIL.Int64.NdArray a) { return UFunc.Apply<long, T, ToInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Byte"/></returns>
        public static explicit operator OutArray(NumCIL.UInt8.NdArray a) { return UFunc.Apply<byte, T, ToInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt16"/></returns>
        public static explicit operator OutArray(NumCIL.UInt16.NdArray a) { return UFunc.Apply<ushort, T, ToInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt32"/></returns>
        public static explicit operator OutArray(NumCIL.UInt32.NdArray a) { return UFunc.Apply<uint, T, ToInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt64"/></returns>
        public static explicit operator OutArray(NumCIL.UInt64.NdArray a) { return UFunc.Apply<ulong, T, ToInt8>(a); }
				#endregion

		#region Logical/Bitwise operator overloads
        /// <summary>
        /// Calculates the and of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of and-ing the two input operands</returns>
        public static OutArray operator &(OutArray a, OutArray b) { return UFunc.Apply<T, And>(a, b, null); }
        /// <summary>
        /// Calculates the or of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of or-ing the two input operands</returns>
        public static OutArray operator |(OutArray a, OutArray b) { return UFunc.Apply<T, Or>(a, b, null); }
        /// <summary>
        /// Calculates the xor of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of xor-ing the two input operands</returns>
        public static OutArray operator ^(OutArray a, OutArray b) { return UFunc.Apply<T, Xor>(a, b, null); }
        /// <summary>
        /// Calculates the bitwise complement of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The bitwise complement of the input operand</returns>
        public static OutArray operator !(OutArray a) { return UFunc.Apply<T, Invert>(a, null); }
		#endregion

		#region Comparison operator overloads
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, OutArray b) { return UFunc.Apply<T, bool, Equal>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator ==(OutArray a, object b) { return ((object)a) == b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator !=(OutArray a, object b) { return ((object)a) != b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, b, null); }
		#endregion

		#region System.Object overrides
		/// <summary>
		/// Compares this object to another
		/// </summary>
		/// <returns>A value indicating if the two elements are equal</returns>
		public override bool Equals(object o)
		{
			return this == o;
		}

		/// <summary>
		/// Returns a hashcode for comparing this object to others
		/// </summary>
		/// <returns>A hash code for this instance</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}
		#endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly CopyOp<T> Copy;
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly Add Add;
        /// <summary>
        /// The subtraction operation
        /// </summary>
        public static readonly Sub Sub;
        /// <summary>
        /// The multiplication operation
        /// </summary>
        public static readonly Mul Mul;
        /// <summary>
        /// The division operation
        /// </summary>
        public static readonly Div Div;
        /// <summary>
        /// The modulo operation
        /// </summary>
        public static readonly Mod Mod;
        /// <summary>
        /// The maximum operation
        /// </summary>
        public static readonly Max Max;
        /// <summary>
        /// The minimum operation
        /// </summary>
        public static readonly Min Min;
        /// <summary>
        /// The absolute operation
        /// </summary>
        public static readonly Abs Abs;
        /// <summary>
        /// The square root operation
        /// </summary>
        public static readonly Sqrt Sqrt;
        /// <summary>
        /// The exponential operation
        /// </summary>
        public static readonly Exp Exp;
        /// <summary>
        /// The logarithmic operation
        /// </summary>
        public static readonly Log Log;
        /// <summary>
        /// The logarithmic-10 operation
        /// </summary>
        public static readonly Log10 Log10;
        /// <summary>
        /// The power operation
        /// </summary>
        public static readonly Pow Pow;
        /// <summary>
        /// The arc cosine operation
        /// </summary>
        public static readonly Acos Acos;
        /// <summary>
        /// The arc sine operation
        /// </summary>
        public static readonly Asin Asin;
        /// <summary>
        /// The arc tangent operation
        /// </summary>
        public static readonly Atan Atan;
        /// <summary>
        /// The cosine operation
        /// </summary>
        public static readonly Cos Cos;
        /// <summary>
        /// The sine operation
        /// </summary>
        public static readonly Sin Sin;
        /// <summary>
        /// The tangent operation
        /// </summary>
        public static readonly Tan Tan;
        /// <summary>
        /// The hyperbolic cosine operation
        /// </summary>
        public static readonly Cosh Cosh;
        /// <summary>
        /// The hyperbolic sine operation
        /// </summary>
        public static readonly Sinh Sihn;
        /// <summary>
        /// The hyperbolic tangent operation
        /// </summary>
        public static readonly Tanh Tanh;
        /// <summary>
        /// The and operation
        /// </summary>
        public static readonly And And;
        /// <summary>
        /// The or operation
        /// </summary>
        public static readonly Or Or;
        /// <summary>
        /// The xor operation
        /// </summary>
        public static readonly Xor Xor;
        /// <summary>
        /// The invert operation
        /// </summary>
        public static readonly Invert Invert;

    }
    #endregion

	#region Comparison operators
    /// <summary>
    /// The equal Equal implementation
    /// </summary>
    public struct Equal : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IEqual
    {
        /// <summary>
        /// Implementation of Equal test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a == b; }
		
        /// <summary>
        /// Applies the Equal operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, Equal>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThan implementation
    /// </summary>
    public struct GreaterThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThan
    {
        /// <summary>
        /// Implementation of GreaterThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a > b; }
		
        /// <summary>
        /// Applies the GreaterThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThan implementation
    /// </summary>
    public struct LessThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThan
    {
        /// <summary>
        /// Implementation of LessThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a < b; }
		
        /// <summary>
        /// Applies the LessThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThanOrEqual implementation
    /// </summary>
    public struct GreaterThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThanOrEqual
    {
        /// <summary>
        /// Implementation of GreaterThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a >= b; }
		
        /// <summary>
        /// Applies the GreaterThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThanOrEqual implementation
    /// </summary>
    public struct LessThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThanOrEqual
    {
        /// <summary>
        /// Implementation of LessThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a <= b; }
		
        /// <summary>
        /// Applies the LessThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal NotEqual implementation
    /// </summary>
    public struct NotEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.INotEqual
    {
        /// <summary>
        /// Implementation of NotEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a != b; }
		
        /// <summary>
        /// Applies the NotEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, NotEqual>(in1, in2, @out); }
    }

	#endregion

    #region Operator implementations
    /// <summary>
    /// The copy operator implementation
    /// </summary>
    public struct Copy
    {
        /// <summary>
        /// Applies the copy operation to the input operand
        /// </summary>
        /// <param name="in1">The input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise copy of the input view</returns>
        public static OutArray Apply(OutArray in1, OutArray @out = null)
        { return UFunc.Apply<T, NumCIL.CopyOp<T>>(in1, @out); }
    }

	#region Binary operation implementations
    /// <summary>
    /// The Add operator implementation
    /// </summary>
    public struct Add : IBinaryOp<T>, NumCIL.Generic.Operators.IAdd
    {
        /// <summary>
        /// Implementation of Add with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Add with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a + b); }
		
        /// <summary>
        /// Reduces the input array with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Add>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Add>(arg); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>(in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Add>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Sub operator implementation
    /// </summary>
    public struct Sub : IBinaryOp<T>, NumCIL.Generic.Operators.ISub
    {
        /// <summary>
        /// Implementation of Sub with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Sub with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a - b); }
		
        /// <summary>
        /// Reduces the input array with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Sub>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Sub>(arg); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>(in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Sub>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mul operator implementation
    /// </summary>
    public struct Mul : IBinaryOp<T>, NumCIL.Generic.Operators.IMul
    {
        /// <summary>
        /// Implementation of Mul with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mul with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a * b); }
		
        /// <summary>
        /// Reduces the input array with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mul>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mul>(arg); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mul>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Div operator implementation
    /// </summary>
    public struct Div : IBinaryOp<T>, NumCIL.Generic.Operators.IDiv
    {
        /// <summary>
        /// Implementation of Div with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Div with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a / b); }
		
        /// <summary>
        /// Reduces the input array with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Div>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Div>(arg); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>(in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Div>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mod operator implementation
    /// </summary>
    public struct Mod : IBinaryOp<T>, NumCIL.Generic.Operators.IMod
    {
        /// <summary>
        /// Implementation of Mod with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mod with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a % b); }
		
        /// <summary>
        /// Reduces the input array with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mod>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mod>(arg); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mod>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Min operator implementation
    /// </summary>
    public struct Min : IBinaryOp<T>, NumCIL.Generic.Operators.IMin
    {
        /// <summary>
        /// Implementation of Min with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Min with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Min(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Min>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Min>(arg); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>(in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Min>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Max operator implementation
    /// </summary>
    public struct Max : IBinaryOp<T>, NumCIL.Generic.Operators.IMax
    {
        /// <summary>
        /// Implementation of Max with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Max with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Max(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Max>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Max>(arg); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>(in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Max>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Pow operator implementation
    /// </summary>
    public struct Pow : IBinaryOp<T>, NumCIL.Generic.Operators.IPow
    {
        /// <summary>
        /// Implementation of Pow with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Pow with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Pow(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Pow>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Pow>(arg); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>(in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ 
			if (in2 == (T)2)
				return UFunc.Apply<T, Mul>(in1, in1, @out);
			else
				return UFunc.Apply<T, Pow>(in1, (OutArray)in2, @out);
		}
		
    }

    /// <summary>
    /// The And operator implementation
    /// </summary>
    public struct And : IBinaryOp<T>, NumCIL.Generic.Operators.IAnd
    {
        /// <summary>
        /// Implementation of And with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of And with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a & b); }
		
        /// <summary>
        /// Reduces the input array with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, And>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, And>(arg); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>(in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, And>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Or operator implementation
    /// </summary>
    public struct Or : IBinaryOp<T>, NumCIL.Generic.Operators.IOr
    {
        /// <summary>
        /// Implementation of Or with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Or with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a | b); }
		
        /// <summary>
        /// Reduces the input array with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Or>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Or>(arg); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>(in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Or>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Xor operator implementation
    /// </summary>
    public struct Xor : IBinaryOp<T>, NumCIL.Generic.Operators.IXor
    {
        /// <summary>
        /// Implementation of Xor with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Xor with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a ^ b); }
		
        /// <summary>
        /// Reduces the input array with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Xor>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Xor>(arg); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>(in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Xor>(in1, (OutArray)in2, @out); }
    }

	#endregion

	#region Unary operations implementation
    /// <summary>
    /// The Sqrt operation implementation
    /// </summary>
    public struct Sqrt : IUnaryOp<T>, NumCIL.Generic.Operators.ISqrt
    {
        /// <summary>
        /// Implementation of the Sqrt operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sqrt to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sqrt(a); }
		
        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>(@in, @out); }

        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Exp operation implementation
    /// </summary>
    public struct Exp : IUnaryOp<T>, NumCIL.Generic.Operators.IExp
    {
        /// <summary>
        /// Implementation of the Exp operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Exp to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Exp(a); }
		
        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>(@in, @out); }

        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Abs operation implementation
    /// </summary>
    public struct Abs : IUnaryOp<T>, NumCIL.Generic.Operators.IAbs
    {
        /// <summary>
        /// Implementation of the Abs operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Abs to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Abs(a); }
		
        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>(@in, @out); }

        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sin operation implementation
    /// </summary>
    public struct Sin : IUnaryOp<T>, NumCIL.Generic.Operators.ISin
    {
        /// <summary>
        /// Implementation of the Sin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sin(a); }
		
        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>(@in, @out); }

        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cos operation implementation
    /// </summary>
    public struct Cos : IUnaryOp<T>, NumCIL.Generic.Operators.ICos
    {
        /// <summary>
        /// Implementation of the Cos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cos(a); }
		
        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>(@in, @out); }

        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tan operation implementation
    /// </summary>
    public struct Tan : IUnaryOp<T>, NumCIL.Generic.Operators.ITan
    {
        /// <summary>
        /// Implementation of the Tan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tan(a); }
		
        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>(@in, @out); }

        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Asin operation implementation
    /// </summary>
    public struct Asin : IUnaryOp<T>, NumCIL.Generic.Operators.IAsin
    {
        /// <summary>
        /// Implementation of the Asin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Asin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Asin(a); }
		
        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>(@in, @out); }

        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Acos operation implementation
    /// </summary>
    public struct Acos : IUnaryOp<T>, NumCIL.Generic.Operators.IAcos
    {
        /// <summary>
        /// Implementation of the Acos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Acos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Acos(a); }
		
        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>(@in, @out); }

        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Atan operation implementation
    /// </summary>
    public struct Atan : IUnaryOp<T>, NumCIL.Generic.Operators.IAtan
    {
        /// <summary>
        /// Implementation of the Atan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Atan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Atan(a); }
		
        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>(@in, @out); }

        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sinh operation implementation
    /// </summary>
    public struct Sinh : IUnaryOp<T>, NumCIL.Generic.Operators.ISinh
    {
        /// <summary>
        /// Implementation of the Sinh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sinh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sinh(a); }
		
        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>(@in, @out); }

        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cosh operation implementation
    /// </summary>
    public struct Cosh : IUnaryOp<T>, NumCIL.Generic.Operators.ICosh
    {
        /// <summary>
        /// Implementation of the Cosh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cosh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cosh(a); }
		
        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>(@in, @out); }

        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tanh operation implementation
    /// </summary>
    public struct Tanh : IUnaryOp<T>, NumCIL.Generic.Operators.ITanh
    {
        /// <summary>
        /// Implementation of the Tanh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tanh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tanh(a); }
		
        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>(@in, @out); }

        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log operation implementation
    /// </summary>
    public struct Log : IUnaryOp<T>, NumCIL.Generic.Operators.ILog
    {
        /// <summary>
        /// Implementation of the Log operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log(a); }
		
        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>(@in, @out); }

        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log10 operation implementation
    /// </summary>
    public struct Log10 : IUnaryOp<T>, NumCIL.Generic.Operators.ILog10
    {
        /// <summary>
        /// Implementation of the Log10 operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log10 to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log10(a); }
		
        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>(@in, @out); }

        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Invert operation implementation
    /// </summary>
    public struct Invert : IUnaryOp<T>, NumCIL.Generic.Operators.IInvert
    {
        /// <summary>
        /// Implementation of the Invert operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Invert to the operand</returns>
        public T Op(T a) 
		{ return (T)(~a); }
		
        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>(@in, @out); }

        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sign operation implementation
    /// </summary>
    public struct Sign : IUnaryOp<T>, NumCIL.Generic.Operators.ISign
    {
        /// <summary>
        /// Implementation of the Sign operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sign to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sign(a); }
		
        /// <summary>
        /// Applies the Sign operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sign>(@in, @out); }

        /// <summary>
        /// Applies the Sign operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sign>((OutArray)@in, @out); }
    }

	#endregion
	#endregion

    #region Generate mimics
    /// <summary>
    /// Generates basic initial arrays
    /// </summary>
    public static class Generate
    {
        /// <summary>
        /// The factory class that produces the NdArray instances
        /// </summary>
        public static NumCIL.Generic.IGenerator<T> Generator = new NumCIL.Generic.Generator<T, NumCIL.Generic.RandomGeneratorOpInt8, NumCIL.Generic.RangeGeneratorOp<T, NumCIL.Generic.NumberConverterInt8>, NumCIL.Generic.NumberConverterInt8>();

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(Shape shape) { return Generator.Range(shape); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(Shape shape) { return Generator.Ones(shape); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(Shape shape) { return Generator.Zeroes(shape); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with uninitialized data</returns>
        public static OutArray Empty(Shape shape) { return Generator.Empty(shape); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to fill the array with</param>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, Shape shape) { return Generator.Same(value, shape); }
        /// <summary>
        /// Creates an array filled with the value random numbers
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to random numbers</returns>
        public static OutArray Random(Shape shape) { return Generator.Random(shape); }

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(params long[] dimensions) { return Generator.Range(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(params long[] dimensions) { return Generator.Ones(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(params long[] dimensions) { return Generator.Zeroes(dimensions); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with uninitialized values</returns>
        public static OutArray Empty(params long[] dimensions) { return Generator.Empty(dimensions); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to set fill the array with</param>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, params long[] dimensions) { return Generator.Same(value, dimensions); }
        /// <summary>
        /// Creates an array filled with random values
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to a random value</returns>
        public static OutArray Random(params long[] dimensions) { return Generator.Random(dimensions); }
    }
    #endregion

	#region Conversion operator
	/// <summary>
    /// Operator for converting a number to another type
    /// </summary>
	public struct ToInt8 :
        IUnaryConvOp<double, T>, 
        IUnaryConvOp<float, T>, 
        IUnaryConvOp<byte,T>, 
        IUnaryConvOp<short, T>, 
        IUnaryConvOp<ushort, T>, 
        IUnaryConvOp<int, T>, 
        IUnaryConvOp<uint,T>, 
        IUnaryConvOp<long, T>, 
        IUnaryConvOp<ulong, T>,
		NumCIL.Generic.Operators.ITypeConversion
    {

        /// <summary>
        /// Converts the input from a <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(double a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(float a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(byte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ushort a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(short a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(uint a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(int a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ulong a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(long a) { return (T)a; }
    }
	#endregion
}

namespace NumCIL.UInt8
{
    using T = System.Byte;
    using InArray = NumCIL.Generic.NdArray<System.Byte>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray : IEnumerable<InArray>
    {
        #region NdArray Mimics
        /// <summary>
        /// The value instance that gives access to values
        /// </summary>
        public InArray.ValueAccessor Value { get { return value.Value; } }
        /// <summary>
        /// A reference to the shape instance that describes this view
        /// </summary>
        public Shape Shape { get { return value.Shape; } }
        /// <summary>
        /// A reference to the underlying data storage
        /// </summary>
        public T[] AsArray() { return value.AsArray(); }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="index">The element to get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params long[] index] { get { return this.value[index]; } set { this.value[index] = value; } }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="ranges">The range get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params Range[] ranges] { get { return this.value[ranges]; } set { this.value[ranges] = value; } }
        /// <summary>
        /// Returns a flattened (1-d copy) of the current data view
        /// </summary>
        /// <returns>A flattened copy</returns>
        public OutArray Flatten() { return this.value.Flatten(); }
        /// <summary>
        /// Returns a copy of the underlying data, shaped as this view
        /// </summary>
        /// <returns>A copy of the view data</returns>
        public OutArray Clone() { return this.value.Clone(); }
        /// <summary>
        /// Generates a new view based on this array
        /// </summary>
        /// <param name="newshape">The new shape</param>
        /// <returns>The reshaped array</returns>
        public OutArray Reshape(Shape newshape) { return this.value.Reshape(newshape); }
        /// <summary>
        /// Returns a view that is a view of a single element
        /// </summary>
        /// <param name="element">The element to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(long element) { return this.value.Subview(element); }
        /// <summary>
        /// Returns a view that is a view of a range of elements
        /// </summary>
        /// <param name="range">The range to view</param>
        /// <param name="dimension">The dimension to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(Range range, long dimension) { return this.value.Subview(range, dimension); }
        /// <summary>
        /// Returnes a sliced subview of the data, optionally collapsing single element dimensions
        /// </summary>
        /// <param name="ranges">The ranges to view for each dimension</param>
        /// <param name="collapse">True if single element dimensions should be collapsed, false to retain all dimensions</param>
        /// <returns>A new view of the data</returns>
        public OutArray Subview(Range[] ranges, bool collapse) { return this.value.Subview(ranges, collapse); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<InArray> GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// A debug tag used for naming a view
        /// </summary>
        public string Name { get { return this.value.Name; } set { this.value.Name = value; } }
        /// <summary>
        /// The data accessor providing the data storage
        /// </summary>
        public NumCIL.Generic.IDataAccessor<T> DataAccessor { get { return this.value.DataAccessor; } }

        /// <summary>
        /// Constructs a NdArray that is a scalar wrapper,
        /// allows simple scalar operations on arbitrary
        /// NdArrays
        /// </summary>
        /// <param name="value">The scalar value</param>
        public NdArray(T value)
            : this(new NumCIL.Generic.DefaultAccessor<T>(new T[] { value }))
        {
        }

        /// <summary>
        /// Constructs a new NdArray with the specified shape
        /// </summary>
        /// <param name="shape">The shape of the new NdArray</param>
        public NdArray(Shape shape)
            : this(Generate.Empty(shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(T[] data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(NumCIL.Generic.IDataAccessor<T> data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="source">An existing array that will be re-shaped</param>
        /// <param name="newshape">The shape to view the array in</param>
        public NdArray(InArray source, Shape newshape)
            : this(new InArray(source, newshape))
        {
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.value.ToString();
        }

        /// <summary>
        /// Flushes pending operations on the array
        /// </summary>
        public void Flush() { this.value.Flush(); }

        /// <summary>
        /// Returns a transposed view of this array. If <paramref name="out"/> is supplied, the contents are copied into that array.
        /// </summary>
        /// <param name="out">Optional output array</param>
        /// <returns>A transposed view</returns>
        public OutArray Transpose(OutArray @out = null) { return value.Transpose(@out); }

        /// <summary>
        /// Gets or sets data in a transposed view
        /// </summary>
        public OutArray Transposed { get { return value.Transposed; } set { value.Transposed = this.value; } }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform</param>
        /// <param name="axis">The axis to repeat, if not speficied, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform in each axis</param>
        /// <param name="axis">The axis to repeat, if not specified, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long[] repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Concatenates an array onto this array, joined at the axis
        /// </summary>
        /// <param name="arg">The array to join</param>
        /// <param name="axis">The axis to join at</param>
        /// <returns>The joined array</returns>
        public OutArray Concatenate(OutArray arg, long axis = 0) { return this.value.Concatenate(arg, axis); }

        /// <summary>
        /// Sets the values viewed to the values from another array, i.e. copies the values
        /// </summary>
        /// <param name="arg">The data to copy</param>
        public void Set(OutArray arg) { this.value.Set(arg); }
        #endregion

        /// <summary>
        /// The only data member of the struct is a reference to the underlying view
        /// </summary>
        private readonly InArray value;
        /// <summary>
        /// Constructs a new typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array</param>
        public NdArray(InArray v) { this.value = v; }

        #region Implict conversion operators
        /// <summary>
        /// Implicit operator that returns a typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array to wrap</param>
        /// <returns>A wrapped array</returns>
        public static implicit operator OutArray(InArray v) { return v == null ? null : new OutArray(v); }
        /// <summary>
        /// Implicit operator that returns a basic array from a wrapped one
        /// </summary>
        /// <param name="v">The wrapper array</param>
        /// <returns>The basic array</returns>
        public static implicit operator InArray(NdArray v) { return ((object)v) == null ? null : v.value; }
        /// <summary>
        /// Implicit operator that returns a wrapped array from a scalar value
        /// </summary>
        /// <param name="v">The scalar value</param>
        /// <returns>A wrapped array representing the scalar value</returns>
        public static implicit operator OutArray(T v) { return new OutArray(v); }
        #endregion

        #region Operator implementations
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, OutArray b) { return UFunc.Apply<T, Add>(a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, OutArray b) { return UFunc.Apply<T, Sub>(a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, OutArray b) { return UFunc.Apply<T, Mul>(a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, OutArray b) { return UFunc.Apply<T, Div>(a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, OutArray b) { return UFunc.Apply<T, Mod>(a, b, null); }

        /// <summary>
        /// Calculates the incremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of incrementing each value</returns>
        public static OutArray operator ++(OutArray a) { return UFunc.Apply<T, Add>(a, (OutArray)1, null); }
        /// <summary>
        /// Calculates the decremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of decrementing each value</returns>
        public static OutArray operator --(OutArray a) { return UFunc.Apply<T, Sub>(a, (OutArray)1, null); }
        #endregion

        #region Common function implementations
        /// <summary>
        /// Copies all values from this NdArray to the output NdArray
        /// </summary>
        /// <param name="out">Optional target for addition, if null, a new array is created</param>
        /// <returns>An NdArray which is a copy of this array</returns>
        public OutArray Copy(OutArray @out = null) { return UFunc.Apply<T, NumCIL.CopyOp<T>>(this, @out); }
        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, op, @out); }
        /// <summary>
        /// Divides values of an NdArray with this NdArray and returns the modulo result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for modulo result, use to perform in-place modulo</param>
        /// <returns>An NdArray which is the modulo residues of dividing the two NdArrays</returns>
        public OutArray Mod(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mod>(this, op, @out); }
        /// <summary>
        /// Calculates the maximum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the max operation, use to perform in-place maximum calculation</param>
        /// <returns>An NdArray which is the maximum values of the two NdArrays</returns>
        public OutArray Max(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Max>(this, op, @out); }
        /// <summary>
        /// Calculates the minimum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the min operation, use to perform in-place minimum calculation</param>
        /// <returns>An NdArray which is the minimum values of the two NdArrays</returns>
        public OutArray Min(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Min>(this, op, @out); }

        /// <summary>
        /// Returns a new NdArray that is the result of calculating the square root for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the square root of all values</returns>
        public OutArray Sqrt(OutArray @out = null) { return UFunc.Apply<T, Sqrt>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the exponent for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the exponent of all values</returns>
        public OutArray Exp(OutArray @out = null) { return UFunc.Apply<T, Exp>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic of all values</returns>
        public OutArray Log(OutArray @out = null) { return UFunc.Apply<T, Log>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic-10 value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic-10 of all values</returns>
        public OutArray Log10(OutArray @out = null) { return UFunc.Apply<T, Log10>(this, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the mathcing element in the operand NdArray
        /// </summary>
        /// <param name="op">The power-of values</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the values in the operand NdArray</returns>
        public OutArray Pow(NdArray op, OutArray @out = null) { return UFunc.Apply<T, Pow>(this, op, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the scalar value
        /// </summary>
        /// <param name="value">The power-of value</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the scalar value</returns>
        public OutArray Pow(T value, OutArray @out = null)
        {
            if (value == 2)
                return UFunc.Apply<T, Mul>(this, this, @out);
            else
                return UFunc.Apply<T, Pow>(this, (OutArray)value, @out);
        }
        /// <summary>
        /// Performs matrix multiplication on the two elements
        /// </summary>
        /// <param name="arg">The right-hand-side argument in matrix multiplication</param>
        /// <param name="out">Optional target for the multiplication</param>
        /// <returns>The matrix multiplication result</returns>
        public OutArray MatrixMultiply(OutArray arg, OutArray @out = null) { return UFunc.Matmul<T, Add, Mul>(this, arg, @out); }
        #endregion


        #region F# support for missing implicit operators
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(T a, OutArray b) { return UFunc.Apply<T, Add>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, T b) { return UFunc.Apply<T, Add>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(T a, OutArray b) { return UFunc.Apply<T, Sub>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, T b) { return UFunc.Apply<T, Sub>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(T a, OutArray b) { return UFunc.Apply<T, Mul>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, T b) { return UFunc.Apply<T, Mul>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(T a, OutArray b) { return UFunc.Apply<T, Div>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, T b) { return UFunc.Apply<T, Div>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(T a, OutArray b) { return UFunc.Apply<T, Mod>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, T b) { return UFunc.Apply<T, Mod>(a, (OutArray)b, null); }

        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(T op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, (OutArray)op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(T op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, (OutArray)op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(T op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, (OutArray)op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(T op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, (OutArray)op, @out); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(T a, OutArray b) { return UFunc.Apply<T, bool, Equal>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, T b) { return UFunc.Apply<T, bool, Equal>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(T a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, T b) { return UFunc.Apply<T, bool, NotEqual>(a, (OutArray)b, null); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(T a, OutArray b) { return UFunc.Apply<T, bool, LessThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, T b) { return UFunc.Apply<T, bool, LessThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(T a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, T b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, (OutArray)b, null); }
        #endregion

        #region Appliers for custom UFuncs
        /// <summary>
        /// Applies a unary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        public OutArray Apply(Func<T, T> op, OutArray @out = null) { return UFunc.Apply(op, this, @out); }
        /// <summary>
        /// Applies a binary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="b">An input operand</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        public OutArray Apply(Func<T, T, T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray @out = null) where C : struct, IUnaryOp<T> { return UFunc.Apply<T, C>(this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray b, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Apply<T, C>(this, b, @out); }
        /// <summary>
        /// Applies a nullary function to each element in this NdArray
        /// Note that Nullary functions are performed in-place
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <returns>This NdArray</returns>
        public OutArray Apply(INullaryOp<T> op) { UFunc.Apply<T>(op, this); return this; }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IUnaryOp<T> op, OutArray @out = null) { return UFunc.Apply<T>(op, this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IBinaryOp<T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }

        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <typeparam name="C">The function to apply reduction with</typeparam>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the reduction in-place</param>
        /// <returns>An NdArray that is the result of reducing the selected axis</returns>
        public OutArray Reduce<C>(long axis = 0, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Reduce<T, C>(this, axis, @out); }
        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <param name="op">The function to apply reduction with</param>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>A reduced array</returns>
        public OutArray Reduce(IBinaryOp<T> op, long axis = 0, OutArray @out = null) { return UFunc.Reduce<T>(op, this, axis, @out); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <typeparam name="C">The operation to perform</typeparam>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate<C>() where C : struct, IBinaryOp<T> { return UFunc.Aggregate<T, C>(this); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <param name="op">The operation to perform</param>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate(IBinaryOp<T> op) { return UFunc.Aggregate<T>(op, this); }

        /// <summary>
        /// Calculates the sum of all elements
        /// </summary>
        /// <returns>A scalar value that is the sum of all elements</returns>
        public T Sum() { return UFunc.Aggregate<T, Add>(this); }
        /// <summary>
        /// Calculates the maximum of all elements
        /// </summary>
        /// <returns>A scalar value that is the maximum of all elements</returns>
        public T Max() { return UFunc.Aggregate<T, Max>(this); }

        /// <summary>
        /// Calculates the minimum of all elements
        /// </summary>
        /// <returns>A scalar value that is the minimum of all elements</returns>
        public T Min() { return UFunc.Aggregate<T, Min>(this); }
        #endregion

		#region Conversion operators
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Double"/></returns>
        public static implicit operator OutArray(NumCIL.Double.NdArray a) { return UFunc.Apply<double, T, ToUInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Single"/></returns>
        public static implicit operator OutArray(NumCIL.Float.NdArray a) { return UFunc.Apply<float, T, ToUInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.SByte"/></returns>
        public static explicit operator OutArray(NumCIL.Int8.NdArray a) { return UFunc.Apply<sbyte, T, ToUInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int16"/></returns>
        public static implicit operator OutArray(NumCIL.Int16.NdArray a) { return UFunc.Apply<short, T, ToUInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int32"/></returns>
        public static implicit operator OutArray(NumCIL.Int32.NdArray a) { return UFunc.Apply<int, T, ToUInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int64"/></returns>
        public static implicit operator OutArray(NumCIL.Int64.NdArray a) { return UFunc.Apply<long, T, ToUInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt16"/></returns>
        public static implicit operator OutArray(NumCIL.UInt16.NdArray a) { return UFunc.Apply<ushort, T, ToUInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt32"/></returns>
        public static implicit operator OutArray(NumCIL.UInt32.NdArray a) { return UFunc.Apply<uint, T, ToUInt8>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt64"/></returns>
        public static implicit operator OutArray(NumCIL.UInt64.NdArray a) { return UFunc.Apply<ulong, T, ToUInt8>(a); }
				#endregion

		#region Logical/Bitwise operator overloads
        /// <summary>
        /// Calculates the and of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of and-ing the two input operands</returns>
        public static OutArray operator &(OutArray a, OutArray b) { return UFunc.Apply<T, And>(a, b, null); }
        /// <summary>
        /// Calculates the or of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of or-ing the two input operands</returns>
        public static OutArray operator |(OutArray a, OutArray b) { return UFunc.Apply<T, Or>(a, b, null); }
        /// <summary>
        /// Calculates the xor of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of xor-ing the two input operands</returns>
        public static OutArray operator ^(OutArray a, OutArray b) { return UFunc.Apply<T, Xor>(a, b, null); }
        /// <summary>
        /// Calculates the bitwise complement of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The bitwise complement of the input operand</returns>
        public static OutArray operator !(OutArray a) { return UFunc.Apply<T, Invert>(a, null); }
		#endregion

		#region Comparison operator overloads
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, OutArray b) { return UFunc.Apply<T, bool, Equal>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator ==(OutArray a, object b) { return ((object)a) == b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator !=(OutArray a, object b) { return ((object)a) != b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, b, null); }
		#endregion

		#region System.Object overrides
		/// <summary>
		/// Compares this object to another
		/// </summary>
		/// <returns>A value indicating if the two elements are equal</returns>
		public override bool Equals(object o)
		{
			return this == o;
		}

		/// <summary>
		/// Returns a hashcode for comparing this object to others
		/// </summary>
		/// <returns>A hash code for this instance</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}
		#endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly CopyOp<T> Copy;
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly Add Add;
        /// <summary>
        /// The subtraction operation
        /// </summary>
        public static readonly Sub Sub;
        /// <summary>
        /// The multiplication operation
        /// </summary>
        public static readonly Mul Mul;
        /// <summary>
        /// The division operation
        /// </summary>
        public static readonly Div Div;
        /// <summary>
        /// The modulo operation
        /// </summary>
        public static readonly Mod Mod;
        /// <summary>
        /// The maximum operation
        /// </summary>
        public static readonly Max Max;
        /// <summary>
        /// The minimum operation
        /// </summary>
        public static readonly Min Min;
        /// <summary>
        /// The square root operation
        /// </summary>
        public static readonly Sqrt Sqrt;
        /// <summary>
        /// The exponential operation
        /// </summary>
        public static readonly Exp Exp;
        /// <summary>
        /// The logarithmic operation
        /// </summary>
        public static readonly Log Log;
        /// <summary>
        /// The logarithmic-10 operation
        /// </summary>
        public static readonly Log10 Log10;
        /// <summary>
        /// The power operation
        /// </summary>
        public static readonly Pow Pow;
        /// <summary>
        /// The arc cosine operation
        /// </summary>
        public static readonly Acos Acos;
        /// <summary>
        /// The arc sine operation
        /// </summary>
        public static readonly Asin Asin;
        /// <summary>
        /// The arc tangent operation
        /// </summary>
        public static readonly Atan Atan;
        /// <summary>
        /// The cosine operation
        /// </summary>
        public static readonly Cos Cos;
        /// <summary>
        /// The sine operation
        /// </summary>
        public static readonly Sin Sin;
        /// <summary>
        /// The tangent operation
        /// </summary>
        public static readonly Tan Tan;
        /// <summary>
        /// The hyperbolic cosine operation
        /// </summary>
        public static readonly Cosh Cosh;
        /// <summary>
        /// The hyperbolic sine operation
        /// </summary>
        public static readonly Sinh Sihn;
        /// <summary>
        /// The hyperbolic tangent operation
        /// </summary>
        public static readonly Tanh Tanh;
        /// <summary>
        /// The and operation
        /// </summary>
        public static readonly And And;
        /// <summary>
        /// The or operation
        /// </summary>
        public static readonly Or Or;
        /// <summary>
        /// The xor operation
        /// </summary>
        public static readonly Xor Xor;
        /// <summary>
        /// The invert operation
        /// </summary>
        public static readonly Invert Invert;

    }
    #endregion

	#region Comparison operators
    /// <summary>
    /// The equal Equal implementation
    /// </summary>
    public struct Equal : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IEqual
    {
        /// <summary>
        /// Implementation of Equal test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a == b; }
		
        /// <summary>
        /// Applies the Equal operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, Equal>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThan implementation
    /// </summary>
    public struct GreaterThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThan
    {
        /// <summary>
        /// Implementation of GreaterThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a > b; }
		
        /// <summary>
        /// Applies the GreaterThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThan implementation
    /// </summary>
    public struct LessThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThan
    {
        /// <summary>
        /// Implementation of LessThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a < b; }
		
        /// <summary>
        /// Applies the LessThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThanOrEqual implementation
    /// </summary>
    public struct GreaterThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThanOrEqual
    {
        /// <summary>
        /// Implementation of GreaterThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a >= b; }
		
        /// <summary>
        /// Applies the GreaterThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThanOrEqual implementation
    /// </summary>
    public struct LessThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThanOrEqual
    {
        /// <summary>
        /// Implementation of LessThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a <= b; }
		
        /// <summary>
        /// Applies the LessThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal NotEqual implementation
    /// </summary>
    public struct NotEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.INotEqual
    {
        /// <summary>
        /// Implementation of NotEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a != b; }
		
        /// <summary>
        /// Applies the NotEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, NotEqual>(in1, in2, @out); }
    }

	#endregion

    #region Operator implementations
    /// <summary>
    /// The copy operator implementation
    /// </summary>
    public struct Copy
    {
        /// <summary>
        /// Applies the copy operation to the input operand
        /// </summary>
        /// <param name="in1">The input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise copy of the input view</returns>
        public static OutArray Apply(OutArray in1, OutArray @out = null)
        { return UFunc.Apply<T, NumCIL.CopyOp<T>>(in1, @out); }
    }

	#region Binary operation implementations
    /// <summary>
    /// The Add operator implementation
    /// </summary>
    public struct Add : IBinaryOp<T>, NumCIL.Generic.Operators.IAdd
    {
        /// <summary>
        /// Implementation of Add with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Add with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a + b); }
		
        /// <summary>
        /// Reduces the input array with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Add>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Add>(arg); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>(in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Add>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Sub operator implementation
    /// </summary>
    public struct Sub : IBinaryOp<T>, NumCIL.Generic.Operators.ISub
    {
        /// <summary>
        /// Implementation of Sub with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Sub with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a - b); }
		
        /// <summary>
        /// Reduces the input array with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Sub>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Sub>(arg); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>(in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Sub>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mul operator implementation
    /// </summary>
    public struct Mul : IBinaryOp<T>, NumCIL.Generic.Operators.IMul
    {
        /// <summary>
        /// Implementation of Mul with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mul with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a * b); }
		
        /// <summary>
        /// Reduces the input array with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mul>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mul>(arg); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mul>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Div operator implementation
    /// </summary>
    public struct Div : IBinaryOp<T>, NumCIL.Generic.Operators.IDiv
    {
        /// <summary>
        /// Implementation of Div with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Div with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a / b); }
		
        /// <summary>
        /// Reduces the input array with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Div>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Div>(arg); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>(in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Div>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mod operator implementation
    /// </summary>
    public struct Mod : IBinaryOp<T>, NumCIL.Generic.Operators.IMod
    {
        /// <summary>
        /// Implementation of Mod with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mod with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a % b); }
		
        /// <summary>
        /// Reduces the input array with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mod>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mod>(arg); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mod>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Min operator implementation
    /// </summary>
    public struct Min : IBinaryOp<T>, NumCIL.Generic.Operators.IMin
    {
        /// <summary>
        /// Implementation of Min with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Min with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Min(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Min>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Min>(arg); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>(in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Min>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Max operator implementation
    /// </summary>
    public struct Max : IBinaryOp<T>, NumCIL.Generic.Operators.IMax
    {
        /// <summary>
        /// Implementation of Max with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Max with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Max(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Max>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Max>(arg); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>(in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Max>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Pow operator implementation
    /// </summary>
    public struct Pow : IBinaryOp<T>, NumCIL.Generic.Operators.IPow
    {
        /// <summary>
        /// Implementation of Pow with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Pow with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Pow(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Pow>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Pow>(arg); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>(in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ 
			if (in2 == (T)2)
				return UFunc.Apply<T, Mul>(in1, in1, @out);
			else
				return UFunc.Apply<T, Pow>(in1, (OutArray)in2, @out);
		}
		
    }

    /// <summary>
    /// The And operator implementation
    /// </summary>
    public struct And : IBinaryOp<T>, NumCIL.Generic.Operators.IAnd
    {
        /// <summary>
        /// Implementation of And with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of And with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a & b); }
		
        /// <summary>
        /// Reduces the input array with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, And>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, And>(arg); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>(in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, And>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Or operator implementation
    /// </summary>
    public struct Or : IBinaryOp<T>, NumCIL.Generic.Operators.IOr
    {
        /// <summary>
        /// Implementation of Or with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Or with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a | b); }
		
        /// <summary>
        /// Reduces the input array with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Or>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Or>(arg); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>(in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Or>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Xor operator implementation
    /// </summary>
    public struct Xor : IBinaryOp<T>, NumCIL.Generic.Operators.IXor
    {
        /// <summary>
        /// Implementation of Xor with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Xor with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a ^ b); }
		
        /// <summary>
        /// Reduces the input array with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Xor>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Xor>(arg); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>(in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Xor>(in1, (OutArray)in2, @out); }
    }

	#endregion

	#region Unary operations implementation
    /// <summary>
    /// The Sqrt operation implementation
    /// </summary>
    public struct Sqrt : IUnaryOp<T>, NumCIL.Generic.Operators.ISqrt
    {
        /// <summary>
        /// Implementation of the Sqrt operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sqrt to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sqrt(a); }
		
        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>(@in, @out); }

        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Exp operation implementation
    /// </summary>
    public struct Exp : IUnaryOp<T>, NumCIL.Generic.Operators.IExp
    {
        /// <summary>
        /// Implementation of the Exp operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Exp to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Exp(a); }
		
        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>(@in, @out); }

        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sin operation implementation
    /// </summary>
    public struct Sin : IUnaryOp<T>, NumCIL.Generic.Operators.ISin
    {
        /// <summary>
        /// Implementation of the Sin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sin(a); }
		
        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>(@in, @out); }

        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cos operation implementation
    /// </summary>
    public struct Cos : IUnaryOp<T>, NumCIL.Generic.Operators.ICos
    {
        /// <summary>
        /// Implementation of the Cos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cos(a); }
		
        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>(@in, @out); }

        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tan operation implementation
    /// </summary>
    public struct Tan : IUnaryOp<T>, NumCIL.Generic.Operators.ITan
    {
        /// <summary>
        /// Implementation of the Tan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tan(a); }
		
        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>(@in, @out); }

        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Asin operation implementation
    /// </summary>
    public struct Asin : IUnaryOp<T>, NumCIL.Generic.Operators.IAsin
    {
        /// <summary>
        /// Implementation of the Asin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Asin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Asin(a); }
		
        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>(@in, @out); }

        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Acos operation implementation
    /// </summary>
    public struct Acos : IUnaryOp<T>, NumCIL.Generic.Operators.IAcos
    {
        /// <summary>
        /// Implementation of the Acos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Acos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Acos(a); }
		
        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>(@in, @out); }

        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Atan operation implementation
    /// </summary>
    public struct Atan : IUnaryOp<T>, NumCIL.Generic.Operators.IAtan
    {
        /// <summary>
        /// Implementation of the Atan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Atan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Atan(a); }
		
        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>(@in, @out); }

        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sinh operation implementation
    /// </summary>
    public struct Sinh : IUnaryOp<T>, NumCIL.Generic.Operators.ISinh
    {
        /// <summary>
        /// Implementation of the Sinh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sinh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sinh(a); }
		
        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>(@in, @out); }

        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cosh operation implementation
    /// </summary>
    public struct Cosh : IUnaryOp<T>, NumCIL.Generic.Operators.ICosh
    {
        /// <summary>
        /// Implementation of the Cosh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cosh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cosh(a); }
		
        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>(@in, @out); }

        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tanh operation implementation
    /// </summary>
    public struct Tanh : IUnaryOp<T>, NumCIL.Generic.Operators.ITanh
    {
        /// <summary>
        /// Implementation of the Tanh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tanh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tanh(a); }
		
        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>(@in, @out); }

        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log operation implementation
    /// </summary>
    public struct Log : IUnaryOp<T>, NumCIL.Generic.Operators.ILog
    {
        /// <summary>
        /// Implementation of the Log operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log(a); }
		
        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>(@in, @out); }

        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log10 operation implementation
    /// </summary>
    public struct Log10 : IUnaryOp<T>, NumCIL.Generic.Operators.ILog10
    {
        /// <summary>
        /// Implementation of the Log10 operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log10 to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log10(a); }
		
        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>(@in, @out); }

        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Invert operation implementation
    /// </summary>
    public struct Invert : IUnaryOp<T>, NumCIL.Generic.Operators.IInvert
    {
        /// <summary>
        /// Implementation of the Invert operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Invert to the operand</returns>
        public T Op(T a) 
		{ return (T)(~a); }
		
        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>(@in, @out); }

        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>((OutArray)@in, @out); }
    }

	#endregion
	#endregion

    #region Generate mimics
    /// <summary>
    /// Generates basic initial arrays
    /// </summary>
    public static class Generate
    {
        /// <summary>
        /// The factory class that produces the NdArray instances
        /// </summary>
        public static NumCIL.Generic.IGenerator<T> Generator = new NumCIL.Generic.Generator<T, NumCIL.Generic.RandomGeneratorOpUInt8, NumCIL.Generic.RangeGeneratorOp<T, NumCIL.Generic.NumberConverterUInt8>, NumCIL.Generic.NumberConverterUInt8>();

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(Shape shape) { return Generator.Range(shape); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(Shape shape) { return Generator.Ones(shape); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(Shape shape) { return Generator.Zeroes(shape); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with uninitialized data</returns>
        public static OutArray Empty(Shape shape) { return Generator.Empty(shape); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to fill the array with</param>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, Shape shape) { return Generator.Same(value, shape); }
        /// <summary>
        /// Creates an array filled with the value random numbers
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to random numbers</returns>
        public static OutArray Random(Shape shape) { return Generator.Random(shape); }

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(params long[] dimensions) { return Generator.Range(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(params long[] dimensions) { return Generator.Ones(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(params long[] dimensions) { return Generator.Zeroes(dimensions); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with uninitialized values</returns>
        public static OutArray Empty(params long[] dimensions) { return Generator.Empty(dimensions); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to set fill the array with</param>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, params long[] dimensions) { return Generator.Same(value, dimensions); }
        /// <summary>
        /// Creates an array filled with random values
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to a random value</returns>
        public static OutArray Random(params long[] dimensions) { return Generator.Random(dimensions); }
    }
    #endregion

	#region Conversion operator
	/// <summary>
    /// Operator for converting a number to another type
    /// </summary>
	public struct ToUInt8 :
        IUnaryConvOp<double, T>, 
        IUnaryConvOp<float, T>, 
        IUnaryConvOp<sbyte, T>, 
        IUnaryConvOp<short, T>, 
        IUnaryConvOp<ushort, T>, 
        IUnaryConvOp<int, T>, 
        IUnaryConvOp<uint,T>, 
        IUnaryConvOp<long, T>, 
        IUnaryConvOp<ulong, T>,
		NumCIL.Generic.Operators.ITypeConversion
    {

        /// <summary>
        /// Converts the input from a <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(double a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(float a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(sbyte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ushort a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(short a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(uint a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(int a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ulong a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(long a) { return (T)a; }
    }
	#endregion
}

namespace NumCIL.Int16
{
    using T = System.Int16;
    using InArray = NumCIL.Generic.NdArray<System.Int16>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray : IEnumerable<InArray>
    {
        #region NdArray Mimics
        /// <summary>
        /// The value instance that gives access to values
        /// </summary>
        public InArray.ValueAccessor Value { get { return value.Value; } }
        /// <summary>
        /// A reference to the shape instance that describes this view
        /// </summary>
        public Shape Shape { get { return value.Shape; } }
        /// <summary>
        /// A reference to the underlying data storage
        /// </summary>
        public T[] AsArray() { return value.AsArray(); }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="index">The element to get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params long[] index] { get { return this.value[index]; } set { this.value[index] = value; } }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="ranges">The range get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params Range[] ranges] { get { return this.value[ranges]; } set { this.value[ranges] = value; } }
        /// <summary>
        /// Returns a flattened (1-d copy) of the current data view
        /// </summary>
        /// <returns>A flattened copy</returns>
        public OutArray Flatten() { return this.value.Flatten(); }
        /// <summary>
        /// Returns a copy of the underlying data, shaped as this view
        /// </summary>
        /// <returns>A copy of the view data</returns>
        public OutArray Clone() { return this.value.Clone(); }
        /// <summary>
        /// Generates a new view based on this array
        /// </summary>
        /// <param name="newshape">The new shape</param>
        /// <returns>The reshaped array</returns>
        public OutArray Reshape(Shape newshape) { return this.value.Reshape(newshape); }
        /// <summary>
        /// Returns a view that is a view of a single element
        /// </summary>
        /// <param name="element">The element to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(long element) { return this.value.Subview(element); }
        /// <summary>
        /// Returns a view that is a view of a range of elements
        /// </summary>
        /// <param name="range">The range to view</param>
        /// <param name="dimension">The dimension to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(Range range, long dimension) { return this.value.Subview(range, dimension); }
        /// <summary>
        /// Returnes a sliced subview of the data, optionally collapsing single element dimensions
        /// </summary>
        /// <param name="ranges">The ranges to view for each dimension</param>
        /// <param name="collapse">True if single element dimensions should be collapsed, false to retain all dimensions</param>
        /// <returns>A new view of the data</returns>
        public OutArray Subview(Range[] ranges, bool collapse) { return this.value.Subview(ranges, collapse); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<InArray> GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// A debug tag used for naming a view
        /// </summary>
        public string Name { get { return this.value.Name; } set { this.value.Name = value; } }
        /// <summary>
        /// The data accessor providing the data storage
        /// </summary>
        public NumCIL.Generic.IDataAccessor<T> DataAccessor { get { return this.value.DataAccessor; } }

        /// <summary>
        /// Constructs a NdArray that is a scalar wrapper,
        /// allows simple scalar operations on arbitrary
        /// NdArrays
        /// </summary>
        /// <param name="value">The scalar value</param>
        public NdArray(T value)
            : this(new NumCIL.Generic.DefaultAccessor<T>(new T[] { value }))
        {
        }

        /// <summary>
        /// Constructs a new NdArray with the specified shape
        /// </summary>
        /// <param name="shape">The shape of the new NdArray</param>
        public NdArray(Shape shape)
            : this(Generate.Empty(shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(T[] data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(NumCIL.Generic.IDataAccessor<T> data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="source">An existing array that will be re-shaped</param>
        /// <param name="newshape">The shape to view the array in</param>
        public NdArray(InArray source, Shape newshape)
            : this(new InArray(source, newshape))
        {
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.value.ToString();
        }

        /// <summary>
        /// Flushes pending operations on the array
        /// </summary>
        public void Flush() { this.value.Flush(); }

        /// <summary>
        /// Returns a transposed view of this array. If <paramref name="out"/> is supplied, the contents are copied into that array.
        /// </summary>
        /// <param name="out">Optional output array</param>
        /// <returns>A transposed view</returns>
        public OutArray Transpose(OutArray @out = null) { return value.Transpose(@out); }

        /// <summary>
        /// Gets or sets data in a transposed view
        /// </summary>
        public OutArray Transposed { get { return value.Transposed; } set { value.Transposed = this.value; } }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform</param>
        /// <param name="axis">The axis to repeat, if not speficied, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform in each axis</param>
        /// <param name="axis">The axis to repeat, if not specified, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long[] repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Concatenates an array onto this array, joined at the axis
        /// </summary>
        /// <param name="arg">The array to join</param>
        /// <param name="axis">The axis to join at</param>
        /// <returns>The joined array</returns>
        public OutArray Concatenate(OutArray arg, long axis = 0) { return this.value.Concatenate(arg, axis); }

        /// <summary>
        /// Sets the values viewed to the values from another array, i.e. copies the values
        /// </summary>
        /// <param name="arg">The data to copy</param>
        public void Set(OutArray arg) { this.value.Set(arg); }
        #endregion

        /// <summary>
        /// The only data member of the struct is a reference to the underlying view
        /// </summary>
        private readonly InArray value;
        /// <summary>
        /// Constructs a new typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array</param>
        public NdArray(InArray v) { this.value = v; }

        #region Implict conversion operators
        /// <summary>
        /// Implicit operator that returns a typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array to wrap</param>
        /// <returns>A wrapped array</returns>
        public static implicit operator OutArray(InArray v) { return v == null ? null : new OutArray(v); }
        /// <summary>
        /// Implicit operator that returns a basic array from a wrapped one
        /// </summary>
        /// <param name="v">The wrapper array</param>
        /// <returns>The basic array</returns>
        public static implicit operator InArray(NdArray v) { return ((object)v) == null ? null : v.value; }
        /// <summary>
        /// Implicit operator that returns a wrapped array from a scalar value
        /// </summary>
        /// <param name="v">The scalar value</param>
        /// <returns>A wrapped array representing the scalar value</returns>
        public static implicit operator OutArray(T v) { return new OutArray(v); }
        #endregion

        #region Operator implementations
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, OutArray b) { return UFunc.Apply<T, Add>(a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, OutArray b) { return UFunc.Apply<T, Sub>(a, b, null); }
        /// <summary>
        /// Calculates negation of the operand
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a) { return UFunc.Apply<T, Sub>(new OutArray((T)0), a, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, OutArray b) { return UFunc.Apply<T, Mul>(a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, OutArray b) { return UFunc.Apply<T, Div>(a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, OutArray b) { return UFunc.Apply<T, Mod>(a, b, null); }

        /// <summary>
        /// Calculates the incremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of incrementing each value</returns>
        public static OutArray operator ++(OutArray a) { return UFunc.Apply<T, Add>(a, (OutArray)1, null); }
        /// <summary>
        /// Calculates the decremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of decrementing each value</returns>
        public static OutArray operator --(OutArray a) { return UFunc.Apply<T, Sub>(a, (OutArray)1, null); }
        #endregion

        #region Common function implementations
        /// <summary>
        /// Copies all values from this NdArray to the output NdArray
        /// </summary>
        /// <param name="out">Optional target for addition, if null, a new array is created</param>
        /// <returns>An NdArray which is a copy of this array</returns>
        public OutArray Copy(OutArray @out = null) { return UFunc.Apply<T, NumCIL.CopyOp<T>>(this, @out); }
        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, op, @out); }
        /// <summary>
        /// Divides values of an NdArray with this NdArray and returns the modulo result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for modulo result, use to perform in-place modulo</param>
        /// <returns>An NdArray which is the modulo residues of dividing the two NdArrays</returns>
        public OutArray Mod(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mod>(this, op, @out); }
        /// <summary>
        /// Calculates the maximum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the max operation, use to perform in-place maximum calculation</param>
        /// <returns>An NdArray which is the maximum values of the two NdArrays</returns>
        public OutArray Max(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Max>(this, op, @out); }
        /// <summary>
        /// Calculates the minimum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the min operation, use to perform in-place minimum calculation</param>
        /// <returns>An NdArray which is the minimum values of the two NdArrays</returns>
        public OutArray Min(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Min>(this, op, @out); }

        /// <summary>
        /// Returns a new NdArray that is the result of calculating the square root for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the square root of all values</returns>
        public OutArray Sqrt(OutArray @out = null) { return UFunc.Apply<T, Sqrt>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the exponent for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the exponent of all values</returns>
        public OutArray Exp(OutArray @out = null) { return UFunc.Apply<T, Exp>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the absolute value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all absolute values</returns>
        public OutArray Abs(OutArray @out = null) { return UFunc.Apply<T, Abs>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic of all values</returns>
        public OutArray Log(OutArray @out = null) { return UFunc.Apply<T, Log>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic-10 value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic-10 of all values</returns>
        public OutArray Log10(OutArray @out = null) { return UFunc.Apply<T, Log10>(this, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the mathcing element in the operand NdArray
        /// </summary>
        /// <param name="op">The power-of values</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the values in the operand NdArray</returns>
        public OutArray Pow(NdArray op, OutArray @out = null) { return UFunc.Apply<T, Pow>(this, op, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the scalar value
        /// </summary>
        /// <param name="value">The power-of value</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the scalar value</returns>
        public OutArray Pow(T value, OutArray @out = null)
        {
            if (value == 2)
                return UFunc.Apply<T, Mul>(this, this, @out);
            else
                return UFunc.Apply<T, Pow>(this, (OutArray)value, @out);
        }
        /// <summary>
        /// Performs matrix multiplication on the two elements
        /// </summary>
        /// <param name="arg">The right-hand-side argument in matrix multiplication</param>
        /// <param name="out">Optional target for the multiplication</param>
        /// <returns>The matrix multiplication result</returns>
        public OutArray MatrixMultiply(OutArray arg, OutArray @out = null) { return UFunc.Matmul<T, Add, Mul>(this, arg, @out); }
        #endregion


        #region F# support for missing implicit operators
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(T a, OutArray b) { return UFunc.Apply<T, Add>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, T b) { return UFunc.Apply<T, Add>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(T a, OutArray b) { return UFunc.Apply<T, Sub>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, T b) { return UFunc.Apply<T, Sub>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(T a, OutArray b) { return UFunc.Apply<T, Mul>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, T b) { return UFunc.Apply<T, Mul>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(T a, OutArray b) { return UFunc.Apply<T, Div>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, T b) { return UFunc.Apply<T, Div>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(T a, OutArray b) { return UFunc.Apply<T, Mod>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, T b) { return UFunc.Apply<T, Mod>(a, (OutArray)b, null); }

        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(T op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, (OutArray)op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(T op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, (OutArray)op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(T op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, (OutArray)op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(T op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, (OutArray)op, @out); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(T a, OutArray b) { return UFunc.Apply<T, bool, Equal>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, T b) { return UFunc.Apply<T, bool, Equal>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(T a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, T b) { return UFunc.Apply<T, bool, NotEqual>(a, (OutArray)b, null); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(T a, OutArray b) { return UFunc.Apply<T, bool, LessThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, T b) { return UFunc.Apply<T, bool, LessThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(T a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, T b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, (OutArray)b, null); }
        #endregion

        #region Appliers for custom UFuncs
        /// <summary>
        /// Applies a unary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        public OutArray Apply(Func<T, T> op, OutArray @out = null) { return UFunc.Apply(op, this, @out); }
        /// <summary>
        /// Applies a binary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="b">An input operand</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        public OutArray Apply(Func<T, T, T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray @out = null) where C : struct, IUnaryOp<T> { return UFunc.Apply<T, C>(this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray b, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Apply<T, C>(this, b, @out); }
        /// <summary>
        /// Applies a nullary function to each element in this NdArray
        /// Note that Nullary functions are performed in-place
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <returns>This NdArray</returns>
        public OutArray Apply(INullaryOp<T> op) { UFunc.Apply<T>(op, this); return this; }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IUnaryOp<T> op, OutArray @out = null) { return UFunc.Apply<T>(op, this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IBinaryOp<T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }

        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <typeparam name="C">The function to apply reduction with</typeparam>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the reduction in-place</param>
        /// <returns>An NdArray that is the result of reducing the selected axis</returns>
        public OutArray Reduce<C>(long axis = 0, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Reduce<T, C>(this, axis, @out); }
        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <param name="op">The function to apply reduction with</param>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>A reduced array</returns>
        public OutArray Reduce(IBinaryOp<T> op, long axis = 0, OutArray @out = null) { return UFunc.Reduce<T>(op, this, axis, @out); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <typeparam name="C">The operation to perform</typeparam>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate<C>() where C : struct, IBinaryOp<T> { return UFunc.Aggregate<T, C>(this); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <param name="op">The operation to perform</param>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate(IBinaryOp<T> op) { return UFunc.Aggregate<T>(op, this); }

        /// <summary>
        /// Calculates the sum of all elements
        /// </summary>
        /// <returns>A scalar value that is the sum of all elements</returns>
        public T Sum() { return UFunc.Aggregate<T, Add>(this); }
        /// <summary>
        /// Calculates the maximum of all elements
        /// </summary>
        /// <returns>A scalar value that is the maximum of all elements</returns>
        public T Max() { return UFunc.Aggregate<T, Max>(this); }

        /// <summary>
        /// Calculates the minimum of all elements
        /// </summary>
        /// <returns>A scalar value that is the minimum of all elements</returns>
        public T Min() { return UFunc.Aggregate<T, Min>(this); }
        #endregion

		#region Conversion operators
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Double"/></returns>
        public static implicit operator OutArray(NumCIL.Double.NdArray a) { return UFunc.Apply<double, T, ToInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Single"/></returns>
        public static implicit operator OutArray(NumCIL.Float.NdArray a) { return UFunc.Apply<float, T, ToInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.SByte"/></returns>
        public static explicit operator OutArray(NumCIL.Int8.NdArray a) { return UFunc.Apply<sbyte, T, ToInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int32"/></returns>
        public static implicit operator OutArray(NumCIL.Int32.NdArray a) { return UFunc.Apply<int, T, ToInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int64"/></returns>
        public static implicit operator OutArray(NumCIL.Int64.NdArray a) { return UFunc.Apply<long, T, ToInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Byte"/></returns>
        public static explicit operator OutArray(NumCIL.UInt8.NdArray a) { return UFunc.Apply<byte, T, ToInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt16"/></returns>
        public static explicit operator OutArray(NumCIL.UInt16.NdArray a) { return UFunc.Apply<ushort, T, ToInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt32"/></returns>
        public static explicit operator OutArray(NumCIL.UInt32.NdArray a) { return UFunc.Apply<uint, T, ToInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt64"/></returns>
        public static explicit operator OutArray(NumCIL.UInt64.NdArray a) { return UFunc.Apply<ulong, T, ToInt16>(a); }
				#endregion

		#region Logical/Bitwise operator overloads
        /// <summary>
        /// Calculates the and of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of and-ing the two input operands</returns>
        public static OutArray operator &(OutArray a, OutArray b) { return UFunc.Apply<T, And>(a, b, null); }
        /// <summary>
        /// Calculates the or of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of or-ing the two input operands</returns>
        public static OutArray operator |(OutArray a, OutArray b) { return UFunc.Apply<T, Or>(a, b, null); }
        /// <summary>
        /// Calculates the xor of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of xor-ing the two input operands</returns>
        public static OutArray operator ^(OutArray a, OutArray b) { return UFunc.Apply<T, Xor>(a, b, null); }
        /// <summary>
        /// Calculates the bitwise complement of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The bitwise complement of the input operand</returns>
        public static OutArray operator !(OutArray a) { return UFunc.Apply<T, Invert>(a, null); }
		#endregion

		#region Comparison operator overloads
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, OutArray b) { return UFunc.Apply<T, bool, Equal>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator ==(OutArray a, object b) { return ((object)a) == b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator !=(OutArray a, object b) { return ((object)a) != b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, b, null); }
		#endregion

		#region System.Object overrides
		/// <summary>
		/// Compares this object to another
		/// </summary>
		/// <returns>A value indicating if the two elements are equal</returns>
		public override bool Equals(object o)
		{
			return this == o;
		}

		/// <summary>
		/// Returns a hashcode for comparing this object to others
		/// </summary>
		/// <returns>A hash code for this instance</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}
		#endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly CopyOp<T> Copy;
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly Add Add;
        /// <summary>
        /// The subtraction operation
        /// </summary>
        public static readonly Sub Sub;
        /// <summary>
        /// The multiplication operation
        /// </summary>
        public static readonly Mul Mul;
        /// <summary>
        /// The division operation
        /// </summary>
        public static readonly Div Div;
        /// <summary>
        /// The modulo operation
        /// </summary>
        public static readonly Mod Mod;
        /// <summary>
        /// The maximum operation
        /// </summary>
        public static readonly Max Max;
        /// <summary>
        /// The minimum operation
        /// </summary>
        public static readonly Min Min;
        /// <summary>
        /// The absolute operation
        /// </summary>
        public static readonly Abs Abs;
        /// <summary>
        /// The square root operation
        /// </summary>
        public static readonly Sqrt Sqrt;
        /// <summary>
        /// The exponential operation
        /// </summary>
        public static readonly Exp Exp;
        /// <summary>
        /// The logarithmic operation
        /// </summary>
        public static readonly Log Log;
        /// <summary>
        /// The logarithmic-10 operation
        /// </summary>
        public static readonly Log10 Log10;
        /// <summary>
        /// The power operation
        /// </summary>
        public static readonly Pow Pow;
        /// <summary>
        /// The arc cosine operation
        /// </summary>
        public static readonly Acos Acos;
        /// <summary>
        /// The arc sine operation
        /// </summary>
        public static readonly Asin Asin;
        /// <summary>
        /// The arc tangent operation
        /// </summary>
        public static readonly Atan Atan;
        /// <summary>
        /// The cosine operation
        /// </summary>
        public static readonly Cos Cos;
        /// <summary>
        /// The sine operation
        /// </summary>
        public static readonly Sin Sin;
        /// <summary>
        /// The tangent operation
        /// </summary>
        public static readonly Tan Tan;
        /// <summary>
        /// The hyperbolic cosine operation
        /// </summary>
        public static readonly Cosh Cosh;
        /// <summary>
        /// The hyperbolic sine operation
        /// </summary>
        public static readonly Sinh Sihn;
        /// <summary>
        /// The hyperbolic tangent operation
        /// </summary>
        public static readonly Tanh Tanh;
        /// <summary>
        /// The and operation
        /// </summary>
        public static readonly And And;
        /// <summary>
        /// The or operation
        /// </summary>
        public static readonly Or Or;
        /// <summary>
        /// The xor operation
        /// </summary>
        public static readonly Xor Xor;
        /// <summary>
        /// The invert operation
        /// </summary>
        public static readonly Invert Invert;

    }
    #endregion

	#region Comparison operators
    /// <summary>
    /// The equal Equal implementation
    /// </summary>
    public struct Equal : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IEqual
    {
        /// <summary>
        /// Implementation of Equal test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a == b; }
		
        /// <summary>
        /// Applies the Equal operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, Equal>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThan implementation
    /// </summary>
    public struct GreaterThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThan
    {
        /// <summary>
        /// Implementation of GreaterThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a > b; }
		
        /// <summary>
        /// Applies the GreaterThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThan implementation
    /// </summary>
    public struct LessThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThan
    {
        /// <summary>
        /// Implementation of LessThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a < b; }
		
        /// <summary>
        /// Applies the LessThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThanOrEqual implementation
    /// </summary>
    public struct GreaterThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThanOrEqual
    {
        /// <summary>
        /// Implementation of GreaterThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a >= b; }
		
        /// <summary>
        /// Applies the GreaterThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThanOrEqual implementation
    /// </summary>
    public struct LessThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThanOrEqual
    {
        /// <summary>
        /// Implementation of LessThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a <= b; }
		
        /// <summary>
        /// Applies the LessThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal NotEqual implementation
    /// </summary>
    public struct NotEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.INotEqual
    {
        /// <summary>
        /// Implementation of NotEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a != b; }
		
        /// <summary>
        /// Applies the NotEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, NotEqual>(in1, in2, @out); }
    }

	#endregion

    #region Operator implementations
    /// <summary>
    /// The copy operator implementation
    /// </summary>
    public struct Copy
    {
        /// <summary>
        /// Applies the copy operation to the input operand
        /// </summary>
        /// <param name="in1">The input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise copy of the input view</returns>
        public static OutArray Apply(OutArray in1, OutArray @out = null)
        { return UFunc.Apply<T, NumCIL.CopyOp<T>>(in1, @out); }
    }

	#region Binary operation implementations
    /// <summary>
    /// The Add operator implementation
    /// </summary>
    public struct Add : IBinaryOp<T>, NumCIL.Generic.Operators.IAdd
    {
        /// <summary>
        /// Implementation of Add with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Add with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a + b); }
		
        /// <summary>
        /// Reduces the input array with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Add>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Add>(arg); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>(in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Add>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Sub operator implementation
    /// </summary>
    public struct Sub : IBinaryOp<T>, NumCIL.Generic.Operators.ISub
    {
        /// <summary>
        /// Implementation of Sub with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Sub with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a - b); }
		
        /// <summary>
        /// Reduces the input array with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Sub>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Sub>(arg); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>(in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Sub>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mul operator implementation
    /// </summary>
    public struct Mul : IBinaryOp<T>, NumCIL.Generic.Operators.IMul
    {
        /// <summary>
        /// Implementation of Mul with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mul with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a * b); }
		
        /// <summary>
        /// Reduces the input array with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mul>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mul>(arg); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mul>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Div operator implementation
    /// </summary>
    public struct Div : IBinaryOp<T>, NumCIL.Generic.Operators.IDiv
    {
        /// <summary>
        /// Implementation of Div with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Div with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a / b); }
		
        /// <summary>
        /// Reduces the input array with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Div>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Div>(arg); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>(in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Div>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mod operator implementation
    /// </summary>
    public struct Mod : IBinaryOp<T>, NumCIL.Generic.Operators.IMod
    {
        /// <summary>
        /// Implementation of Mod with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mod with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a % b); }
		
        /// <summary>
        /// Reduces the input array with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mod>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mod>(arg); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mod>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Min operator implementation
    /// </summary>
    public struct Min : IBinaryOp<T>, NumCIL.Generic.Operators.IMin
    {
        /// <summary>
        /// Implementation of Min with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Min with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Min(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Min>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Min>(arg); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>(in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Min>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Max operator implementation
    /// </summary>
    public struct Max : IBinaryOp<T>, NumCIL.Generic.Operators.IMax
    {
        /// <summary>
        /// Implementation of Max with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Max with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Max(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Max>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Max>(arg); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>(in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Max>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Pow operator implementation
    /// </summary>
    public struct Pow : IBinaryOp<T>, NumCIL.Generic.Operators.IPow
    {
        /// <summary>
        /// Implementation of Pow with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Pow with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Pow(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Pow>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Pow>(arg); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>(in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ 
			if (in2 == (T)2)
				return UFunc.Apply<T, Mul>(in1, in1, @out);
			else
				return UFunc.Apply<T, Pow>(in1, (OutArray)in2, @out);
		}
		
    }

    /// <summary>
    /// The And operator implementation
    /// </summary>
    public struct And : IBinaryOp<T>, NumCIL.Generic.Operators.IAnd
    {
        /// <summary>
        /// Implementation of And with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of And with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a & b); }
		
        /// <summary>
        /// Reduces the input array with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, And>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, And>(arg); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>(in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, And>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Or operator implementation
    /// </summary>
    public struct Or : IBinaryOp<T>, NumCIL.Generic.Operators.IOr
    {
        /// <summary>
        /// Implementation of Or with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Or with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a | b); }
		
        /// <summary>
        /// Reduces the input array with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Or>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Or>(arg); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>(in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Or>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Xor operator implementation
    /// </summary>
    public struct Xor : IBinaryOp<T>, NumCIL.Generic.Operators.IXor
    {
        /// <summary>
        /// Implementation of Xor with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Xor with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a ^ b); }
		
        /// <summary>
        /// Reduces the input array with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Xor>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Xor>(arg); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>(in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Xor>(in1, (OutArray)in2, @out); }
    }

	#endregion

	#region Unary operations implementation
    /// <summary>
    /// The Sqrt operation implementation
    /// </summary>
    public struct Sqrt : IUnaryOp<T>, NumCIL.Generic.Operators.ISqrt
    {
        /// <summary>
        /// Implementation of the Sqrt operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sqrt to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sqrt(a); }
		
        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>(@in, @out); }

        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Exp operation implementation
    /// </summary>
    public struct Exp : IUnaryOp<T>, NumCIL.Generic.Operators.IExp
    {
        /// <summary>
        /// Implementation of the Exp operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Exp to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Exp(a); }
		
        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>(@in, @out); }

        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Abs operation implementation
    /// </summary>
    public struct Abs : IUnaryOp<T>, NumCIL.Generic.Operators.IAbs
    {
        /// <summary>
        /// Implementation of the Abs operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Abs to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Abs(a); }
		
        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>(@in, @out); }

        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sin operation implementation
    /// </summary>
    public struct Sin : IUnaryOp<T>, NumCIL.Generic.Operators.ISin
    {
        /// <summary>
        /// Implementation of the Sin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sin(a); }
		
        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>(@in, @out); }

        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cos operation implementation
    /// </summary>
    public struct Cos : IUnaryOp<T>, NumCIL.Generic.Operators.ICos
    {
        /// <summary>
        /// Implementation of the Cos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cos(a); }
		
        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>(@in, @out); }

        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tan operation implementation
    /// </summary>
    public struct Tan : IUnaryOp<T>, NumCIL.Generic.Operators.ITan
    {
        /// <summary>
        /// Implementation of the Tan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tan(a); }
		
        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>(@in, @out); }

        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Asin operation implementation
    /// </summary>
    public struct Asin : IUnaryOp<T>, NumCIL.Generic.Operators.IAsin
    {
        /// <summary>
        /// Implementation of the Asin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Asin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Asin(a); }
		
        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>(@in, @out); }

        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Acos operation implementation
    /// </summary>
    public struct Acos : IUnaryOp<T>, NumCIL.Generic.Operators.IAcos
    {
        /// <summary>
        /// Implementation of the Acos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Acos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Acos(a); }
		
        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>(@in, @out); }

        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Atan operation implementation
    /// </summary>
    public struct Atan : IUnaryOp<T>, NumCIL.Generic.Operators.IAtan
    {
        /// <summary>
        /// Implementation of the Atan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Atan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Atan(a); }
		
        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>(@in, @out); }

        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sinh operation implementation
    /// </summary>
    public struct Sinh : IUnaryOp<T>, NumCIL.Generic.Operators.ISinh
    {
        /// <summary>
        /// Implementation of the Sinh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sinh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sinh(a); }
		
        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>(@in, @out); }

        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cosh operation implementation
    /// </summary>
    public struct Cosh : IUnaryOp<T>, NumCIL.Generic.Operators.ICosh
    {
        /// <summary>
        /// Implementation of the Cosh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cosh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cosh(a); }
		
        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>(@in, @out); }

        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tanh operation implementation
    /// </summary>
    public struct Tanh : IUnaryOp<T>, NumCIL.Generic.Operators.ITanh
    {
        /// <summary>
        /// Implementation of the Tanh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tanh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tanh(a); }
		
        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>(@in, @out); }

        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log operation implementation
    /// </summary>
    public struct Log : IUnaryOp<T>, NumCIL.Generic.Operators.ILog
    {
        /// <summary>
        /// Implementation of the Log operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log(a); }
		
        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>(@in, @out); }

        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log10 operation implementation
    /// </summary>
    public struct Log10 : IUnaryOp<T>, NumCIL.Generic.Operators.ILog10
    {
        /// <summary>
        /// Implementation of the Log10 operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log10 to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log10(a); }
		
        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>(@in, @out); }

        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Invert operation implementation
    /// </summary>
    public struct Invert : IUnaryOp<T>, NumCIL.Generic.Operators.IInvert
    {
        /// <summary>
        /// Implementation of the Invert operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Invert to the operand</returns>
        public T Op(T a) 
		{ return (T)(~a); }
		
        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>(@in, @out); }

        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sign operation implementation
    /// </summary>
    public struct Sign : IUnaryOp<T>, NumCIL.Generic.Operators.ISign
    {
        /// <summary>
        /// Implementation of the Sign operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sign to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sign(a); }
		
        /// <summary>
        /// Applies the Sign operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sign>(@in, @out); }

        /// <summary>
        /// Applies the Sign operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sign>((OutArray)@in, @out); }
    }

	#endregion
	#endregion

    #region Generate mimics
    /// <summary>
    /// Generates basic initial arrays
    /// </summary>
    public static class Generate
    {
        /// <summary>
        /// The factory class that produces the NdArray instances
        /// </summary>
        public static NumCIL.Generic.IGenerator<T> Generator = new NumCIL.Generic.Generator<T, NumCIL.Generic.RandomGeneratorOpInt16, NumCIL.Generic.RangeGeneratorOp<T, NumCIL.Generic.NumberConverterInt16>, NumCIL.Generic.NumberConverterInt16>();

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(Shape shape) { return Generator.Range(shape); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(Shape shape) { return Generator.Ones(shape); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(Shape shape) { return Generator.Zeroes(shape); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with uninitialized data</returns>
        public static OutArray Empty(Shape shape) { return Generator.Empty(shape); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to fill the array with</param>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, Shape shape) { return Generator.Same(value, shape); }
        /// <summary>
        /// Creates an array filled with the value random numbers
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to random numbers</returns>
        public static OutArray Random(Shape shape) { return Generator.Random(shape); }

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(params long[] dimensions) { return Generator.Range(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(params long[] dimensions) { return Generator.Ones(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(params long[] dimensions) { return Generator.Zeroes(dimensions); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with uninitialized values</returns>
        public static OutArray Empty(params long[] dimensions) { return Generator.Empty(dimensions); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to set fill the array with</param>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, params long[] dimensions) { return Generator.Same(value, dimensions); }
        /// <summary>
        /// Creates an array filled with random values
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to a random value</returns>
        public static OutArray Random(params long[] dimensions) { return Generator.Random(dimensions); }
    }
    #endregion

	#region Conversion operator
	/// <summary>
    /// Operator for converting a number to another type
    /// </summary>
	public struct ToInt16 :
        IUnaryConvOp<double, T>, 
        IUnaryConvOp<float, T>, 
        IUnaryConvOp<sbyte, T>, 
        IUnaryConvOp<byte,T>, 
        IUnaryConvOp<ushort, T>, 
        IUnaryConvOp<int, T>, 
        IUnaryConvOp<uint,T>, 
        IUnaryConvOp<long, T>, 
        IUnaryConvOp<ulong, T>,
		NumCIL.Generic.Operators.ITypeConversion
    {

        /// <summary>
        /// Converts the input from a <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(double a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(float a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(sbyte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(byte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ushort a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(uint a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(int a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ulong a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(long a) { return (T)a; }
    }
	#endregion
}

namespace NumCIL.UInt16
{
    using T = System.UInt16;
    using InArray = NumCIL.Generic.NdArray<System.UInt16>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray : IEnumerable<InArray>
    {
        #region NdArray Mimics
        /// <summary>
        /// The value instance that gives access to values
        /// </summary>
        public InArray.ValueAccessor Value { get { return value.Value; } }
        /// <summary>
        /// A reference to the shape instance that describes this view
        /// </summary>
        public Shape Shape { get { return value.Shape; } }
        /// <summary>
        /// A reference to the underlying data storage
        /// </summary>
        public T[] AsArray() { return value.AsArray(); }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="index">The element to get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params long[] index] { get { return this.value[index]; } set { this.value[index] = value; } }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="ranges">The range get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params Range[] ranges] { get { return this.value[ranges]; } set { this.value[ranges] = value; } }
        /// <summary>
        /// Returns a flattened (1-d copy) of the current data view
        /// </summary>
        /// <returns>A flattened copy</returns>
        public OutArray Flatten() { return this.value.Flatten(); }
        /// <summary>
        /// Returns a copy of the underlying data, shaped as this view
        /// </summary>
        /// <returns>A copy of the view data</returns>
        public OutArray Clone() { return this.value.Clone(); }
        /// <summary>
        /// Generates a new view based on this array
        /// </summary>
        /// <param name="newshape">The new shape</param>
        /// <returns>The reshaped array</returns>
        public OutArray Reshape(Shape newshape) { return this.value.Reshape(newshape); }
        /// <summary>
        /// Returns a view that is a view of a single element
        /// </summary>
        /// <param name="element">The element to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(long element) { return this.value.Subview(element); }
        /// <summary>
        /// Returns a view that is a view of a range of elements
        /// </summary>
        /// <param name="range">The range to view</param>
        /// <param name="dimension">The dimension to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(Range range, long dimension) { return this.value.Subview(range, dimension); }
        /// <summary>
        /// Returnes a sliced subview of the data, optionally collapsing single element dimensions
        /// </summary>
        /// <param name="ranges">The ranges to view for each dimension</param>
        /// <param name="collapse">True if single element dimensions should be collapsed, false to retain all dimensions</param>
        /// <returns>A new view of the data</returns>
        public OutArray Subview(Range[] ranges, bool collapse) { return this.value.Subview(ranges, collapse); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<InArray> GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// A debug tag used for naming a view
        /// </summary>
        public string Name { get { return this.value.Name; } set { this.value.Name = value; } }
        /// <summary>
        /// The data accessor providing the data storage
        /// </summary>
        public NumCIL.Generic.IDataAccessor<T> DataAccessor { get { return this.value.DataAccessor; } }

        /// <summary>
        /// Constructs a NdArray that is a scalar wrapper,
        /// allows simple scalar operations on arbitrary
        /// NdArrays
        /// </summary>
        /// <param name="value">The scalar value</param>
        public NdArray(T value)
            : this(new NumCIL.Generic.DefaultAccessor<T>(new T[] { value }))
        {
        }

        /// <summary>
        /// Constructs a new NdArray with the specified shape
        /// </summary>
        /// <param name="shape">The shape of the new NdArray</param>
        public NdArray(Shape shape)
            : this(Generate.Empty(shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(T[] data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(NumCIL.Generic.IDataAccessor<T> data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="source">An existing array that will be re-shaped</param>
        /// <param name="newshape">The shape to view the array in</param>
        public NdArray(InArray source, Shape newshape)
            : this(new InArray(source, newshape))
        {
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.value.ToString();
        }

        /// <summary>
        /// Flushes pending operations on the array
        /// </summary>
        public void Flush() { this.value.Flush(); }

        /// <summary>
        /// Returns a transposed view of this array. If <paramref name="out"/> is supplied, the contents are copied into that array.
        /// </summary>
        /// <param name="out">Optional output array</param>
        /// <returns>A transposed view</returns>
        public OutArray Transpose(OutArray @out = null) { return value.Transpose(@out); }

        /// <summary>
        /// Gets or sets data in a transposed view
        /// </summary>
        public OutArray Transposed { get { return value.Transposed; } set { value.Transposed = this.value; } }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform</param>
        /// <param name="axis">The axis to repeat, if not speficied, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform in each axis</param>
        /// <param name="axis">The axis to repeat, if not specified, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long[] repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Concatenates an array onto this array, joined at the axis
        /// </summary>
        /// <param name="arg">The array to join</param>
        /// <param name="axis">The axis to join at</param>
        /// <returns>The joined array</returns>
        public OutArray Concatenate(OutArray arg, long axis = 0) { return this.value.Concatenate(arg, axis); }

        /// <summary>
        /// Sets the values viewed to the values from another array, i.e. copies the values
        /// </summary>
        /// <param name="arg">The data to copy</param>
        public void Set(OutArray arg) { this.value.Set(arg); }
        #endregion

        /// <summary>
        /// The only data member of the struct is a reference to the underlying view
        /// </summary>
        private readonly InArray value;
        /// <summary>
        /// Constructs a new typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array</param>
        public NdArray(InArray v) { this.value = v; }

        #region Implict conversion operators
        /// <summary>
        /// Implicit operator that returns a typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array to wrap</param>
        /// <returns>A wrapped array</returns>
        public static implicit operator OutArray(InArray v) { return v == null ? null : new OutArray(v); }
        /// <summary>
        /// Implicit operator that returns a basic array from a wrapped one
        /// </summary>
        /// <param name="v">The wrapper array</param>
        /// <returns>The basic array</returns>
        public static implicit operator InArray(NdArray v) { return ((object)v) == null ? null : v.value; }
        /// <summary>
        /// Implicit operator that returns a wrapped array from a scalar value
        /// </summary>
        /// <param name="v">The scalar value</param>
        /// <returns>A wrapped array representing the scalar value</returns>
        public static implicit operator OutArray(T v) { return new OutArray(v); }
        #endregion

        #region Operator implementations
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, OutArray b) { return UFunc.Apply<T, Add>(a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, OutArray b) { return UFunc.Apply<T, Sub>(a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, OutArray b) { return UFunc.Apply<T, Mul>(a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, OutArray b) { return UFunc.Apply<T, Div>(a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, OutArray b) { return UFunc.Apply<T, Mod>(a, b, null); }

        /// <summary>
        /// Calculates the incremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of incrementing each value</returns>
        public static OutArray operator ++(OutArray a) { return UFunc.Apply<T, Add>(a, (OutArray)1, null); }
        /// <summary>
        /// Calculates the decremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of decrementing each value</returns>
        public static OutArray operator --(OutArray a) { return UFunc.Apply<T, Sub>(a, (OutArray)1, null); }
        #endregion

        #region Common function implementations
        /// <summary>
        /// Copies all values from this NdArray to the output NdArray
        /// </summary>
        /// <param name="out">Optional target for addition, if null, a new array is created</param>
        /// <returns>An NdArray which is a copy of this array</returns>
        public OutArray Copy(OutArray @out = null) { return UFunc.Apply<T, NumCIL.CopyOp<T>>(this, @out); }
        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, op, @out); }
        /// <summary>
        /// Divides values of an NdArray with this NdArray and returns the modulo result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for modulo result, use to perform in-place modulo</param>
        /// <returns>An NdArray which is the modulo residues of dividing the two NdArrays</returns>
        public OutArray Mod(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mod>(this, op, @out); }
        /// <summary>
        /// Calculates the maximum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the max operation, use to perform in-place maximum calculation</param>
        /// <returns>An NdArray which is the maximum values of the two NdArrays</returns>
        public OutArray Max(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Max>(this, op, @out); }
        /// <summary>
        /// Calculates the minimum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the min operation, use to perform in-place minimum calculation</param>
        /// <returns>An NdArray which is the minimum values of the two NdArrays</returns>
        public OutArray Min(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Min>(this, op, @out); }

        /// <summary>
        /// Returns a new NdArray that is the result of calculating the square root for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the square root of all values</returns>
        public OutArray Sqrt(OutArray @out = null) { return UFunc.Apply<T, Sqrt>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the exponent for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the exponent of all values</returns>
        public OutArray Exp(OutArray @out = null) { return UFunc.Apply<T, Exp>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic of all values</returns>
        public OutArray Log(OutArray @out = null) { return UFunc.Apply<T, Log>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic-10 value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic-10 of all values</returns>
        public OutArray Log10(OutArray @out = null) { return UFunc.Apply<T, Log10>(this, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the mathcing element in the operand NdArray
        /// </summary>
        /// <param name="op">The power-of values</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the values in the operand NdArray</returns>
        public OutArray Pow(NdArray op, OutArray @out = null) { return UFunc.Apply<T, Pow>(this, op, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the scalar value
        /// </summary>
        /// <param name="value">The power-of value</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the scalar value</returns>
        public OutArray Pow(T value, OutArray @out = null)
        {
            if (value == 2)
                return UFunc.Apply<T, Mul>(this, this, @out);
            else
                return UFunc.Apply<T, Pow>(this, (OutArray)value, @out);
        }
        /// <summary>
        /// Performs matrix multiplication on the two elements
        /// </summary>
        /// <param name="arg">The right-hand-side argument in matrix multiplication</param>
        /// <param name="out">Optional target for the multiplication</param>
        /// <returns>The matrix multiplication result</returns>
        public OutArray MatrixMultiply(OutArray arg, OutArray @out = null) { return UFunc.Matmul<T, Add, Mul>(this, arg, @out); }
        #endregion


        #region F# support for missing implicit operators
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(T a, OutArray b) { return UFunc.Apply<T, Add>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, T b) { return UFunc.Apply<T, Add>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(T a, OutArray b) { return UFunc.Apply<T, Sub>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, T b) { return UFunc.Apply<T, Sub>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(T a, OutArray b) { return UFunc.Apply<T, Mul>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, T b) { return UFunc.Apply<T, Mul>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(T a, OutArray b) { return UFunc.Apply<T, Div>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, T b) { return UFunc.Apply<T, Div>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(T a, OutArray b) { return UFunc.Apply<T, Mod>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, T b) { return UFunc.Apply<T, Mod>(a, (OutArray)b, null); }

        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(T op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, (OutArray)op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(T op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, (OutArray)op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(T op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, (OutArray)op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(T op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, (OutArray)op, @out); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(T a, OutArray b) { return UFunc.Apply<T, bool, Equal>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, T b) { return UFunc.Apply<T, bool, Equal>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(T a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, T b) { return UFunc.Apply<T, bool, NotEqual>(a, (OutArray)b, null); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(T a, OutArray b) { return UFunc.Apply<T, bool, LessThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, T b) { return UFunc.Apply<T, bool, LessThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(T a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, T b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, (OutArray)b, null); }
        #endregion

        #region Appliers for custom UFuncs
        /// <summary>
        /// Applies a unary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        public OutArray Apply(Func<T, T> op, OutArray @out = null) { return UFunc.Apply(op, this, @out); }
        /// <summary>
        /// Applies a binary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="b">An input operand</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        public OutArray Apply(Func<T, T, T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray @out = null) where C : struct, IUnaryOp<T> { return UFunc.Apply<T, C>(this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray b, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Apply<T, C>(this, b, @out); }
        /// <summary>
        /// Applies a nullary function to each element in this NdArray
        /// Note that Nullary functions are performed in-place
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <returns>This NdArray</returns>
        public OutArray Apply(INullaryOp<T> op) { UFunc.Apply<T>(op, this); return this; }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IUnaryOp<T> op, OutArray @out = null) { return UFunc.Apply<T>(op, this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IBinaryOp<T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }

        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <typeparam name="C">The function to apply reduction with</typeparam>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the reduction in-place</param>
        /// <returns>An NdArray that is the result of reducing the selected axis</returns>
        public OutArray Reduce<C>(long axis = 0, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Reduce<T, C>(this, axis, @out); }
        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <param name="op">The function to apply reduction with</param>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>A reduced array</returns>
        public OutArray Reduce(IBinaryOp<T> op, long axis = 0, OutArray @out = null) { return UFunc.Reduce<T>(op, this, axis, @out); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <typeparam name="C">The operation to perform</typeparam>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate<C>() where C : struct, IBinaryOp<T> { return UFunc.Aggregate<T, C>(this); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <param name="op">The operation to perform</param>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate(IBinaryOp<T> op) { return UFunc.Aggregate<T>(op, this); }

        /// <summary>
        /// Calculates the sum of all elements
        /// </summary>
        /// <returns>A scalar value that is the sum of all elements</returns>
        public T Sum() { return UFunc.Aggregate<T, Add>(this); }
        /// <summary>
        /// Calculates the maximum of all elements
        /// </summary>
        /// <returns>A scalar value that is the maximum of all elements</returns>
        public T Max() { return UFunc.Aggregate<T, Max>(this); }

        /// <summary>
        /// Calculates the minimum of all elements
        /// </summary>
        /// <returns>A scalar value that is the minimum of all elements</returns>
        public T Min() { return UFunc.Aggregate<T, Min>(this); }
        #endregion

		#region Conversion operators
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Double"/></returns>
        public static implicit operator OutArray(NumCIL.Double.NdArray a) { return UFunc.Apply<double, T, ToUInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Single"/></returns>
        public static implicit operator OutArray(NumCIL.Float.NdArray a) { return UFunc.Apply<float, T, ToUInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.SByte"/></returns>
        public static explicit operator OutArray(NumCIL.Int8.NdArray a) { return UFunc.Apply<sbyte, T, ToUInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int16"/></returns>
        public static explicit operator OutArray(NumCIL.Int16.NdArray a) { return UFunc.Apply<short, T, ToUInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int32"/></returns>
        public static implicit operator OutArray(NumCIL.Int32.NdArray a) { return UFunc.Apply<int, T, ToUInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int64"/></returns>
        public static implicit operator OutArray(NumCIL.Int64.NdArray a) { return UFunc.Apply<long, T, ToUInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Byte"/></returns>
        public static explicit operator OutArray(NumCIL.UInt8.NdArray a) { return UFunc.Apply<byte, T, ToUInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt32"/></returns>
        public static implicit operator OutArray(NumCIL.UInt32.NdArray a) { return UFunc.Apply<uint, T, ToUInt16>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt64"/></returns>
        public static implicit operator OutArray(NumCIL.UInt64.NdArray a) { return UFunc.Apply<ulong, T, ToUInt16>(a); }
				#endregion

		#region Logical/Bitwise operator overloads
        /// <summary>
        /// Calculates the and of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of and-ing the two input operands</returns>
        public static OutArray operator &(OutArray a, OutArray b) { return UFunc.Apply<T, And>(a, b, null); }
        /// <summary>
        /// Calculates the or of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of or-ing the two input operands</returns>
        public static OutArray operator |(OutArray a, OutArray b) { return UFunc.Apply<T, Or>(a, b, null); }
        /// <summary>
        /// Calculates the xor of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of xor-ing the two input operands</returns>
        public static OutArray operator ^(OutArray a, OutArray b) { return UFunc.Apply<T, Xor>(a, b, null); }
        /// <summary>
        /// Calculates the bitwise complement of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The bitwise complement of the input operand</returns>
        public static OutArray operator !(OutArray a) { return UFunc.Apply<T, Invert>(a, null); }
		#endregion

		#region Comparison operator overloads
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, OutArray b) { return UFunc.Apply<T, bool, Equal>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator ==(OutArray a, object b) { return ((object)a) == b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator !=(OutArray a, object b) { return ((object)a) != b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, b, null); }
		#endregion

		#region System.Object overrides
		/// <summary>
		/// Compares this object to another
		/// </summary>
		/// <returns>A value indicating if the two elements are equal</returns>
		public override bool Equals(object o)
		{
			return this == o;
		}

		/// <summary>
		/// Returns a hashcode for comparing this object to others
		/// </summary>
		/// <returns>A hash code for this instance</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}
		#endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly CopyOp<T> Copy;
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly Add Add;
        /// <summary>
        /// The subtraction operation
        /// </summary>
        public static readonly Sub Sub;
        /// <summary>
        /// The multiplication operation
        /// </summary>
        public static readonly Mul Mul;
        /// <summary>
        /// The division operation
        /// </summary>
        public static readonly Div Div;
        /// <summary>
        /// The modulo operation
        /// </summary>
        public static readonly Mod Mod;
        /// <summary>
        /// The maximum operation
        /// </summary>
        public static readonly Max Max;
        /// <summary>
        /// The minimum operation
        /// </summary>
        public static readonly Min Min;
        /// <summary>
        /// The square root operation
        /// </summary>
        public static readonly Sqrt Sqrt;
        /// <summary>
        /// The exponential operation
        /// </summary>
        public static readonly Exp Exp;
        /// <summary>
        /// The logarithmic operation
        /// </summary>
        public static readonly Log Log;
        /// <summary>
        /// The logarithmic-10 operation
        /// </summary>
        public static readonly Log10 Log10;
        /// <summary>
        /// The power operation
        /// </summary>
        public static readonly Pow Pow;
        /// <summary>
        /// The arc cosine operation
        /// </summary>
        public static readonly Acos Acos;
        /// <summary>
        /// The arc sine operation
        /// </summary>
        public static readonly Asin Asin;
        /// <summary>
        /// The arc tangent operation
        /// </summary>
        public static readonly Atan Atan;
        /// <summary>
        /// The cosine operation
        /// </summary>
        public static readonly Cos Cos;
        /// <summary>
        /// The sine operation
        /// </summary>
        public static readonly Sin Sin;
        /// <summary>
        /// The tangent operation
        /// </summary>
        public static readonly Tan Tan;
        /// <summary>
        /// The hyperbolic cosine operation
        /// </summary>
        public static readonly Cosh Cosh;
        /// <summary>
        /// The hyperbolic sine operation
        /// </summary>
        public static readonly Sinh Sihn;
        /// <summary>
        /// The hyperbolic tangent operation
        /// </summary>
        public static readonly Tanh Tanh;
        /// <summary>
        /// The and operation
        /// </summary>
        public static readonly And And;
        /// <summary>
        /// The or operation
        /// </summary>
        public static readonly Or Or;
        /// <summary>
        /// The xor operation
        /// </summary>
        public static readonly Xor Xor;
        /// <summary>
        /// The invert operation
        /// </summary>
        public static readonly Invert Invert;

    }
    #endregion

	#region Comparison operators
    /// <summary>
    /// The equal Equal implementation
    /// </summary>
    public struct Equal : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IEqual
    {
        /// <summary>
        /// Implementation of Equal test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a == b; }
		
        /// <summary>
        /// Applies the Equal operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, Equal>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThan implementation
    /// </summary>
    public struct GreaterThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThan
    {
        /// <summary>
        /// Implementation of GreaterThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a > b; }
		
        /// <summary>
        /// Applies the GreaterThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThan implementation
    /// </summary>
    public struct LessThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThan
    {
        /// <summary>
        /// Implementation of LessThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a < b; }
		
        /// <summary>
        /// Applies the LessThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThanOrEqual implementation
    /// </summary>
    public struct GreaterThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThanOrEqual
    {
        /// <summary>
        /// Implementation of GreaterThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a >= b; }
		
        /// <summary>
        /// Applies the GreaterThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThanOrEqual implementation
    /// </summary>
    public struct LessThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThanOrEqual
    {
        /// <summary>
        /// Implementation of LessThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a <= b; }
		
        /// <summary>
        /// Applies the LessThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal NotEqual implementation
    /// </summary>
    public struct NotEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.INotEqual
    {
        /// <summary>
        /// Implementation of NotEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a != b; }
		
        /// <summary>
        /// Applies the NotEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, NotEqual>(in1, in2, @out); }
    }

	#endregion

    #region Operator implementations
    /// <summary>
    /// The copy operator implementation
    /// </summary>
    public struct Copy
    {
        /// <summary>
        /// Applies the copy operation to the input operand
        /// </summary>
        /// <param name="in1">The input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise copy of the input view</returns>
        public static OutArray Apply(OutArray in1, OutArray @out = null)
        { return UFunc.Apply<T, NumCIL.CopyOp<T>>(in1, @out); }
    }

	#region Binary operation implementations
    /// <summary>
    /// The Add operator implementation
    /// </summary>
    public struct Add : IBinaryOp<T>, NumCIL.Generic.Operators.IAdd
    {
        /// <summary>
        /// Implementation of Add with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Add with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a + b); }
		
        /// <summary>
        /// Reduces the input array with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Add>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Add>(arg); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>(in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Add>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Sub operator implementation
    /// </summary>
    public struct Sub : IBinaryOp<T>, NumCIL.Generic.Operators.ISub
    {
        /// <summary>
        /// Implementation of Sub with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Sub with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a - b); }
		
        /// <summary>
        /// Reduces the input array with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Sub>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Sub>(arg); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>(in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Sub>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mul operator implementation
    /// </summary>
    public struct Mul : IBinaryOp<T>, NumCIL.Generic.Operators.IMul
    {
        /// <summary>
        /// Implementation of Mul with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mul with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a * b); }
		
        /// <summary>
        /// Reduces the input array with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mul>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mul>(arg); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mul>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Div operator implementation
    /// </summary>
    public struct Div : IBinaryOp<T>, NumCIL.Generic.Operators.IDiv
    {
        /// <summary>
        /// Implementation of Div with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Div with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a / b); }
		
        /// <summary>
        /// Reduces the input array with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Div>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Div>(arg); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>(in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Div>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mod operator implementation
    /// </summary>
    public struct Mod : IBinaryOp<T>, NumCIL.Generic.Operators.IMod
    {
        /// <summary>
        /// Implementation of Mod with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mod with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a % b); }
		
        /// <summary>
        /// Reduces the input array with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mod>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mod>(arg); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mod>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Min operator implementation
    /// </summary>
    public struct Min : IBinaryOp<T>, NumCIL.Generic.Operators.IMin
    {
        /// <summary>
        /// Implementation of Min with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Min with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Min(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Min>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Min>(arg); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>(in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Min>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Max operator implementation
    /// </summary>
    public struct Max : IBinaryOp<T>, NumCIL.Generic.Operators.IMax
    {
        /// <summary>
        /// Implementation of Max with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Max with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Max(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Max>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Max>(arg); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>(in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Max>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Pow operator implementation
    /// </summary>
    public struct Pow : IBinaryOp<T>, NumCIL.Generic.Operators.IPow
    {
        /// <summary>
        /// Implementation of Pow with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Pow with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Pow(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Pow>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Pow>(arg); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>(in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ 
			if (in2 == (T)2)
				return UFunc.Apply<T, Mul>(in1, in1, @out);
			else
				return UFunc.Apply<T, Pow>(in1, (OutArray)in2, @out);
		}
		
    }

    /// <summary>
    /// The And operator implementation
    /// </summary>
    public struct And : IBinaryOp<T>, NumCIL.Generic.Operators.IAnd
    {
        /// <summary>
        /// Implementation of And with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of And with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a & b); }
		
        /// <summary>
        /// Reduces the input array with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, And>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, And>(arg); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>(in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, And>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Or operator implementation
    /// </summary>
    public struct Or : IBinaryOp<T>, NumCIL.Generic.Operators.IOr
    {
        /// <summary>
        /// Implementation of Or with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Or with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a | b); }
		
        /// <summary>
        /// Reduces the input array with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Or>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Or>(arg); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>(in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Or>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Xor operator implementation
    /// </summary>
    public struct Xor : IBinaryOp<T>, NumCIL.Generic.Operators.IXor
    {
        /// <summary>
        /// Implementation of Xor with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Xor with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a ^ b); }
		
        /// <summary>
        /// Reduces the input array with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Xor>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Xor>(arg); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>(in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Xor>(in1, (OutArray)in2, @out); }
    }

	#endregion

	#region Unary operations implementation
    /// <summary>
    /// The Sqrt operation implementation
    /// </summary>
    public struct Sqrt : IUnaryOp<T>, NumCIL.Generic.Operators.ISqrt
    {
        /// <summary>
        /// Implementation of the Sqrt operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sqrt to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sqrt(a); }
		
        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>(@in, @out); }

        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Exp operation implementation
    /// </summary>
    public struct Exp : IUnaryOp<T>, NumCIL.Generic.Operators.IExp
    {
        /// <summary>
        /// Implementation of the Exp operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Exp to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Exp(a); }
		
        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>(@in, @out); }

        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sin operation implementation
    /// </summary>
    public struct Sin : IUnaryOp<T>, NumCIL.Generic.Operators.ISin
    {
        /// <summary>
        /// Implementation of the Sin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sin(a); }
		
        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>(@in, @out); }

        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cos operation implementation
    /// </summary>
    public struct Cos : IUnaryOp<T>, NumCIL.Generic.Operators.ICos
    {
        /// <summary>
        /// Implementation of the Cos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cos(a); }
		
        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>(@in, @out); }

        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tan operation implementation
    /// </summary>
    public struct Tan : IUnaryOp<T>, NumCIL.Generic.Operators.ITan
    {
        /// <summary>
        /// Implementation of the Tan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tan(a); }
		
        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>(@in, @out); }

        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Asin operation implementation
    /// </summary>
    public struct Asin : IUnaryOp<T>, NumCIL.Generic.Operators.IAsin
    {
        /// <summary>
        /// Implementation of the Asin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Asin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Asin(a); }
		
        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>(@in, @out); }

        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Acos operation implementation
    /// </summary>
    public struct Acos : IUnaryOp<T>, NumCIL.Generic.Operators.IAcos
    {
        /// <summary>
        /// Implementation of the Acos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Acos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Acos(a); }
		
        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>(@in, @out); }

        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Atan operation implementation
    /// </summary>
    public struct Atan : IUnaryOp<T>, NumCIL.Generic.Operators.IAtan
    {
        /// <summary>
        /// Implementation of the Atan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Atan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Atan(a); }
		
        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>(@in, @out); }

        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sinh operation implementation
    /// </summary>
    public struct Sinh : IUnaryOp<T>, NumCIL.Generic.Operators.ISinh
    {
        /// <summary>
        /// Implementation of the Sinh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sinh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sinh(a); }
		
        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>(@in, @out); }

        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cosh operation implementation
    /// </summary>
    public struct Cosh : IUnaryOp<T>, NumCIL.Generic.Operators.ICosh
    {
        /// <summary>
        /// Implementation of the Cosh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cosh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cosh(a); }
		
        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>(@in, @out); }

        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tanh operation implementation
    /// </summary>
    public struct Tanh : IUnaryOp<T>, NumCIL.Generic.Operators.ITanh
    {
        /// <summary>
        /// Implementation of the Tanh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tanh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tanh(a); }
		
        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>(@in, @out); }

        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log operation implementation
    /// </summary>
    public struct Log : IUnaryOp<T>, NumCIL.Generic.Operators.ILog
    {
        /// <summary>
        /// Implementation of the Log operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log(a); }
		
        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>(@in, @out); }

        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log10 operation implementation
    /// </summary>
    public struct Log10 : IUnaryOp<T>, NumCIL.Generic.Operators.ILog10
    {
        /// <summary>
        /// Implementation of the Log10 operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log10 to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log10(a); }
		
        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>(@in, @out); }

        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Invert operation implementation
    /// </summary>
    public struct Invert : IUnaryOp<T>, NumCIL.Generic.Operators.IInvert
    {
        /// <summary>
        /// Implementation of the Invert operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Invert to the operand</returns>
        public T Op(T a) 
		{ return (T)(~a); }
		
        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>(@in, @out); }

        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>((OutArray)@in, @out); }
    }

	#endregion
	#endregion

    #region Generate mimics
    /// <summary>
    /// Generates basic initial arrays
    /// </summary>
    public static class Generate
    {
        /// <summary>
        /// The factory class that produces the NdArray instances
        /// </summary>
        public static NumCIL.Generic.IGenerator<T> Generator = new NumCIL.Generic.Generator<T, NumCIL.Generic.RandomGeneratorOpUInt16, NumCIL.Generic.RangeGeneratorOp<T, NumCIL.Generic.NumberConverterUInt16>, NumCIL.Generic.NumberConverterUInt16>();

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(Shape shape) { return Generator.Range(shape); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(Shape shape) { return Generator.Ones(shape); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(Shape shape) { return Generator.Zeroes(shape); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with uninitialized data</returns>
        public static OutArray Empty(Shape shape) { return Generator.Empty(shape); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to fill the array with</param>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, Shape shape) { return Generator.Same(value, shape); }
        /// <summary>
        /// Creates an array filled with the value random numbers
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to random numbers</returns>
        public static OutArray Random(Shape shape) { return Generator.Random(shape); }

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(params long[] dimensions) { return Generator.Range(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(params long[] dimensions) { return Generator.Ones(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(params long[] dimensions) { return Generator.Zeroes(dimensions); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with uninitialized values</returns>
        public static OutArray Empty(params long[] dimensions) { return Generator.Empty(dimensions); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to set fill the array with</param>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, params long[] dimensions) { return Generator.Same(value, dimensions); }
        /// <summary>
        /// Creates an array filled with random values
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to a random value</returns>
        public static OutArray Random(params long[] dimensions) { return Generator.Random(dimensions); }
    }
    #endregion

	#region Conversion operator
	/// <summary>
    /// Operator for converting a number to another type
    /// </summary>
	public struct ToUInt16 :
        IUnaryConvOp<double, T>, 
        IUnaryConvOp<float, T>, 
        IUnaryConvOp<sbyte, T>, 
        IUnaryConvOp<byte,T>, 
        IUnaryConvOp<short, T>, 
        IUnaryConvOp<int, T>, 
        IUnaryConvOp<uint,T>, 
        IUnaryConvOp<long, T>, 
        IUnaryConvOp<ulong, T>,
		NumCIL.Generic.Operators.ITypeConversion
    {

        /// <summary>
        /// Converts the input from a <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(double a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(float a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(sbyte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(byte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(short a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(uint a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(int a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ulong a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(long a) { return (T)a; }
    }
	#endregion
}

namespace NumCIL.Int32
{
    using T = System.Int32;
    using InArray = NumCIL.Generic.NdArray<System.Int32>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray : IEnumerable<InArray>
    {
        #region NdArray Mimics
        /// <summary>
        /// The value instance that gives access to values
        /// </summary>
        public InArray.ValueAccessor Value { get { return value.Value; } }
        /// <summary>
        /// A reference to the shape instance that describes this view
        /// </summary>
        public Shape Shape { get { return value.Shape; } }
        /// <summary>
        /// A reference to the underlying data storage
        /// </summary>
        public T[] AsArray() { return value.AsArray(); }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="index">The element to get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params long[] index] { get { return this.value[index]; } set { this.value[index] = value; } }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="ranges">The range get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params Range[] ranges] { get { return this.value[ranges]; } set { this.value[ranges] = value; } }
        /// <summary>
        /// Returns a flattened (1-d copy) of the current data view
        /// </summary>
        /// <returns>A flattened copy</returns>
        public OutArray Flatten() { return this.value.Flatten(); }
        /// <summary>
        /// Returns a copy of the underlying data, shaped as this view
        /// </summary>
        /// <returns>A copy of the view data</returns>
        public OutArray Clone() { return this.value.Clone(); }
        /// <summary>
        /// Generates a new view based on this array
        /// </summary>
        /// <param name="newshape">The new shape</param>
        /// <returns>The reshaped array</returns>
        public OutArray Reshape(Shape newshape) { return this.value.Reshape(newshape); }
        /// <summary>
        /// Returns a view that is a view of a single element
        /// </summary>
        /// <param name="element">The element to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(long element) { return this.value.Subview(element); }
        /// <summary>
        /// Returns a view that is a view of a range of elements
        /// </summary>
        /// <param name="range">The range to view</param>
        /// <param name="dimension">The dimension to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(Range range, long dimension) { return this.value.Subview(range, dimension); }
        /// <summary>
        /// Returnes a sliced subview of the data, optionally collapsing single element dimensions
        /// </summary>
        /// <param name="ranges">The ranges to view for each dimension</param>
        /// <param name="collapse">True if single element dimensions should be collapsed, false to retain all dimensions</param>
        /// <returns>A new view of the data</returns>
        public OutArray Subview(Range[] ranges, bool collapse) { return this.value.Subview(ranges, collapse); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<InArray> GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// A debug tag used for naming a view
        /// </summary>
        public string Name { get { return this.value.Name; } set { this.value.Name = value; } }
        /// <summary>
        /// The data accessor providing the data storage
        /// </summary>
        public NumCIL.Generic.IDataAccessor<T> DataAccessor { get { return this.value.DataAccessor; } }

        /// <summary>
        /// Constructs a NdArray that is a scalar wrapper,
        /// allows simple scalar operations on arbitrary
        /// NdArrays
        /// </summary>
        /// <param name="value">The scalar value</param>
        public NdArray(T value)
            : this(new NumCIL.Generic.DefaultAccessor<T>(new T[] { value }))
        {
        }

        /// <summary>
        /// Constructs a new NdArray with the specified shape
        /// </summary>
        /// <param name="shape">The shape of the new NdArray</param>
        public NdArray(Shape shape)
            : this(Generate.Empty(shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(T[] data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(NumCIL.Generic.IDataAccessor<T> data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="source">An existing array that will be re-shaped</param>
        /// <param name="newshape">The shape to view the array in</param>
        public NdArray(InArray source, Shape newshape)
            : this(new InArray(source, newshape))
        {
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.value.ToString();
        }

        /// <summary>
        /// Flushes pending operations on the array
        /// </summary>
        public void Flush() { this.value.Flush(); }

        /// <summary>
        /// Returns a transposed view of this array. If <paramref name="out"/> is supplied, the contents are copied into that array.
        /// </summary>
        /// <param name="out">Optional output array</param>
        /// <returns>A transposed view</returns>
        public OutArray Transpose(OutArray @out = null) { return value.Transpose(@out); }

        /// <summary>
        /// Gets or sets data in a transposed view
        /// </summary>
        public OutArray Transposed { get { return value.Transposed; } set { value.Transposed = this.value; } }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform</param>
        /// <param name="axis">The axis to repeat, if not speficied, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform in each axis</param>
        /// <param name="axis">The axis to repeat, if not specified, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long[] repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Concatenates an array onto this array, joined at the axis
        /// </summary>
        /// <param name="arg">The array to join</param>
        /// <param name="axis">The axis to join at</param>
        /// <returns>The joined array</returns>
        public OutArray Concatenate(OutArray arg, long axis = 0) { return this.value.Concatenate(arg, axis); }

        /// <summary>
        /// Sets the values viewed to the values from another array, i.e. copies the values
        /// </summary>
        /// <param name="arg">The data to copy</param>
        public void Set(OutArray arg) { this.value.Set(arg); }
        #endregion

        /// <summary>
        /// The only data member of the struct is a reference to the underlying view
        /// </summary>
        private readonly InArray value;
        /// <summary>
        /// Constructs a new typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array</param>
        public NdArray(InArray v) { this.value = v; }

        #region Implict conversion operators
        /// <summary>
        /// Implicit operator that returns a typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array to wrap</param>
        /// <returns>A wrapped array</returns>
        public static implicit operator OutArray(InArray v) { return v == null ? null : new OutArray(v); }
        /// <summary>
        /// Implicit operator that returns a basic array from a wrapped one
        /// </summary>
        /// <param name="v">The wrapper array</param>
        /// <returns>The basic array</returns>
        public static implicit operator InArray(NdArray v) { return ((object)v) == null ? null : v.value; }
        /// <summary>
        /// Implicit operator that returns a wrapped array from a scalar value
        /// </summary>
        /// <param name="v">The scalar value</param>
        /// <returns>A wrapped array representing the scalar value</returns>
        public static implicit operator OutArray(T v) { return new OutArray(v); }
        #endregion

        #region Operator implementations
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, OutArray b) { return UFunc.Apply<T, Add>(a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, OutArray b) { return UFunc.Apply<T, Sub>(a, b, null); }
        /// <summary>
        /// Calculates negation of the operand
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a) { return UFunc.Apply<T, Sub>(new OutArray((T)0), a, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, OutArray b) { return UFunc.Apply<T, Mul>(a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, OutArray b) { return UFunc.Apply<T, Div>(a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, OutArray b) { return UFunc.Apply<T, Mod>(a, b, null); }

        /// <summary>
        /// Calculates the incremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of incrementing each value</returns>
        public static OutArray operator ++(OutArray a) { return UFunc.Apply<T, Add>(a, (OutArray)1, null); }
        /// <summary>
        /// Calculates the decremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of decrementing each value</returns>
        public static OutArray operator --(OutArray a) { return UFunc.Apply<T, Sub>(a, (OutArray)1, null); }
        #endregion

        #region Common function implementations
        /// <summary>
        /// Copies all values from this NdArray to the output NdArray
        /// </summary>
        /// <param name="out">Optional target for addition, if null, a new array is created</param>
        /// <returns>An NdArray which is a copy of this array</returns>
        public OutArray Copy(OutArray @out = null) { return UFunc.Apply<T, NumCIL.CopyOp<T>>(this, @out); }
        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, op, @out); }
        /// <summary>
        /// Divides values of an NdArray with this NdArray and returns the modulo result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for modulo result, use to perform in-place modulo</param>
        /// <returns>An NdArray which is the modulo residues of dividing the two NdArrays</returns>
        public OutArray Mod(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mod>(this, op, @out); }
        /// <summary>
        /// Calculates the maximum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the max operation, use to perform in-place maximum calculation</param>
        /// <returns>An NdArray which is the maximum values of the two NdArrays</returns>
        public OutArray Max(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Max>(this, op, @out); }
        /// <summary>
        /// Calculates the minimum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the min operation, use to perform in-place minimum calculation</param>
        /// <returns>An NdArray which is the minimum values of the two NdArrays</returns>
        public OutArray Min(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Min>(this, op, @out); }

        /// <summary>
        /// Returns a new NdArray that is the result of calculating the square root for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the square root of all values</returns>
        public OutArray Sqrt(OutArray @out = null) { return UFunc.Apply<T, Sqrt>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the exponent for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the exponent of all values</returns>
        public OutArray Exp(OutArray @out = null) { return UFunc.Apply<T, Exp>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the absolute value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all absolute values</returns>
        public OutArray Abs(OutArray @out = null) { return UFunc.Apply<T, Abs>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic of all values</returns>
        public OutArray Log(OutArray @out = null) { return UFunc.Apply<T, Log>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic-10 value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic-10 of all values</returns>
        public OutArray Log10(OutArray @out = null) { return UFunc.Apply<T, Log10>(this, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the mathcing element in the operand NdArray
        /// </summary>
        /// <param name="op">The power-of values</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the values in the operand NdArray</returns>
        public OutArray Pow(NdArray op, OutArray @out = null) { return UFunc.Apply<T, Pow>(this, op, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the scalar value
        /// </summary>
        /// <param name="value">The power-of value</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the scalar value</returns>
        public OutArray Pow(T value, OutArray @out = null)
        {
            if (value == 2)
                return UFunc.Apply<T, Mul>(this, this, @out);
            else
                return UFunc.Apply<T, Pow>(this, (OutArray)value, @out);
        }
        /// <summary>
        /// Performs matrix multiplication on the two elements
        /// </summary>
        /// <param name="arg">The right-hand-side argument in matrix multiplication</param>
        /// <param name="out">Optional target for the multiplication</param>
        /// <returns>The matrix multiplication result</returns>
        public OutArray MatrixMultiply(OutArray arg, OutArray @out = null) { return UFunc.Matmul<T, Add, Mul>(this, arg, @out); }
        #endregion


        #region F# support for missing implicit operators
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(T a, OutArray b) { return UFunc.Apply<T, Add>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, T b) { return UFunc.Apply<T, Add>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(T a, OutArray b) { return UFunc.Apply<T, Sub>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, T b) { return UFunc.Apply<T, Sub>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(T a, OutArray b) { return UFunc.Apply<T, Mul>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, T b) { return UFunc.Apply<T, Mul>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(T a, OutArray b) { return UFunc.Apply<T, Div>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, T b) { return UFunc.Apply<T, Div>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(T a, OutArray b) { return UFunc.Apply<T, Mod>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, T b) { return UFunc.Apply<T, Mod>(a, (OutArray)b, null); }

        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(T op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, (OutArray)op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(T op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, (OutArray)op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(T op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, (OutArray)op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(T op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, (OutArray)op, @out); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(T a, OutArray b) { return UFunc.Apply<T, bool, Equal>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, T b) { return UFunc.Apply<T, bool, Equal>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(T a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, T b) { return UFunc.Apply<T, bool, NotEqual>(a, (OutArray)b, null); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(T a, OutArray b) { return UFunc.Apply<T, bool, LessThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, T b) { return UFunc.Apply<T, bool, LessThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(T a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, T b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, (OutArray)b, null); }
        #endregion

        #region Appliers for custom UFuncs
        /// <summary>
        /// Applies a unary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        public OutArray Apply(Func<T, T> op, OutArray @out = null) { return UFunc.Apply(op, this, @out); }
        /// <summary>
        /// Applies a binary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="b">An input operand</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        public OutArray Apply(Func<T, T, T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray @out = null) where C : struct, IUnaryOp<T> { return UFunc.Apply<T, C>(this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray b, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Apply<T, C>(this, b, @out); }
        /// <summary>
        /// Applies a nullary function to each element in this NdArray
        /// Note that Nullary functions are performed in-place
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <returns>This NdArray</returns>
        public OutArray Apply(INullaryOp<T> op) { UFunc.Apply<T>(op, this); return this; }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IUnaryOp<T> op, OutArray @out = null) { return UFunc.Apply<T>(op, this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IBinaryOp<T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }

        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <typeparam name="C">The function to apply reduction with</typeparam>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the reduction in-place</param>
        /// <returns>An NdArray that is the result of reducing the selected axis</returns>
        public OutArray Reduce<C>(long axis = 0, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Reduce<T, C>(this, axis, @out); }
        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <param name="op">The function to apply reduction with</param>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>A reduced array</returns>
        public OutArray Reduce(IBinaryOp<T> op, long axis = 0, OutArray @out = null) { return UFunc.Reduce<T>(op, this, axis, @out); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <typeparam name="C">The operation to perform</typeparam>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate<C>() where C : struct, IBinaryOp<T> { return UFunc.Aggregate<T, C>(this); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <param name="op">The operation to perform</param>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate(IBinaryOp<T> op) { return UFunc.Aggregate<T>(op, this); }

        /// <summary>
        /// Calculates the sum of all elements
        /// </summary>
        /// <returns>A scalar value that is the sum of all elements</returns>
        public T Sum() { return UFunc.Aggregate<T, Add>(this); }
        /// <summary>
        /// Calculates the maximum of all elements
        /// </summary>
        /// <returns>A scalar value that is the maximum of all elements</returns>
        public T Max() { return UFunc.Aggregate<T, Max>(this); }

        /// <summary>
        /// Calculates the minimum of all elements
        /// </summary>
        /// <returns>A scalar value that is the minimum of all elements</returns>
        public T Min() { return UFunc.Aggregate<T, Min>(this); }
        #endregion

		#region Conversion operators
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Double"/></returns>
        public static implicit operator OutArray(NumCIL.Double.NdArray a) { return UFunc.Apply<double, T, ToInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Single"/></returns>
        public static implicit operator OutArray(NumCIL.Float.NdArray a) { return UFunc.Apply<float, T, ToInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.SByte"/></returns>
        public static explicit operator OutArray(NumCIL.Int8.NdArray a) { return UFunc.Apply<sbyte, T, ToInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int16"/></returns>
        public static explicit operator OutArray(NumCIL.Int16.NdArray a) { return UFunc.Apply<short, T, ToInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int64"/></returns>
        public static implicit operator OutArray(NumCIL.Int64.NdArray a) { return UFunc.Apply<long, T, ToInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Byte"/></returns>
        public static explicit operator OutArray(NumCIL.UInt8.NdArray a) { return UFunc.Apply<byte, T, ToInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt16"/></returns>
        public static explicit operator OutArray(NumCIL.UInt16.NdArray a) { return UFunc.Apply<ushort, T, ToInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt32"/></returns>
        public static explicit operator OutArray(NumCIL.UInt32.NdArray a) { return UFunc.Apply<uint, T, ToInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt64"/></returns>
        public static explicit operator OutArray(NumCIL.UInt64.NdArray a) { return UFunc.Apply<ulong, T, ToInt32>(a); }
				#endregion

		#region Logical/Bitwise operator overloads
        /// <summary>
        /// Calculates the and of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of and-ing the two input operands</returns>
        public static OutArray operator &(OutArray a, OutArray b) { return UFunc.Apply<T, And>(a, b, null); }
        /// <summary>
        /// Calculates the or of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of or-ing the two input operands</returns>
        public static OutArray operator |(OutArray a, OutArray b) { return UFunc.Apply<T, Or>(a, b, null); }
        /// <summary>
        /// Calculates the xor of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of xor-ing the two input operands</returns>
        public static OutArray operator ^(OutArray a, OutArray b) { return UFunc.Apply<T, Xor>(a, b, null); }
        /// <summary>
        /// Calculates the bitwise complement of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The bitwise complement of the input operand</returns>
        public static OutArray operator !(OutArray a) { return UFunc.Apply<T, Invert>(a, null); }
		#endregion

		#region Comparison operator overloads
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, OutArray b) { return UFunc.Apply<T, bool, Equal>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator ==(OutArray a, object b) { return ((object)a) == b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator !=(OutArray a, object b) { return ((object)a) != b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, b, null); }
		#endregion

		#region System.Object overrides
		/// <summary>
		/// Compares this object to another
		/// </summary>
		/// <returns>A value indicating if the two elements are equal</returns>
		public override bool Equals(object o)
		{
			return this == o;
		}

		/// <summary>
		/// Returns a hashcode for comparing this object to others
		/// </summary>
		/// <returns>A hash code for this instance</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}
		#endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly CopyOp<T> Copy;
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly Add Add;
        /// <summary>
        /// The subtraction operation
        /// </summary>
        public static readonly Sub Sub;
        /// <summary>
        /// The multiplication operation
        /// </summary>
        public static readonly Mul Mul;
        /// <summary>
        /// The division operation
        /// </summary>
        public static readonly Div Div;
        /// <summary>
        /// The modulo operation
        /// </summary>
        public static readonly Mod Mod;
        /// <summary>
        /// The maximum operation
        /// </summary>
        public static readonly Max Max;
        /// <summary>
        /// The minimum operation
        /// </summary>
        public static readonly Min Min;
        /// <summary>
        /// The absolute operation
        /// </summary>
        public static readonly Abs Abs;
        /// <summary>
        /// The square root operation
        /// </summary>
        public static readonly Sqrt Sqrt;
        /// <summary>
        /// The exponential operation
        /// </summary>
        public static readonly Exp Exp;
        /// <summary>
        /// The logarithmic operation
        /// </summary>
        public static readonly Log Log;
        /// <summary>
        /// The logarithmic-10 operation
        /// </summary>
        public static readonly Log10 Log10;
        /// <summary>
        /// The power operation
        /// </summary>
        public static readonly Pow Pow;
        /// <summary>
        /// The arc cosine operation
        /// </summary>
        public static readonly Acos Acos;
        /// <summary>
        /// The arc sine operation
        /// </summary>
        public static readonly Asin Asin;
        /// <summary>
        /// The arc tangent operation
        /// </summary>
        public static readonly Atan Atan;
        /// <summary>
        /// The cosine operation
        /// </summary>
        public static readonly Cos Cos;
        /// <summary>
        /// The sine operation
        /// </summary>
        public static readonly Sin Sin;
        /// <summary>
        /// The tangent operation
        /// </summary>
        public static readonly Tan Tan;
        /// <summary>
        /// The hyperbolic cosine operation
        /// </summary>
        public static readonly Cosh Cosh;
        /// <summary>
        /// The hyperbolic sine operation
        /// </summary>
        public static readonly Sinh Sihn;
        /// <summary>
        /// The hyperbolic tangent operation
        /// </summary>
        public static readonly Tanh Tanh;
        /// <summary>
        /// The and operation
        /// </summary>
        public static readonly And And;
        /// <summary>
        /// The or operation
        /// </summary>
        public static readonly Or Or;
        /// <summary>
        /// The xor operation
        /// </summary>
        public static readonly Xor Xor;
        /// <summary>
        /// The invert operation
        /// </summary>
        public static readonly Invert Invert;

    }
    #endregion

	#region Comparison operators
    /// <summary>
    /// The equal Equal implementation
    /// </summary>
    public struct Equal : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IEqual
    {
        /// <summary>
        /// Implementation of Equal test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a == b; }
		
        /// <summary>
        /// Applies the Equal operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, Equal>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThan implementation
    /// </summary>
    public struct GreaterThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThan
    {
        /// <summary>
        /// Implementation of GreaterThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a > b; }
		
        /// <summary>
        /// Applies the GreaterThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThan implementation
    /// </summary>
    public struct LessThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThan
    {
        /// <summary>
        /// Implementation of LessThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a < b; }
		
        /// <summary>
        /// Applies the LessThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThanOrEqual implementation
    /// </summary>
    public struct GreaterThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThanOrEqual
    {
        /// <summary>
        /// Implementation of GreaterThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a >= b; }
		
        /// <summary>
        /// Applies the GreaterThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThanOrEqual implementation
    /// </summary>
    public struct LessThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThanOrEqual
    {
        /// <summary>
        /// Implementation of LessThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a <= b; }
		
        /// <summary>
        /// Applies the LessThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal NotEqual implementation
    /// </summary>
    public struct NotEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.INotEqual
    {
        /// <summary>
        /// Implementation of NotEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a != b; }
		
        /// <summary>
        /// Applies the NotEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, NotEqual>(in1, in2, @out); }
    }

	#endregion

    #region Operator implementations
    /// <summary>
    /// The copy operator implementation
    /// </summary>
    public struct Copy
    {
        /// <summary>
        /// Applies the copy operation to the input operand
        /// </summary>
        /// <param name="in1">The input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise copy of the input view</returns>
        public static OutArray Apply(OutArray in1, OutArray @out = null)
        { return UFunc.Apply<T, NumCIL.CopyOp<T>>(in1, @out); }
    }

	#region Binary operation implementations
    /// <summary>
    /// The Add operator implementation
    /// </summary>
    public struct Add : IBinaryOp<T>, NumCIL.Generic.Operators.IAdd
    {
        /// <summary>
        /// Implementation of Add with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Add with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a + b); }
		
        /// <summary>
        /// Reduces the input array with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Add>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Add>(arg); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>(in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Add>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Sub operator implementation
    /// </summary>
    public struct Sub : IBinaryOp<T>, NumCIL.Generic.Operators.ISub
    {
        /// <summary>
        /// Implementation of Sub with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Sub with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a - b); }
		
        /// <summary>
        /// Reduces the input array with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Sub>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Sub>(arg); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>(in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Sub>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mul operator implementation
    /// </summary>
    public struct Mul : IBinaryOp<T>, NumCIL.Generic.Operators.IMul
    {
        /// <summary>
        /// Implementation of Mul with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mul with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a * b); }
		
        /// <summary>
        /// Reduces the input array with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mul>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mul>(arg); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mul>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Div operator implementation
    /// </summary>
    public struct Div : IBinaryOp<T>, NumCIL.Generic.Operators.IDiv
    {
        /// <summary>
        /// Implementation of Div with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Div with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a / b); }
		
        /// <summary>
        /// Reduces the input array with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Div>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Div>(arg); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>(in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Div>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mod operator implementation
    /// </summary>
    public struct Mod : IBinaryOp<T>, NumCIL.Generic.Operators.IMod
    {
        /// <summary>
        /// Implementation of Mod with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mod with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a % b); }
		
        /// <summary>
        /// Reduces the input array with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mod>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mod>(arg); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mod>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Min operator implementation
    /// </summary>
    public struct Min : IBinaryOp<T>, NumCIL.Generic.Operators.IMin
    {
        /// <summary>
        /// Implementation of Min with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Min with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Min(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Min>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Min>(arg); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>(in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Min>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Max operator implementation
    /// </summary>
    public struct Max : IBinaryOp<T>, NumCIL.Generic.Operators.IMax
    {
        /// <summary>
        /// Implementation of Max with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Max with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Max(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Max>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Max>(arg); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>(in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Max>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Pow operator implementation
    /// </summary>
    public struct Pow : IBinaryOp<T>, NumCIL.Generic.Operators.IPow
    {
        /// <summary>
        /// Implementation of Pow with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Pow with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Pow(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Pow>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Pow>(arg); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>(in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ 
			if (in2 == (T)2)
				return UFunc.Apply<T, Mul>(in1, in1, @out);
			else
				return UFunc.Apply<T, Pow>(in1, (OutArray)in2, @out);
		}
		
    }

    /// <summary>
    /// The And operator implementation
    /// </summary>
    public struct And : IBinaryOp<T>, NumCIL.Generic.Operators.IAnd
    {
        /// <summary>
        /// Implementation of And with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of And with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a & b); }
		
        /// <summary>
        /// Reduces the input array with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, And>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, And>(arg); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>(in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, And>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Or operator implementation
    /// </summary>
    public struct Or : IBinaryOp<T>, NumCIL.Generic.Operators.IOr
    {
        /// <summary>
        /// Implementation of Or with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Or with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a | b); }
		
        /// <summary>
        /// Reduces the input array with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Or>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Or>(arg); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>(in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Or>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Xor operator implementation
    /// </summary>
    public struct Xor : IBinaryOp<T>, NumCIL.Generic.Operators.IXor
    {
        /// <summary>
        /// Implementation of Xor with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Xor with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a ^ b); }
		
        /// <summary>
        /// Reduces the input array with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Xor>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Xor>(arg); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>(in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Xor>(in1, (OutArray)in2, @out); }
    }

	#endregion

	#region Unary operations implementation
    /// <summary>
    /// The Sqrt operation implementation
    /// </summary>
    public struct Sqrt : IUnaryOp<T>, NumCIL.Generic.Operators.ISqrt
    {
        /// <summary>
        /// Implementation of the Sqrt operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sqrt to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sqrt(a); }
		
        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>(@in, @out); }

        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Exp operation implementation
    /// </summary>
    public struct Exp : IUnaryOp<T>, NumCIL.Generic.Operators.IExp
    {
        /// <summary>
        /// Implementation of the Exp operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Exp to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Exp(a); }
		
        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>(@in, @out); }

        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Abs operation implementation
    /// </summary>
    public struct Abs : IUnaryOp<T>, NumCIL.Generic.Operators.IAbs
    {
        /// <summary>
        /// Implementation of the Abs operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Abs to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Abs(a); }
		
        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>(@in, @out); }

        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sin operation implementation
    /// </summary>
    public struct Sin : IUnaryOp<T>, NumCIL.Generic.Operators.ISin
    {
        /// <summary>
        /// Implementation of the Sin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sin(a); }
		
        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>(@in, @out); }

        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cos operation implementation
    /// </summary>
    public struct Cos : IUnaryOp<T>, NumCIL.Generic.Operators.ICos
    {
        /// <summary>
        /// Implementation of the Cos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cos(a); }
		
        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>(@in, @out); }

        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tan operation implementation
    /// </summary>
    public struct Tan : IUnaryOp<T>, NumCIL.Generic.Operators.ITan
    {
        /// <summary>
        /// Implementation of the Tan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tan(a); }
		
        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>(@in, @out); }

        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Asin operation implementation
    /// </summary>
    public struct Asin : IUnaryOp<T>, NumCIL.Generic.Operators.IAsin
    {
        /// <summary>
        /// Implementation of the Asin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Asin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Asin(a); }
		
        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>(@in, @out); }

        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Acos operation implementation
    /// </summary>
    public struct Acos : IUnaryOp<T>, NumCIL.Generic.Operators.IAcos
    {
        /// <summary>
        /// Implementation of the Acos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Acos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Acos(a); }
		
        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>(@in, @out); }

        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Atan operation implementation
    /// </summary>
    public struct Atan : IUnaryOp<T>, NumCIL.Generic.Operators.IAtan
    {
        /// <summary>
        /// Implementation of the Atan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Atan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Atan(a); }
		
        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>(@in, @out); }

        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sinh operation implementation
    /// </summary>
    public struct Sinh : IUnaryOp<T>, NumCIL.Generic.Operators.ISinh
    {
        /// <summary>
        /// Implementation of the Sinh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sinh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sinh(a); }
		
        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>(@in, @out); }

        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cosh operation implementation
    /// </summary>
    public struct Cosh : IUnaryOp<T>, NumCIL.Generic.Operators.ICosh
    {
        /// <summary>
        /// Implementation of the Cosh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cosh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cosh(a); }
		
        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>(@in, @out); }

        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tanh operation implementation
    /// </summary>
    public struct Tanh : IUnaryOp<T>, NumCIL.Generic.Operators.ITanh
    {
        /// <summary>
        /// Implementation of the Tanh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tanh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tanh(a); }
		
        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>(@in, @out); }

        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log operation implementation
    /// </summary>
    public struct Log : IUnaryOp<T>, NumCIL.Generic.Operators.ILog
    {
        /// <summary>
        /// Implementation of the Log operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log(a); }
		
        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>(@in, @out); }

        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log10 operation implementation
    /// </summary>
    public struct Log10 : IUnaryOp<T>, NumCIL.Generic.Operators.ILog10
    {
        /// <summary>
        /// Implementation of the Log10 operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log10 to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log10(a); }
		
        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>(@in, @out); }

        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Invert operation implementation
    /// </summary>
    public struct Invert : IUnaryOp<T>, NumCIL.Generic.Operators.IInvert
    {
        /// <summary>
        /// Implementation of the Invert operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Invert to the operand</returns>
        public T Op(T a) 
		{ return (T)(~a); }
		
        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>(@in, @out); }

        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sign operation implementation
    /// </summary>
    public struct Sign : IUnaryOp<T>, NumCIL.Generic.Operators.ISign
    {
        /// <summary>
        /// Implementation of the Sign operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sign to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sign(a); }
		
        /// <summary>
        /// Applies the Sign operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sign>(@in, @out); }

        /// <summary>
        /// Applies the Sign operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sign>((OutArray)@in, @out); }
    }

	#endregion
	#endregion

    #region Generate mimics
    /// <summary>
    /// Generates basic initial arrays
    /// </summary>
    public static class Generate
    {
        /// <summary>
        /// The factory class that produces the NdArray instances
        /// </summary>
        public static NumCIL.Generic.IGenerator<T> Generator = new NumCIL.Generic.Generator<T, NumCIL.Generic.RandomGeneratorOpInt32, NumCIL.Generic.RangeGeneratorOp<T, NumCIL.Generic.NumberConverterInt32>, NumCIL.Generic.NumberConverterInt32>();

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(Shape shape) { return Generator.Range(shape); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(Shape shape) { return Generator.Ones(shape); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(Shape shape) { return Generator.Zeroes(shape); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with uninitialized data</returns>
        public static OutArray Empty(Shape shape) { return Generator.Empty(shape); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to fill the array with</param>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, Shape shape) { return Generator.Same(value, shape); }
        /// <summary>
        /// Creates an array filled with the value random numbers
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to random numbers</returns>
        public static OutArray Random(Shape shape) { return Generator.Random(shape); }

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(params long[] dimensions) { return Generator.Range(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(params long[] dimensions) { return Generator.Ones(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(params long[] dimensions) { return Generator.Zeroes(dimensions); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with uninitialized values</returns>
        public static OutArray Empty(params long[] dimensions) { return Generator.Empty(dimensions); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to set fill the array with</param>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, params long[] dimensions) { return Generator.Same(value, dimensions); }
        /// <summary>
        /// Creates an array filled with random values
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to a random value</returns>
        public static OutArray Random(params long[] dimensions) { return Generator.Random(dimensions); }
    }
    #endregion

	#region Conversion operator
	/// <summary>
    /// Operator for converting a number to another type
    /// </summary>
	public struct ToInt32 :
        IUnaryConvOp<double, T>, 
        IUnaryConvOp<float, T>, 
        IUnaryConvOp<sbyte, T>, 
        IUnaryConvOp<byte,T>, 
        IUnaryConvOp<short, T>, 
        IUnaryConvOp<ushort, T>, 
        IUnaryConvOp<uint,T>, 
        IUnaryConvOp<long, T>, 
        IUnaryConvOp<ulong, T>,
		NumCIL.Generic.Operators.ITypeConversion
    {

        /// <summary>
        /// Converts the input from a <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(double a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(float a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(sbyte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(byte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ushort a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(short a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(uint a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ulong a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(long a) { return (T)a; }
    }
	#endregion
}

namespace NumCIL.UInt32
{
    using T = System.UInt32;
    using InArray = NumCIL.Generic.NdArray<System.UInt32>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray : IEnumerable<InArray>
    {
        #region NdArray Mimics
        /// <summary>
        /// The value instance that gives access to values
        /// </summary>
        public InArray.ValueAccessor Value { get { return value.Value; } }
        /// <summary>
        /// A reference to the shape instance that describes this view
        /// </summary>
        public Shape Shape { get { return value.Shape; } }
        /// <summary>
        /// A reference to the underlying data storage
        /// </summary>
        public T[] AsArray() { return value.AsArray(); }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="index">The element to get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params long[] index] { get { return this.value[index]; } set { this.value[index] = value; } }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="ranges">The range get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params Range[] ranges] { get { return this.value[ranges]; } set { this.value[ranges] = value; } }
        /// <summary>
        /// Returns a flattened (1-d copy) of the current data view
        /// </summary>
        /// <returns>A flattened copy</returns>
        public OutArray Flatten() { return this.value.Flatten(); }
        /// <summary>
        /// Returns a copy of the underlying data, shaped as this view
        /// </summary>
        /// <returns>A copy of the view data</returns>
        public OutArray Clone() { return this.value.Clone(); }
        /// <summary>
        /// Generates a new view based on this array
        /// </summary>
        /// <param name="newshape">The new shape</param>
        /// <returns>The reshaped array</returns>
        public OutArray Reshape(Shape newshape) { return this.value.Reshape(newshape); }
        /// <summary>
        /// Returns a view that is a view of a single element
        /// </summary>
        /// <param name="element">The element to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(long element) { return this.value.Subview(element); }
        /// <summary>
        /// Returns a view that is a view of a range of elements
        /// </summary>
        /// <param name="range">The range to view</param>
        /// <param name="dimension">The dimension to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(Range range, long dimension) { return this.value.Subview(range, dimension); }
        /// <summary>
        /// Returnes a sliced subview of the data, optionally collapsing single element dimensions
        /// </summary>
        /// <param name="ranges">The ranges to view for each dimension</param>
        /// <param name="collapse">True if single element dimensions should be collapsed, false to retain all dimensions</param>
        /// <returns>A new view of the data</returns>
        public OutArray Subview(Range[] ranges, bool collapse) { return this.value.Subview(ranges, collapse); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<InArray> GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// A debug tag used for naming a view
        /// </summary>
        public string Name { get { return this.value.Name; } set { this.value.Name = value; } }
        /// <summary>
        /// The data accessor providing the data storage
        /// </summary>
        public NumCIL.Generic.IDataAccessor<T> DataAccessor { get { return this.value.DataAccessor; } }

        /// <summary>
        /// Constructs a NdArray that is a scalar wrapper,
        /// allows simple scalar operations on arbitrary
        /// NdArrays
        /// </summary>
        /// <param name="value">The scalar value</param>
        public NdArray(T value)
            : this(new NumCIL.Generic.DefaultAccessor<T>(new T[] { value }))
        {
        }

        /// <summary>
        /// Constructs a new NdArray with the specified shape
        /// </summary>
        /// <param name="shape">The shape of the new NdArray</param>
        public NdArray(Shape shape)
            : this(Generate.Empty(shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(T[] data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(NumCIL.Generic.IDataAccessor<T> data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="source">An existing array that will be re-shaped</param>
        /// <param name="newshape">The shape to view the array in</param>
        public NdArray(InArray source, Shape newshape)
            : this(new InArray(source, newshape))
        {
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.value.ToString();
        }

        /// <summary>
        /// Flushes pending operations on the array
        /// </summary>
        public void Flush() { this.value.Flush(); }

        /// <summary>
        /// Returns a transposed view of this array. If <paramref name="out"/> is supplied, the contents are copied into that array.
        /// </summary>
        /// <param name="out">Optional output array</param>
        /// <returns>A transposed view</returns>
        public OutArray Transpose(OutArray @out = null) { return value.Transpose(@out); }

        /// <summary>
        /// Gets or sets data in a transposed view
        /// </summary>
        public OutArray Transposed { get { return value.Transposed; } set { value.Transposed = this.value; } }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform</param>
        /// <param name="axis">The axis to repeat, if not speficied, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform in each axis</param>
        /// <param name="axis">The axis to repeat, if not specified, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long[] repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Concatenates an array onto this array, joined at the axis
        /// </summary>
        /// <param name="arg">The array to join</param>
        /// <param name="axis">The axis to join at</param>
        /// <returns>The joined array</returns>
        public OutArray Concatenate(OutArray arg, long axis = 0) { return this.value.Concatenate(arg, axis); }

        /// <summary>
        /// Sets the values viewed to the values from another array, i.e. copies the values
        /// </summary>
        /// <param name="arg">The data to copy</param>
        public void Set(OutArray arg) { this.value.Set(arg); }
        #endregion

        /// <summary>
        /// The only data member of the struct is a reference to the underlying view
        /// </summary>
        private readonly InArray value;
        /// <summary>
        /// Constructs a new typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array</param>
        public NdArray(InArray v) { this.value = v; }

        #region Implict conversion operators
        /// <summary>
        /// Implicit operator that returns a typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array to wrap</param>
        /// <returns>A wrapped array</returns>
        public static implicit operator OutArray(InArray v) { return v == null ? null : new OutArray(v); }
        /// <summary>
        /// Implicit operator that returns a basic array from a wrapped one
        /// </summary>
        /// <param name="v">The wrapper array</param>
        /// <returns>The basic array</returns>
        public static implicit operator InArray(NdArray v) { return ((object)v) == null ? null : v.value; }
        /// <summary>
        /// Implicit operator that returns a wrapped array from a scalar value
        /// </summary>
        /// <param name="v">The scalar value</param>
        /// <returns>A wrapped array representing the scalar value</returns>
        public static implicit operator OutArray(T v) { return new OutArray(v); }
        #endregion

        #region Operator implementations
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, OutArray b) { return UFunc.Apply<T, Add>(a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, OutArray b) { return UFunc.Apply<T, Sub>(a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, OutArray b) { return UFunc.Apply<T, Mul>(a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, OutArray b) { return UFunc.Apply<T, Div>(a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, OutArray b) { return UFunc.Apply<T, Mod>(a, b, null); }

        /// <summary>
        /// Calculates the incremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of incrementing each value</returns>
        public static OutArray operator ++(OutArray a) { return UFunc.Apply<T, Add>(a, (OutArray)1, null); }
        /// <summary>
        /// Calculates the decremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of decrementing each value</returns>
        public static OutArray operator --(OutArray a) { return UFunc.Apply<T, Sub>(a, (OutArray)1, null); }
        #endregion

        #region Common function implementations
        /// <summary>
        /// Copies all values from this NdArray to the output NdArray
        /// </summary>
        /// <param name="out">Optional target for addition, if null, a new array is created</param>
        /// <returns>An NdArray which is a copy of this array</returns>
        public OutArray Copy(OutArray @out = null) { return UFunc.Apply<T, NumCIL.CopyOp<T>>(this, @out); }
        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, op, @out); }
        /// <summary>
        /// Divides values of an NdArray with this NdArray and returns the modulo result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for modulo result, use to perform in-place modulo</param>
        /// <returns>An NdArray which is the modulo residues of dividing the two NdArrays</returns>
        public OutArray Mod(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mod>(this, op, @out); }
        /// <summary>
        /// Calculates the maximum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the max operation, use to perform in-place maximum calculation</param>
        /// <returns>An NdArray which is the maximum values of the two NdArrays</returns>
        public OutArray Max(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Max>(this, op, @out); }
        /// <summary>
        /// Calculates the minimum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the min operation, use to perform in-place minimum calculation</param>
        /// <returns>An NdArray which is the minimum values of the two NdArrays</returns>
        public OutArray Min(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Min>(this, op, @out); }

        /// <summary>
        /// Returns a new NdArray that is the result of calculating the square root for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the square root of all values</returns>
        public OutArray Sqrt(OutArray @out = null) { return UFunc.Apply<T, Sqrt>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the exponent for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the exponent of all values</returns>
        public OutArray Exp(OutArray @out = null) { return UFunc.Apply<T, Exp>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic of all values</returns>
        public OutArray Log(OutArray @out = null) { return UFunc.Apply<T, Log>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic-10 value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic-10 of all values</returns>
        public OutArray Log10(OutArray @out = null) { return UFunc.Apply<T, Log10>(this, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the mathcing element in the operand NdArray
        /// </summary>
        /// <param name="op">The power-of values</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the values in the operand NdArray</returns>
        public OutArray Pow(NdArray op, OutArray @out = null) { return UFunc.Apply<T, Pow>(this, op, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the scalar value
        /// </summary>
        /// <param name="value">The power-of value</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the scalar value</returns>
        public OutArray Pow(T value, OutArray @out = null)
        {
            if (value == 2)
                return UFunc.Apply<T, Mul>(this, this, @out);
            else
                return UFunc.Apply<T, Pow>(this, (OutArray)value, @out);
        }
        /// <summary>
        /// Performs matrix multiplication on the two elements
        /// </summary>
        /// <param name="arg">The right-hand-side argument in matrix multiplication</param>
        /// <param name="out">Optional target for the multiplication</param>
        /// <returns>The matrix multiplication result</returns>
        public OutArray MatrixMultiply(OutArray arg, OutArray @out = null) { return UFunc.Matmul<T, Add, Mul>(this, arg, @out); }
        #endregion


        #region F# support for missing implicit operators
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(T a, OutArray b) { return UFunc.Apply<T, Add>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, T b) { return UFunc.Apply<T, Add>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(T a, OutArray b) { return UFunc.Apply<T, Sub>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, T b) { return UFunc.Apply<T, Sub>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(T a, OutArray b) { return UFunc.Apply<T, Mul>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, T b) { return UFunc.Apply<T, Mul>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(T a, OutArray b) { return UFunc.Apply<T, Div>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, T b) { return UFunc.Apply<T, Div>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(T a, OutArray b) { return UFunc.Apply<T, Mod>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, T b) { return UFunc.Apply<T, Mod>(a, (OutArray)b, null); }

        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(T op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, (OutArray)op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(T op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, (OutArray)op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(T op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, (OutArray)op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(T op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, (OutArray)op, @out); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(T a, OutArray b) { return UFunc.Apply<T, bool, Equal>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, T b) { return UFunc.Apply<T, bool, Equal>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(T a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, T b) { return UFunc.Apply<T, bool, NotEqual>(a, (OutArray)b, null); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(T a, OutArray b) { return UFunc.Apply<T, bool, LessThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, T b) { return UFunc.Apply<T, bool, LessThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(T a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, T b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, (OutArray)b, null); }
        #endregion

        #region Appliers for custom UFuncs
        /// <summary>
        /// Applies a unary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        public OutArray Apply(Func<T, T> op, OutArray @out = null) { return UFunc.Apply(op, this, @out); }
        /// <summary>
        /// Applies a binary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="b">An input operand</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        public OutArray Apply(Func<T, T, T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray @out = null) where C : struct, IUnaryOp<T> { return UFunc.Apply<T, C>(this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray b, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Apply<T, C>(this, b, @out); }
        /// <summary>
        /// Applies a nullary function to each element in this NdArray
        /// Note that Nullary functions are performed in-place
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <returns>This NdArray</returns>
        public OutArray Apply(INullaryOp<T> op) { UFunc.Apply<T>(op, this); return this; }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IUnaryOp<T> op, OutArray @out = null) { return UFunc.Apply<T>(op, this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IBinaryOp<T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }

        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <typeparam name="C">The function to apply reduction with</typeparam>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the reduction in-place</param>
        /// <returns>An NdArray that is the result of reducing the selected axis</returns>
        public OutArray Reduce<C>(long axis = 0, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Reduce<T, C>(this, axis, @out); }
        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <param name="op">The function to apply reduction with</param>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>A reduced array</returns>
        public OutArray Reduce(IBinaryOp<T> op, long axis = 0, OutArray @out = null) { return UFunc.Reduce<T>(op, this, axis, @out); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <typeparam name="C">The operation to perform</typeparam>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate<C>() where C : struct, IBinaryOp<T> { return UFunc.Aggregate<T, C>(this); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <param name="op">The operation to perform</param>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate(IBinaryOp<T> op) { return UFunc.Aggregate<T>(op, this); }

        /// <summary>
        /// Calculates the sum of all elements
        /// </summary>
        /// <returns>A scalar value that is the sum of all elements</returns>
        public T Sum() { return UFunc.Aggregate<T, Add>(this); }
        /// <summary>
        /// Calculates the maximum of all elements
        /// </summary>
        /// <returns>A scalar value that is the maximum of all elements</returns>
        public T Max() { return UFunc.Aggregate<T, Max>(this); }

        /// <summary>
        /// Calculates the minimum of all elements
        /// </summary>
        /// <returns>A scalar value that is the minimum of all elements</returns>
        public T Min() { return UFunc.Aggregate<T, Min>(this); }
        #endregion

		#region Conversion operators
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Double"/></returns>
        public static implicit operator OutArray(NumCIL.Double.NdArray a) { return UFunc.Apply<double, T, ToUInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Single"/></returns>
        public static implicit operator OutArray(NumCIL.Float.NdArray a) { return UFunc.Apply<float, T, ToUInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.SByte"/></returns>
        public static explicit operator OutArray(NumCIL.Int8.NdArray a) { return UFunc.Apply<sbyte, T, ToUInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int16"/></returns>
        public static explicit operator OutArray(NumCIL.Int16.NdArray a) { return UFunc.Apply<short, T, ToUInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int32"/></returns>
        public static explicit operator OutArray(NumCIL.Int32.NdArray a) { return UFunc.Apply<int, T, ToUInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int64"/></returns>
        public static implicit operator OutArray(NumCIL.Int64.NdArray a) { return UFunc.Apply<long, T, ToUInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Byte"/></returns>
        public static explicit operator OutArray(NumCIL.UInt8.NdArray a) { return UFunc.Apply<byte, T, ToUInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt16"/></returns>
        public static explicit operator OutArray(NumCIL.UInt16.NdArray a) { return UFunc.Apply<ushort, T, ToUInt32>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt64"/></returns>
        public static implicit operator OutArray(NumCIL.UInt64.NdArray a) { return UFunc.Apply<ulong, T, ToUInt32>(a); }
				#endregion

		#region Logical/Bitwise operator overloads
        /// <summary>
        /// Calculates the and of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of and-ing the two input operands</returns>
        public static OutArray operator &(OutArray a, OutArray b) { return UFunc.Apply<T, And>(a, b, null); }
        /// <summary>
        /// Calculates the or of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of or-ing the two input operands</returns>
        public static OutArray operator |(OutArray a, OutArray b) { return UFunc.Apply<T, Or>(a, b, null); }
        /// <summary>
        /// Calculates the xor of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of xor-ing the two input operands</returns>
        public static OutArray operator ^(OutArray a, OutArray b) { return UFunc.Apply<T, Xor>(a, b, null); }
        /// <summary>
        /// Calculates the bitwise complement of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The bitwise complement of the input operand</returns>
        public static OutArray operator !(OutArray a) { return UFunc.Apply<T, Invert>(a, null); }
		#endregion

		#region Comparison operator overloads
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, OutArray b) { return UFunc.Apply<T, bool, Equal>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator ==(OutArray a, object b) { return ((object)a) == b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator !=(OutArray a, object b) { return ((object)a) != b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, b, null); }
		#endregion

		#region System.Object overrides
		/// <summary>
		/// Compares this object to another
		/// </summary>
		/// <returns>A value indicating if the two elements are equal</returns>
		public override bool Equals(object o)
		{
			return this == o;
		}

		/// <summary>
		/// Returns a hashcode for comparing this object to others
		/// </summary>
		/// <returns>A hash code for this instance</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}
		#endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly CopyOp<T> Copy;
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly Add Add;
        /// <summary>
        /// The subtraction operation
        /// </summary>
        public static readonly Sub Sub;
        /// <summary>
        /// The multiplication operation
        /// </summary>
        public static readonly Mul Mul;
        /// <summary>
        /// The division operation
        /// </summary>
        public static readonly Div Div;
        /// <summary>
        /// The modulo operation
        /// </summary>
        public static readonly Mod Mod;
        /// <summary>
        /// The maximum operation
        /// </summary>
        public static readonly Max Max;
        /// <summary>
        /// The minimum operation
        /// </summary>
        public static readonly Min Min;
        /// <summary>
        /// The square root operation
        /// </summary>
        public static readonly Sqrt Sqrt;
        /// <summary>
        /// The exponential operation
        /// </summary>
        public static readonly Exp Exp;
        /// <summary>
        /// The logarithmic operation
        /// </summary>
        public static readonly Log Log;
        /// <summary>
        /// The logarithmic-10 operation
        /// </summary>
        public static readonly Log10 Log10;
        /// <summary>
        /// The power operation
        /// </summary>
        public static readonly Pow Pow;
        /// <summary>
        /// The arc cosine operation
        /// </summary>
        public static readonly Acos Acos;
        /// <summary>
        /// The arc sine operation
        /// </summary>
        public static readonly Asin Asin;
        /// <summary>
        /// The arc tangent operation
        /// </summary>
        public static readonly Atan Atan;
        /// <summary>
        /// The cosine operation
        /// </summary>
        public static readonly Cos Cos;
        /// <summary>
        /// The sine operation
        /// </summary>
        public static readonly Sin Sin;
        /// <summary>
        /// The tangent operation
        /// </summary>
        public static readonly Tan Tan;
        /// <summary>
        /// The hyperbolic cosine operation
        /// </summary>
        public static readonly Cosh Cosh;
        /// <summary>
        /// The hyperbolic sine operation
        /// </summary>
        public static readonly Sinh Sihn;
        /// <summary>
        /// The hyperbolic tangent operation
        /// </summary>
        public static readonly Tanh Tanh;
        /// <summary>
        /// The and operation
        /// </summary>
        public static readonly And And;
        /// <summary>
        /// The or operation
        /// </summary>
        public static readonly Or Or;
        /// <summary>
        /// The xor operation
        /// </summary>
        public static readonly Xor Xor;
        /// <summary>
        /// The invert operation
        /// </summary>
        public static readonly Invert Invert;

    }
    #endregion

	#region Comparison operators
    /// <summary>
    /// The equal Equal implementation
    /// </summary>
    public struct Equal : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IEqual
    {
        /// <summary>
        /// Implementation of Equal test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a == b; }
		
        /// <summary>
        /// Applies the Equal operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, Equal>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThan implementation
    /// </summary>
    public struct GreaterThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThan
    {
        /// <summary>
        /// Implementation of GreaterThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a > b; }
		
        /// <summary>
        /// Applies the GreaterThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThan implementation
    /// </summary>
    public struct LessThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThan
    {
        /// <summary>
        /// Implementation of LessThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a < b; }
		
        /// <summary>
        /// Applies the LessThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThanOrEqual implementation
    /// </summary>
    public struct GreaterThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThanOrEqual
    {
        /// <summary>
        /// Implementation of GreaterThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a >= b; }
		
        /// <summary>
        /// Applies the GreaterThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThanOrEqual implementation
    /// </summary>
    public struct LessThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThanOrEqual
    {
        /// <summary>
        /// Implementation of LessThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a <= b; }
		
        /// <summary>
        /// Applies the LessThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal NotEqual implementation
    /// </summary>
    public struct NotEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.INotEqual
    {
        /// <summary>
        /// Implementation of NotEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a != b; }
		
        /// <summary>
        /// Applies the NotEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, NotEqual>(in1, in2, @out); }
    }

	#endregion

    #region Operator implementations
    /// <summary>
    /// The copy operator implementation
    /// </summary>
    public struct Copy
    {
        /// <summary>
        /// Applies the copy operation to the input operand
        /// </summary>
        /// <param name="in1">The input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise copy of the input view</returns>
        public static OutArray Apply(OutArray in1, OutArray @out = null)
        { return UFunc.Apply<T, NumCIL.CopyOp<T>>(in1, @out); }
    }

	#region Binary operation implementations
    /// <summary>
    /// The Add operator implementation
    /// </summary>
    public struct Add : IBinaryOp<T>, NumCIL.Generic.Operators.IAdd
    {
        /// <summary>
        /// Implementation of Add with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Add with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a + b); }
		
        /// <summary>
        /// Reduces the input array with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Add>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Add>(arg); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>(in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Add>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Sub operator implementation
    /// </summary>
    public struct Sub : IBinaryOp<T>, NumCIL.Generic.Operators.ISub
    {
        /// <summary>
        /// Implementation of Sub with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Sub with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a - b); }
		
        /// <summary>
        /// Reduces the input array with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Sub>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Sub>(arg); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>(in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Sub>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mul operator implementation
    /// </summary>
    public struct Mul : IBinaryOp<T>, NumCIL.Generic.Operators.IMul
    {
        /// <summary>
        /// Implementation of Mul with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mul with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a * b); }
		
        /// <summary>
        /// Reduces the input array with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mul>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mul>(arg); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mul>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Div operator implementation
    /// </summary>
    public struct Div : IBinaryOp<T>, NumCIL.Generic.Operators.IDiv
    {
        /// <summary>
        /// Implementation of Div with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Div with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a / b); }
		
        /// <summary>
        /// Reduces the input array with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Div>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Div>(arg); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>(in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Div>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mod operator implementation
    /// </summary>
    public struct Mod : IBinaryOp<T>, NumCIL.Generic.Operators.IMod
    {
        /// <summary>
        /// Implementation of Mod with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mod with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a % b); }
		
        /// <summary>
        /// Reduces the input array with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mod>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mod>(arg); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mod>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Min operator implementation
    /// </summary>
    public struct Min : IBinaryOp<T>, NumCIL.Generic.Operators.IMin
    {
        /// <summary>
        /// Implementation of Min with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Min with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Min(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Min>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Min>(arg); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>(in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Min>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Max operator implementation
    /// </summary>
    public struct Max : IBinaryOp<T>, NumCIL.Generic.Operators.IMax
    {
        /// <summary>
        /// Implementation of Max with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Max with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Max(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Max>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Max>(arg); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>(in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Max>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Pow operator implementation
    /// </summary>
    public struct Pow : IBinaryOp<T>, NumCIL.Generic.Operators.IPow
    {
        /// <summary>
        /// Implementation of Pow with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Pow with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Pow(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Pow>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Pow>(arg); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>(in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ 
			if (in2 == (T)2)
				return UFunc.Apply<T, Mul>(in1, in1, @out);
			else
				return UFunc.Apply<T, Pow>(in1, (OutArray)in2, @out);
		}
		
    }

    /// <summary>
    /// The And operator implementation
    /// </summary>
    public struct And : IBinaryOp<T>, NumCIL.Generic.Operators.IAnd
    {
        /// <summary>
        /// Implementation of And with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of And with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a & b); }
		
        /// <summary>
        /// Reduces the input array with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, And>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, And>(arg); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>(in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, And>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Or operator implementation
    /// </summary>
    public struct Or : IBinaryOp<T>, NumCIL.Generic.Operators.IOr
    {
        /// <summary>
        /// Implementation of Or with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Or with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a | b); }
		
        /// <summary>
        /// Reduces the input array with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Or>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Or>(arg); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>(in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Or>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Xor operator implementation
    /// </summary>
    public struct Xor : IBinaryOp<T>, NumCIL.Generic.Operators.IXor
    {
        /// <summary>
        /// Implementation of Xor with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Xor with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a ^ b); }
		
        /// <summary>
        /// Reduces the input array with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Xor>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Xor>(arg); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>(in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Xor>(in1, (OutArray)in2, @out); }
    }

	#endregion

	#region Unary operations implementation
    /// <summary>
    /// The Sqrt operation implementation
    /// </summary>
    public struct Sqrt : IUnaryOp<T>, NumCIL.Generic.Operators.ISqrt
    {
        /// <summary>
        /// Implementation of the Sqrt operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sqrt to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sqrt(a); }
		
        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>(@in, @out); }

        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Exp operation implementation
    /// </summary>
    public struct Exp : IUnaryOp<T>, NumCIL.Generic.Operators.IExp
    {
        /// <summary>
        /// Implementation of the Exp operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Exp to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Exp(a); }
		
        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>(@in, @out); }

        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sin operation implementation
    /// </summary>
    public struct Sin : IUnaryOp<T>, NumCIL.Generic.Operators.ISin
    {
        /// <summary>
        /// Implementation of the Sin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sin(a); }
		
        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>(@in, @out); }

        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cos operation implementation
    /// </summary>
    public struct Cos : IUnaryOp<T>, NumCIL.Generic.Operators.ICos
    {
        /// <summary>
        /// Implementation of the Cos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cos(a); }
		
        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>(@in, @out); }

        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tan operation implementation
    /// </summary>
    public struct Tan : IUnaryOp<T>, NumCIL.Generic.Operators.ITan
    {
        /// <summary>
        /// Implementation of the Tan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tan(a); }
		
        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>(@in, @out); }

        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Asin operation implementation
    /// </summary>
    public struct Asin : IUnaryOp<T>, NumCIL.Generic.Operators.IAsin
    {
        /// <summary>
        /// Implementation of the Asin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Asin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Asin(a); }
		
        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>(@in, @out); }

        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Acos operation implementation
    /// </summary>
    public struct Acos : IUnaryOp<T>, NumCIL.Generic.Operators.IAcos
    {
        /// <summary>
        /// Implementation of the Acos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Acos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Acos(a); }
		
        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>(@in, @out); }

        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Atan operation implementation
    /// </summary>
    public struct Atan : IUnaryOp<T>, NumCIL.Generic.Operators.IAtan
    {
        /// <summary>
        /// Implementation of the Atan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Atan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Atan(a); }
		
        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>(@in, @out); }

        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sinh operation implementation
    /// </summary>
    public struct Sinh : IUnaryOp<T>, NumCIL.Generic.Operators.ISinh
    {
        /// <summary>
        /// Implementation of the Sinh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sinh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sinh(a); }
		
        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>(@in, @out); }

        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cosh operation implementation
    /// </summary>
    public struct Cosh : IUnaryOp<T>, NumCIL.Generic.Operators.ICosh
    {
        /// <summary>
        /// Implementation of the Cosh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cosh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cosh(a); }
		
        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>(@in, @out); }

        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tanh operation implementation
    /// </summary>
    public struct Tanh : IUnaryOp<T>, NumCIL.Generic.Operators.ITanh
    {
        /// <summary>
        /// Implementation of the Tanh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tanh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tanh(a); }
		
        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>(@in, @out); }

        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log operation implementation
    /// </summary>
    public struct Log : IUnaryOp<T>, NumCIL.Generic.Operators.ILog
    {
        /// <summary>
        /// Implementation of the Log operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log(a); }
		
        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>(@in, @out); }

        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log10 operation implementation
    /// </summary>
    public struct Log10 : IUnaryOp<T>, NumCIL.Generic.Operators.ILog10
    {
        /// <summary>
        /// Implementation of the Log10 operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log10 to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log10(a); }
		
        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>(@in, @out); }

        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Invert operation implementation
    /// </summary>
    public struct Invert : IUnaryOp<T>, NumCIL.Generic.Operators.IInvert
    {
        /// <summary>
        /// Implementation of the Invert operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Invert to the operand</returns>
        public T Op(T a) 
		{ return (T)(~a); }
		
        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>(@in, @out); }

        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>((OutArray)@in, @out); }
    }

	#endregion
	#endregion

    #region Generate mimics
    /// <summary>
    /// Generates basic initial arrays
    /// </summary>
    public static class Generate
    {
        /// <summary>
        /// The factory class that produces the NdArray instances
        /// </summary>
        public static NumCIL.Generic.IGenerator<T> Generator = new NumCIL.Generic.Generator<T, NumCIL.Generic.RandomGeneratorOpUInt32, NumCIL.Generic.RangeGeneratorOp<T, NumCIL.Generic.NumberConverterUInt32>, NumCIL.Generic.NumberConverterUInt32>();

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(Shape shape) { return Generator.Range(shape); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(Shape shape) { return Generator.Ones(shape); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(Shape shape) { return Generator.Zeroes(shape); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with uninitialized data</returns>
        public static OutArray Empty(Shape shape) { return Generator.Empty(shape); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to fill the array with</param>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, Shape shape) { return Generator.Same(value, shape); }
        /// <summary>
        /// Creates an array filled with the value random numbers
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to random numbers</returns>
        public static OutArray Random(Shape shape) { return Generator.Random(shape); }

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(params long[] dimensions) { return Generator.Range(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(params long[] dimensions) { return Generator.Ones(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(params long[] dimensions) { return Generator.Zeroes(dimensions); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with uninitialized values</returns>
        public static OutArray Empty(params long[] dimensions) { return Generator.Empty(dimensions); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to set fill the array with</param>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, params long[] dimensions) { return Generator.Same(value, dimensions); }
        /// <summary>
        /// Creates an array filled with random values
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to a random value</returns>
        public static OutArray Random(params long[] dimensions) { return Generator.Random(dimensions); }
    }
    #endregion

	#region Conversion operator
	/// <summary>
    /// Operator for converting a number to another type
    /// </summary>
	public struct ToUInt32 :
        IUnaryConvOp<double, T>, 
        IUnaryConvOp<float, T>, 
        IUnaryConvOp<sbyte, T>, 
        IUnaryConvOp<byte,T>, 
        IUnaryConvOp<short, T>, 
        IUnaryConvOp<ushort, T>, 
        IUnaryConvOp<int, T>, 
        IUnaryConvOp<long, T>, 
        IUnaryConvOp<ulong, T>,
		NumCIL.Generic.Operators.ITypeConversion
    {

        /// <summary>
        /// Converts the input from a <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(double a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(float a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(sbyte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(byte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ushort a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(short a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(int a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ulong a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(long a) { return (T)a; }
    }
	#endregion
}

namespace NumCIL.Int64
{
    using T = System.Int64;
    using InArray = NumCIL.Generic.NdArray<System.Int64>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray : IEnumerable<InArray>
    {
        #region NdArray Mimics
        /// <summary>
        /// The value instance that gives access to values
        /// </summary>
        public InArray.ValueAccessor Value { get { return value.Value; } }
        /// <summary>
        /// A reference to the shape instance that describes this view
        /// </summary>
        public Shape Shape { get { return value.Shape; } }
        /// <summary>
        /// A reference to the underlying data storage
        /// </summary>
        public T[] AsArray() { return value.AsArray(); }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="index">The element to get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params long[] index] { get { return this.value[index]; } set { this.value[index] = value; } }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="ranges">The range get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params Range[] ranges] { get { return this.value[ranges]; } set { this.value[ranges] = value; } }
        /// <summary>
        /// Returns a flattened (1-d copy) of the current data view
        /// </summary>
        /// <returns>A flattened copy</returns>
        public OutArray Flatten() { return this.value.Flatten(); }
        /// <summary>
        /// Returns a copy of the underlying data, shaped as this view
        /// </summary>
        /// <returns>A copy of the view data</returns>
        public OutArray Clone() { return this.value.Clone(); }
        /// <summary>
        /// Generates a new view based on this array
        /// </summary>
        /// <param name="newshape">The new shape</param>
        /// <returns>The reshaped array</returns>
        public OutArray Reshape(Shape newshape) { return this.value.Reshape(newshape); }
        /// <summary>
        /// Returns a view that is a view of a single element
        /// </summary>
        /// <param name="element">The element to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(long element) { return this.value.Subview(element); }
        /// <summary>
        /// Returns a view that is a view of a range of elements
        /// </summary>
        /// <param name="range">The range to view</param>
        /// <param name="dimension">The dimension to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(Range range, long dimension) { return this.value.Subview(range, dimension); }
        /// <summary>
        /// Returnes a sliced subview of the data, optionally collapsing single element dimensions
        /// </summary>
        /// <param name="ranges">The ranges to view for each dimension</param>
        /// <param name="collapse">True if single element dimensions should be collapsed, false to retain all dimensions</param>
        /// <returns>A new view of the data</returns>
        public OutArray Subview(Range[] ranges, bool collapse) { return this.value.Subview(ranges, collapse); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<InArray> GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// A debug tag used for naming a view
        /// </summary>
        public string Name { get { return this.value.Name; } set { this.value.Name = value; } }
        /// <summary>
        /// The data accessor providing the data storage
        /// </summary>
        public NumCIL.Generic.IDataAccessor<T> DataAccessor { get { return this.value.DataAccessor; } }

        /// <summary>
        /// Constructs a NdArray that is a scalar wrapper,
        /// allows simple scalar operations on arbitrary
        /// NdArrays
        /// </summary>
        /// <param name="value">The scalar value</param>
        public NdArray(T value)
            : this(new NumCIL.Generic.DefaultAccessor<T>(new T[] { value }))
        {
        }

        /// <summary>
        /// Constructs a new NdArray with the specified shape
        /// </summary>
        /// <param name="shape">The shape of the new NdArray</param>
        public NdArray(Shape shape)
            : this(Generate.Empty(shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(T[] data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(NumCIL.Generic.IDataAccessor<T> data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="source">An existing array that will be re-shaped</param>
        /// <param name="newshape">The shape to view the array in</param>
        public NdArray(InArray source, Shape newshape)
            : this(new InArray(source, newshape))
        {
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.value.ToString();
        }

        /// <summary>
        /// Flushes pending operations on the array
        /// </summary>
        public void Flush() { this.value.Flush(); }

        /// <summary>
        /// Returns a transposed view of this array. If <paramref name="out"/> is supplied, the contents are copied into that array.
        /// </summary>
        /// <param name="out">Optional output array</param>
        /// <returns>A transposed view</returns>
        public OutArray Transpose(OutArray @out = null) { return value.Transpose(@out); }

        /// <summary>
        /// Gets or sets data in a transposed view
        /// </summary>
        public OutArray Transposed { get { return value.Transposed; } set { value.Transposed = this.value; } }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform</param>
        /// <param name="axis">The axis to repeat, if not speficied, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform in each axis</param>
        /// <param name="axis">The axis to repeat, if not specified, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long[] repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Concatenates an array onto this array, joined at the axis
        /// </summary>
        /// <param name="arg">The array to join</param>
        /// <param name="axis">The axis to join at</param>
        /// <returns>The joined array</returns>
        public OutArray Concatenate(OutArray arg, long axis = 0) { return this.value.Concatenate(arg, axis); }

        /// <summary>
        /// Sets the values viewed to the values from another array, i.e. copies the values
        /// </summary>
        /// <param name="arg">The data to copy</param>
        public void Set(OutArray arg) { this.value.Set(arg); }
        #endregion

        /// <summary>
        /// The only data member of the struct is a reference to the underlying view
        /// </summary>
        private readonly InArray value;
        /// <summary>
        /// Constructs a new typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array</param>
        public NdArray(InArray v) { this.value = v; }

        #region Implict conversion operators
        /// <summary>
        /// Implicit operator that returns a typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array to wrap</param>
        /// <returns>A wrapped array</returns>
        public static implicit operator OutArray(InArray v) { return v == null ? null : new OutArray(v); }
        /// <summary>
        /// Implicit operator that returns a basic array from a wrapped one
        /// </summary>
        /// <param name="v">The wrapper array</param>
        /// <returns>The basic array</returns>
        public static implicit operator InArray(NdArray v) { return ((object)v) == null ? null : v.value; }
        /// <summary>
        /// Implicit operator that returns a wrapped array from a scalar value
        /// </summary>
        /// <param name="v">The scalar value</param>
        /// <returns>A wrapped array representing the scalar value</returns>
        public static implicit operator OutArray(T v) { return new OutArray(v); }
        #endregion

        #region Operator implementations
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, OutArray b) { return UFunc.Apply<T, Add>(a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, OutArray b) { return UFunc.Apply<T, Sub>(a, b, null); }
        /// <summary>
        /// Calculates negation of the operand
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a) { return UFunc.Apply<T, Sub>(new OutArray((T)0), a, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, OutArray b) { return UFunc.Apply<T, Mul>(a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, OutArray b) { return UFunc.Apply<T, Div>(a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, OutArray b) { return UFunc.Apply<T, Mod>(a, b, null); }

        /// <summary>
        /// Calculates the incremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of incrementing each value</returns>
        public static OutArray operator ++(OutArray a) { return UFunc.Apply<T, Add>(a, (OutArray)1, null); }
        /// <summary>
        /// Calculates the decremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of decrementing each value</returns>
        public static OutArray operator --(OutArray a) { return UFunc.Apply<T, Sub>(a, (OutArray)1, null); }
        #endregion

        #region Common function implementations
        /// <summary>
        /// Copies all values from this NdArray to the output NdArray
        /// </summary>
        /// <param name="out">Optional target for addition, if null, a new array is created</param>
        /// <returns>An NdArray which is a copy of this array</returns>
        public OutArray Copy(OutArray @out = null) { return UFunc.Apply<T, NumCIL.CopyOp<T>>(this, @out); }
        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, op, @out); }
        /// <summary>
        /// Divides values of an NdArray with this NdArray and returns the modulo result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for modulo result, use to perform in-place modulo</param>
        /// <returns>An NdArray which is the modulo residues of dividing the two NdArrays</returns>
        public OutArray Mod(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mod>(this, op, @out); }
        /// <summary>
        /// Calculates the maximum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the max operation, use to perform in-place maximum calculation</param>
        /// <returns>An NdArray which is the maximum values of the two NdArrays</returns>
        public OutArray Max(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Max>(this, op, @out); }
        /// <summary>
        /// Calculates the minimum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the min operation, use to perform in-place minimum calculation</param>
        /// <returns>An NdArray which is the minimum values of the two NdArrays</returns>
        public OutArray Min(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Min>(this, op, @out); }

        /// <summary>
        /// Returns a new NdArray that is the result of calculating the square root for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the square root of all values</returns>
        public OutArray Sqrt(OutArray @out = null) { return UFunc.Apply<T, Sqrt>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the exponent for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the exponent of all values</returns>
        public OutArray Exp(OutArray @out = null) { return UFunc.Apply<T, Exp>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the absolute value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all absolute values</returns>
        public OutArray Abs(OutArray @out = null) { return UFunc.Apply<T, Abs>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic of all values</returns>
        public OutArray Log(OutArray @out = null) { return UFunc.Apply<T, Log>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic-10 value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic-10 of all values</returns>
        public OutArray Log10(OutArray @out = null) { return UFunc.Apply<T, Log10>(this, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the mathcing element in the operand NdArray
        /// </summary>
        /// <param name="op">The power-of values</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the values in the operand NdArray</returns>
        public OutArray Pow(NdArray op, OutArray @out = null) { return UFunc.Apply<T, Pow>(this, op, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the scalar value
        /// </summary>
        /// <param name="value">The power-of value</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the scalar value</returns>
        public OutArray Pow(T value, OutArray @out = null)
        {
            if (value == 2)
                return UFunc.Apply<T, Mul>(this, this, @out);
            else
                return UFunc.Apply<T, Pow>(this, (OutArray)value, @out);
        }
        /// <summary>
        /// Performs matrix multiplication on the two elements
        /// </summary>
        /// <param name="arg">The right-hand-side argument in matrix multiplication</param>
        /// <param name="out">Optional target for the multiplication</param>
        /// <returns>The matrix multiplication result</returns>
        public OutArray MatrixMultiply(OutArray arg, OutArray @out = null) { return UFunc.Matmul<T, Add, Mul>(this, arg, @out); }
        #endregion


        #region F# support for missing implicit operators
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(T a, OutArray b) { return UFunc.Apply<T, Add>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, T b) { return UFunc.Apply<T, Add>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(T a, OutArray b) { return UFunc.Apply<T, Sub>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, T b) { return UFunc.Apply<T, Sub>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(T a, OutArray b) { return UFunc.Apply<T, Mul>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, T b) { return UFunc.Apply<T, Mul>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(T a, OutArray b) { return UFunc.Apply<T, Div>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, T b) { return UFunc.Apply<T, Div>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(T a, OutArray b) { return UFunc.Apply<T, Mod>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, T b) { return UFunc.Apply<T, Mod>(a, (OutArray)b, null); }

        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(T op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, (OutArray)op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(T op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, (OutArray)op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(T op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, (OutArray)op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(T op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, (OutArray)op, @out); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(T a, OutArray b) { return UFunc.Apply<T, bool, Equal>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, T b) { return UFunc.Apply<T, bool, Equal>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(T a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, T b) { return UFunc.Apply<T, bool, NotEqual>(a, (OutArray)b, null); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(T a, OutArray b) { return UFunc.Apply<T, bool, LessThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, T b) { return UFunc.Apply<T, bool, LessThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(T a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, T b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, (OutArray)b, null); }
        #endregion

        #region Appliers for custom UFuncs
        /// <summary>
        /// Applies a unary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        public OutArray Apply(Func<T, T> op, OutArray @out = null) { return UFunc.Apply(op, this, @out); }
        /// <summary>
        /// Applies a binary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="b">An input operand</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        public OutArray Apply(Func<T, T, T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray @out = null) where C : struct, IUnaryOp<T> { return UFunc.Apply<T, C>(this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray b, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Apply<T, C>(this, b, @out); }
        /// <summary>
        /// Applies a nullary function to each element in this NdArray
        /// Note that Nullary functions are performed in-place
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <returns>This NdArray</returns>
        public OutArray Apply(INullaryOp<T> op) { UFunc.Apply<T>(op, this); return this; }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IUnaryOp<T> op, OutArray @out = null) { return UFunc.Apply<T>(op, this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IBinaryOp<T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }

        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <typeparam name="C">The function to apply reduction with</typeparam>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the reduction in-place</param>
        /// <returns>An NdArray that is the result of reducing the selected axis</returns>
        public OutArray Reduce<C>(long axis = 0, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Reduce<T, C>(this, axis, @out); }
        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <param name="op">The function to apply reduction with</param>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>A reduced array</returns>
        public OutArray Reduce(IBinaryOp<T> op, long axis = 0, OutArray @out = null) { return UFunc.Reduce<T>(op, this, axis, @out); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <typeparam name="C">The operation to perform</typeparam>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate<C>() where C : struct, IBinaryOp<T> { return UFunc.Aggregate<T, C>(this); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <param name="op">The operation to perform</param>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate(IBinaryOp<T> op) { return UFunc.Aggregate<T>(op, this); }

        /// <summary>
        /// Calculates the sum of all elements
        /// </summary>
        /// <returns>A scalar value that is the sum of all elements</returns>
        public T Sum() { return UFunc.Aggregate<T, Add>(this); }
        /// <summary>
        /// Calculates the maximum of all elements
        /// </summary>
        /// <returns>A scalar value that is the maximum of all elements</returns>
        public T Max() { return UFunc.Aggregate<T, Max>(this); }

        /// <summary>
        /// Calculates the minimum of all elements
        /// </summary>
        /// <returns>A scalar value that is the minimum of all elements</returns>
        public T Min() { return UFunc.Aggregate<T, Min>(this); }
        #endregion

		#region Conversion operators
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Double"/></returns>
        public static implicit operator OutArray(NumCIL.Double.NdArray a) { return UFunc.Apply<double, T, ToInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Single"/></returns>
        public static implicit operator OutArray(NumCIL.Float.NdArray a) { return UFunc.Apply<float, T, ToInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.SByte"/></returns>
        public static explicit operator OutArray(NumCIL.Int8.NdArray a) { return UFunc.Apply<sbyte, T, ToInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int16"/></returns>
        public static explicit operator OutArray(NumCIL.Int16.NdArray a) { return UFunc.Apply<short, T, ToInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int32"/></returns>
        public static explicit operator OutArray(NumCIL.Int32.NdArray a) { return UFunc.Apply<int, T, ToInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Byte"/></returns>
        public static explicit operator OutArray(NumCIL.UInt8.NdArray a) { return UFunc.Apply<byte, T, ToInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt16"/></returns>
        public static explicit operator OutArray(NumCIL.UInt16.NdArray a) { return UFunc.Apply<ushort, T, ToInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt32"/></returns>
        public static explicit operator OutArray(NumCIL.UInt32.NdArray a) { return UFunc.Apply<uint, T, ToInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt64"/></returns>
        public static explicit operator OutArray(NumCIL.UInt64.NdArray a) { return UFunc.Apply<ulong, T, ToInt64>(a); }
				#endregion

		#region Logical/Bitwise operator overloads
        /// <summary>
        /// Calculates the and of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of and-ing the two input operands</returns>
        public static OutArray operator &(OutArray a, OutArray b) { return UFunc.Apply<T, And>(a, b, null); }
        /// <summary>
        /// Calculates the or of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of or-ing the two input operands</returns>
        public static OutArray operator |(OutArray a, OutArray b) { return UFunc.Apply<T, Or>(a, b, null); }
        /// <summary>
        /// Calculates the xor of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of xor-ing the two input operands</returns>
        public static OutArray operator ^(OutArray a, OutArray b) { return UFunc.Apply<T, Xor>(a, b, null); }
        /// <summary>
        /// Calculates the bitwise complement of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The bitwise complement of the input operand</returns>
        public static OutArray operator !(OutArray a) { return UFunc.Apply<T, Invert>(a, null); }
		#endregion

		#region Comparison operator overloads
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, OutArray b) { return UFunc.Apply<T, bool, Equal>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator ==(OutArray a, object b) { return ((object)a) == b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator !=(OutArray a, object b) { return ((object)a) != b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, b, null); }
		#endregion

		#region System.Object overrides
		/// <summary>
		/// Compares this object to another
		/// </summary>
		/// <returns>A value indicating if the two elements are equal</returns>
		public override bool Equals(object o)
		{
			return this == o;
		}

		/// <summary>
		/// Returns a hashcode for comparing this object to others
		/// </summary>
		/// <returns>A hash code for this instance</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}
		#endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly CopyOp<T> Copy;
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly Add Add;
        /// <summary>
        /// The subtraction operation
        /// </summary>
        public static readonly Sub Sub;
        /// <summary>
        /// The multiplication operation
        /// </summary>
        public static readonly Mul Mul;
        /// <summary>
        /// The division operation
        /// </summary>
        public static readonly Div Div;
        /// <summary>
        /// The modulo operation
        /// </summary>
        public static readonly Mod Mod;
        /// <summary>
        /// The maximum operation
        /// </summary>
        public static readonly Max Max;
        /// <summary>
        /// The minimum operation
        /// </summary>
        public static readonly Min Min;
        /// <summary>
        /// The absolute operation
        /// </summary>
        public static readonly Abs Abs;
        /// <summary>
        /// The square root operation
        /// </summary>
        public static readonly Sqrt Sqrt;
        /// <summary>
        /// The exponential operation
        /// </summary>
        public static readonly Exp Exp;
        /// <summary>
        /// The logarithmic operation
        /// </summary>
        public static readonly Log Log;
        /// <summary>
        /// The logarithmic-10 operation
        /// </summary>
        public static readonly Log10 Log10;
        /// <summary>
        /// The power operation
        /// </summary>
        public static readonly Pow Pow;
        /// <summary>
        /// The arc cosine operation
        /// </summary>
        public static readonly Acos Acos;
        /// <summary>
        /// The arc sine operation
        /// </summary>
        public static readonly Asin Asin;
        /// <summary>
        /// The arc tangent operation
        /// </summary>
        public static readonly Atan Atan;
        /// <summary>
        /// The cosine operation
        /// </summary>
        public static readonly Cos Cos;
        /// <summary>
        /// The sine operation
        /// </summary>
        public static readonly Sin Sin;
        /// <summary>
        /// The tangent operation
        /// </summary>
        public static readonly Tan Tan;
        /// <summary>
        /// The hyperbolic cosine operation
        /// </summary>
        public static readonly Cosh Cosh;
        /// <summary>
        /// The hyperbolic sine operation
        /// </summary>
        public static readonly Sinh Sihn;
        /// <summary>
        /// The hyperbolic tangent operation
        /// </summary>
        public static readonly Tanh Tanh;
        /// <summary>
        /// The and operation
        /// </summary>
        public static readonly And And;
        /// <summary>
        /// The or operation
        /// </summary>
        public static readonly Or Or;
        /// <summary>
        /// The xor operation
        /// </summary>
        public static readonly Xor Xor;
        /// <summary>
        /// The invert operation
        /// </summary>
        public static readonly Invert Invert;

    }
    #endregion

	#region Comparison operators
    /// <summary>
    /// The equal Equal implementation
    /// </summary>
    public struct Equal : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IEqual
    {
        /// <summary>
        /// Implementation of Equal test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a == b; }
		
        /// <summary>
        /// Applies the Equal operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, Equal>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThan implementation
    /// </summary>
    public struct GreaterThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThan
    {
        /// <summary>
        /// Implementation of GreaterThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a > b; }
		
        /// <summary>
        /// Applies the GreaterThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThan implementation
    /// </summary>
    public struct LessThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThan
    {
        /// <summary>
        /// Implementation of LessThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a < b; }
		
        /// <summary>
        /// Applies the LessThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThanOrEqual implementation
    /// </summary>
    public struct GreaterThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThanOrEqual
    {
        /// <summary>
        /// Implementation of GreaterThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a >= b; }
		
        /// <summary>
        /// Applies the GreaterThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThanOrEqual implementation
    /// </summary>
    public struct LessThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThanOrEqual
    {
        /// <summary>
        /// Implementation of LessThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a <= b; }
		
        /// <summary>
        /// Applies the LessThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal NotEqual implementation
    /// </summary>
    public struct NotEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.INotEqual
    {
        /// <summary>
        /// Implementation of NotEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a != b; }
		
        /// <summary>
        /// Applies the NotEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, NotEqual>(in1, in2, @out); }
    }

	#endregion

    #region Operator implementations
    /// <summary>
    /// The copy operator implementation
    /// </summary>
    public struct Copy
    {
        /// <summary>
        /// Applies the copy operation to the input operand
        /// </summary>
        /// <param name="in1">The input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise copy of the input view</returns>
        public static OutArray Apply(OutArray in1, OutArray @out = null)
        { return UFunc.Apply<T, NumCIL.CopyOp<T>>(in1, @out); }
    }

	#region Binary operation implementations
    /// <summary>
    /// The Add operator implementation
    /// </summary>
    public struct Add : IBinaryOp<T>, NumCIL.Generic.Operators.IAdd
    {
        /// <summary>
        /// Implementation of Add with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Add with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a + b); }
		
        /// <summary>
        /// Reduces the input array with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Add>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Add>(arg); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>(in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Add>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Sub operator implementation
    /// </summary>
    public struct Sub : IBinaryOp<T>, NumCIL.Generic.Operators.ISub
    {
        /// <summary>
        /// Implementation of Sub with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Sub with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a - b); }
		
        /// <summary>
        /// Reduces the input array with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Sub>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Sub>(arg); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>(in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Sub>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mul operator implementation
    /// </summary>
    public struct Mul : IBinaryOp<T>, NumCIL.Generic.Operators.IMul
    {
        /// <summary>
        /// Implementation of Mul with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mul with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a * b); }
		
        /// <summary>
        /// Reduces the input array with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mul>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mul>(arg); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mul>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Div operator implementation
    /// </summary>
    public struct Div : IBinaryOp<T>, NumCIL.Generic.Operators.IDiv
    {
        /// <summary>
        /// Implementation of Div with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Div with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a / b); }
		
        /// <summary>
        /// Reduces the input array with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Div>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Div>(arg); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>(in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Div>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mod operator implementation
    /// </summary>
    public struct Mod : IBinaryOp<T>, NumCIL.Generic.Operators.IMod
    {
        /// <summary>
        /// Implementation of Mod with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mod with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a % b); }
		
        /// <summary>
        /// Reduces the input array with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mod>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mod>(arg); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mod>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Min operator implementation
    /// </summary>
    public struct Min : IBinaryOp<T>, NumCIL.Generic.Operators.IMin
    {
        /// <summary>
        /// Implementation of Min with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Min with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Min(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Min>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Min>(arg); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>(in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Min>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Max operator implementation
    /// </summary>
    public struct Max : IBinaryOp<T>, NumCIL.Generic.Operators.IMax
    {
        /// <summary>
        /// Implementation of Max with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Max with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Max(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Max>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Max>(arg); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>(in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Max>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Pow operator implementation
    /// </summary>
    public struct Pow : IBinaryOp<T>, NumCIL.Generic.Operators.IPow
    {
        /// <summary>
        /// Implementation of Pow with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Pow with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Pow(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Pow>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Pow>(arg); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>(in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ 
			if (in2 == (T)2)
				return UFunc.Apply<T, Mul>(in1, in1, @out);
			else
				return UFunc.Apply<T, Pow>(in1, (OutArray)in2, @out);
		}
		
    }

    /// <summary>
    /// The And operator implementation
    /// </summary>
    public struct And : IBinaryOp<T>, NumCIL.Generic.Operators.IAnd
    {
        /// <summary>
        /// Implementation of And with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of And with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a & b); }
		
        /// <summary>
        /// Reduces the input array with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, And>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, And>(arg); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>(in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, And>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Or operator implementation
    /// </summary>
    public struct Or : IBinaryOp<T>, NumCIL.Generic.Operators.IOr
    {
        /// <summary>
        /// Implementation of Or with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Or with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a | b); }
		
        /// <summary>
        /// Reduces the input array with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Or>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Or>(arg); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>(in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Or>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Xor operator implementation
    /// </summary>
    public struct Xor : IBinaryOp<T>, NumCIL.Generic.Operators.IXor
    {
        /// <summary>
        /// Implementation of Xor with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Xor with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a ^ b); }
		
        /// <summary>
        /// Reduces the input array with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Xor>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Xor>(arg); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>(in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Xor>(in1, (OutArray)in2, @out); }
    }

	#endregion

	#region Unary operations implementation
    /// <summary>
    /// The Sqrt operation implementation
    /// </summary>
    public struct Sqrt : IUnaryOp<T>, NumCIL.Generic.Operators.ISqrt
    {
        /// <summary>
        /// Implementation of the Sqrt operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sqrt to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sqrt(a); }
		
        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>(@in, @out); }

        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Exp operation implementation
    /// </summary>
    public struct Exp : IUnaryOp<T>, NumCIL.Generic.Operators.IExp
    {
        /// <summary>
        /// Implementation of the Exp operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Exp to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Exp(a); }
		
        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>(@in, @out); }

        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Abs operation implementation
    /// </summary>
    public struct Abs : IUnaryOp<T>, NumCIL.Generic.Operators.IAbs
    {
        /// <summary>
        /// Implementation of the Abs operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Abs to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Abs(a); }
		
        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>(@in, @out); }

        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sin operation implementation
    /// </summary>
    public struct Sin : IUnaryOp<T>, NumCIL.Generic.Operators.ISin
    {
        /// <summary>
        /// Implementation of the Sin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sin(a); }
		
        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>(@in, @out); }

        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cos operation implementation
    /// </summary>
    public struct Cos : IUnaryOp<T>, NumCIL.Generic.Operators.ICos
    {
        /// <summary>
        /// Implementation of the Cos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cos(a); }
		
        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>(@in, @out); }

        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tan operation implementation
    /// </summary>
    public struct Tan : IUnaryOp<T>, NumCIL.Generic.Operators.ITan
    {
        /// <summary>
        /// Implementation of the Tan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tan(a); }
		
        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>(@in, @out); }

        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Asin operation implementation
    /// </summary>
    public struct Asin : IUnaryOp<T>, NumCIL.Generic.Operators.IAsin
    {
        /// <summary>
        /// Implementation of the Asin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Asin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Asin(a); }
		
        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>(@in, @out); }

        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Acos operation implementation
    /// </summary>
    public struct Acos : IUnaryOp<T>, NumCIL.Generic.Operators.IAcos
    {
        /// <summary>
        /// Implementation of the Acos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Acos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Acos(a); }
		
        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>(@in, @out); }

        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Atan operation implementation
    /// </summary>
    public struct Atan : IUnaryOp<T>, NumCIL.Generic.Operators.IAtan
    {
        /// <summary>
        /// Implementation of the Atan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Atan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Atan(a); }
		
        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>(@in, @out); }

        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sinh operation implementation
    /// </summary>
    public struct Sinh : IUnaryOp<T>, NumCIL.Generic.Operators.ISinh
    {
        /// <summary>
        /// Implementation of the Sinh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sinh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sinh(a); }
		
        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>(@in, @out); }

        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cosh operation implementation
    /// </summary>
    public struct Cosh : IUnaryOp<T>, NumCIL.Generic.Operators.ICosh
    {
        /// <summary>
        /// Implementation of the Cosh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cosh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cosh(a); }
		
        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>(@in, @out); }

        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tanh operation implementation
    /// </summary>
    public struct Tanh : IUnaryOp<T>, NumCIL.Generic.Operators.ITanh
    {
        /// <summary>
        /// Implementation of the Tanh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tanh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tanh(a); }
		
        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>(@in, @out); }

        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log operation implementation
    /// </summary>
    public struct Log : IUnaryOp<T>, NumCIL.Generic.Operators.ILog
    {
        /// <summary>
        /// Implementation of the Log operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log(a); }
		
        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>(@in, @out); }

        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log10 operation implementation
    /// </summary>
    public struct Log10 : IUnaryOp<T>, NumCIL.Generic.Operators.ILog10
    {
        /// <summary>
        /// Implementation of the Log10 operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log10 to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log10(a); }
		
        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>(@in, @out); }

        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Invert operation implementation
    /// </summary>
    public struct Invert : IUnaryOp<T>, NumCIL.Generic.Operators.IInvert
    {
        /// <summary>
        /// Implementation of the Invert operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Invert to the operand</returns>
        public T Op(T a) 
		{ return (T)(~a); }
		
        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>(@in, @out); }

        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sign operation implementation
    /// </summary>
    public struct Sign : IUnaryOp<T>, NumCIL.Generic.Operators.ISign
    {
        /// <summary>
        /// Implementation of the Sign operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sign to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sign(a); }
		
        /// <summary>
        /// Applies the Sign operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sign>(@in, @out); }

        /// <summary>
        /// Applies the Sign operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sign>((OutArray)@in, @out); }
    }

	#endregion
	#endregion

    #region Generate mimics
    /// <summary>
    /// Generates basic initial arrays
    /// </summary>
    public static class Generate
    {
        /// <summary>
        /// The factory class that produces the NdArray instances
        /// </summary>
        public static NumCIL.Generic.IGenerator<T> Generator = new NumCIL.Generic.Generator<T, NumCIL.Generic.RandomGeneratorOpInt64, NumCIL.Generic.RangeGeneratorOp<T, NumCIL.Generic.NumberConverterInt64>, NumCIL.Generic.NumberConverterInt64>();

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(Shape shape) { return Generator.Range(shape); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(Shape shape) { return Generator.Ones(shape); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(Shape shape) { return Generator.Zeroes(shape); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with uninitialized data</returns>
        public static OutArray Empty(Shape shape) { return Generator.Empty(shape); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to fill the array with</param>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, Shape shape) { return Generator.Same(value, shape); }
        /// <summary>
        /// Creates an array filled with the value random numbers
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to random numbers</returns>
        public static OutArray Random(Shape shape) { return Generator.Random(shape); }

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(params long[] dimensions) { return Generator.Range(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(params long[] dimensions) { return Generator.Ones(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(params long[] dimensions) { return Generator.Zeroes(dimensions); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with uninitialized values</returns>
        public static OutArray Empty(params long[] dimensions) { return Generator.Empty(dimensions); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to set fill the array with</param>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, params long[] dimensions) { return Generator.Same(value, dimensions); }
        /// <summary>
        /// Creates an array filled with random values
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to a random value</returns>
        public static OutArray Random(params long[] dimensions) { return Generator.Random(dimensions); }
    }
    #endregion

	#region Conversion operator
	/// <summary>
    /// Operator for converting a number to another type
    /// </summary>
	public struct ToInt64 :
        IUnaryConvOp<double, T>, 
        IUnaryConvOp<float, T>, 
        IUnaryConvOp<sbyte, T>, 
        IUnaryConvOp<byte,T>, 
        IUnaryConvOp<short, T>, 
        IUnaryConvOp<ushort, T>, 
        IUnaryConvOp<int, T>, 
        IUnaryConvOp<uint,T>, 
        IUnaryConvOp<ulong, T>,
		NumCIL.Generic.Operators.ITypeConversion
    {

        /// <summary>
        /// Converts the input from a <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(double a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(float a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(sbyte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(byte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ushort a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(short a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(uint a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(int a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ulong a) { return (T)a; }
    }
	#endregion
}

namespace NumCIL.UInt64
{
    using T = System.UInt64;
    using InArray = NumCIL.Generic.NdArray<System.UInt64>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray : IEnumerable<InArray>
    {
        #region NdArray Mimics
        /// <summary>
        /// The value instance that gives access to values
        /// </summary>
        public InArray.ValueAccessor Value { get { return value.Value; } }
        /// <summary>
        /// A reference to the shape instance that describes this view
        /// </summary>
        public Shape Shape { get { return value.Shape; } }
        /// <summary>
        /// A reference to the underlying data storage
        /// </summary>
        public T[] AsArray() { return value.AsArray(); }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="index">The element to get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params long[] index] { get { return this.value[index]; } set { this.value[index] = value; } }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="ranges">The range get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params Range[] ranges] { get { return this.value[ranges]; } set { this.value[ranges] = value; } }
        /// <summary>
        /// Returns a flattened (1-d copy) of the current data view
        /// </summary>
        /// <returns>A flattened copy</returns>
        public OutArray Flatten() { return this.value.Flatten(); }
        /// <summary>
        /// Returns a copy of the underlying data, shaped as this view
        /// </summary>
        /// <returns>A copy of the view data</returns>
        public OutArray Clone() { return this.value.Clone(); }
        /// <summary>
        /// Generates a new view based on this array
        /// </summary>
        /// <param name="newshape">The new shape</param>
        /// <returns>The reshaped array</returns>
        public OutArray Reshape(Shape newshape) { return this.value.Reshape(newshape); }
        /// <summary>
        /// Returns a view that is a view of a single element
        /// </summary>
        /// <param name="element">The element to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(long element) { return this.value.Subview(element); }
        /// <summary>
        /// Returns a view that is a view of a range of elements
        /// </summary>
        /// <param name="range">The range to view</param>
        /// <param name="dimension">The dimension to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(Range range, long dimension) { return this.value.Subview(range, dimension); }
        /// <summary>
        /// Returnes a sliced subview of the data, optionally collapsing single element dimensions
        /// </summary>
        /// <param name="ranges">The ranges to view for each dimension</param>
        /// <param name="collapse">True if single element dimensions should be collapsed, false to retain all dimensions</param>
        /// <returns>A new view of the data</returns>
        public OutArray Subview(Range[] ranges, bool collapse) { return this.value.Subview(ranges, collapse); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<InArray> GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// A debug tag used for naming a view
        /// </summary>
        public string Name { get { return this.value.Name; } set { this.value.Name = value; } }
        /// <summary>
        /// The data accessor providing the data storage
        /// </summary>
        public NumCIL.Generic.IDataAccessor<T> DataAccessor { get { return this.value.DataAccessor; } }

        /// <summary>
        /// Constructs a NdArray that is a scalar wrapper,
        /// allows simple scalar operations on arbitrary
        /// NdArrays
        /// </summary>
        /// <param name="value">The scalar value</param>
        public NdArray(T value)
            : this(new NumCIL.Generic.DefaultAccessor<T>(new T[] { value }))
        {
        }

        /// <summary>
        /// Constructs a new NdArray with the specified shape
        /// </summary>
        /// <param name="shape">The shape of the new NdArray</param>
        public NdArray(Shape shape)
            : this(Generate.Empty(shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(T[] data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(NumCIL.Generic.IDataAccessor<T> data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="source">An existing array that will be re-shaped</param>
        /// <param name="newshape">The shape to view the array in</param>
        public NdArray(InArray source, Shape newshape)
            : this(new InArray(source, newshape))
        {
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.value.ToString();
        }

        /// <summary>
        /// Flushes pending operations on the array
        /// </summary>
        public void Flush() { this.value.Flush(); }

        /// <summary>
        /// Returns a transposed view of this array. If <paramref name="out"/> is supplied, the contents are copied into that array.
        /// </summary>
        /// <param name="out">Optional output array</param>
        /// <returns>A transposed view</returns>
        public OutArray Transpose(OutArray @out = null) { return value.Transpose(@out); }

        /// <summary>
        /// Gets or sets data in a transposed view
        /// </summary>
        public OutArray Transposed { get { return value.Transposed; } set { value.Transposed = this.value; } }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform</param>
        /// <param name="axis">The axis to repeat, if not speficied, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform in each axis</param>
        /// <param name="axis">The axis to repeat, if not specified, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long[] repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Concatenates an array onto this array, joined at the axis
        /// </summary>
        /// <param name="arg">The array to join</param>
        /// <param name="axis">The axis to join at</param>
        /// <returns>The joined array</returns>
        public OutArray Concatenate(OutArray arg, long axis = 0) { return this.value.Concatenate(arg, axis); }

        /// <summary>
        /// Sets the values viewed to the values from another array, i.e. copies the values
        /// </summary>
        /// <param name="arg">The data to copy</param>
        public void Set(OutArray arg) { this.value.Set(arg); }
        #endregion

        /// <summary>
        /// The only data member of the struct is a reference to the underlying view
        /// </summary>
        private readonly InArray value;
        /// <summary>
        /// Constructs a new typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array</param>
        public NdArray(InArray v) { this.value = v; }

        #region Implict conversion operators
        /// <summary>
        /// Implicit operator that returns a typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array to wrap</param>
        /// <returns>A wrapped array</returns>
        public static implicit operator OutArray(InArray v) { return v == null ? null : new OutArray(v); }
        /// <summary>
        /// Implicit operator that returns a basic array from a wrapped one
        /// </summary>
        /// <param name="v">The wrapper array</param>
        /// <returns>The basic array</returns>
        public static implicit operator InArray(NdArray v) { return ((object)v) == null ? null : v.value; }
        /// <summary>
        /// Implicit operator that returns a wrapped array from a scalar value
        /// </summary>
        /// <param name="v">The scalar value</param>
        /// <returns>A wrapped array representing the scalar value</returns>
        public static implicit operator OutArray(T v) { return new OutArray(v); }
        #endregion

        #region Operator implementations
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, OutArray b) { return UFunc.Apply<T, Add>(a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, OutArray b) { return UFunc.Apply<T, Sub>(a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, OutArray b) { return UFunc.Apply<T, Mul>(a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, OutArray b) { return UFunc.Apply<T, Div>(a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, OutArray b) { return UFunc.Apply<T, Mod>(a, b, null); }

        /// <summary>
        /// Calculates the incremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of incrementing each value</returns>
        public static OutArray operator ++(OutArray a) { return UFunc.Apply<T, Add>(a, (OutArray)1, null); }
        /// <summary>
        /// Calculates the decremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of decrementing each value</returns>
        public static OutArray operator --(OutArray a) { return UFunc.Apply<T, Sub>(a, (OutArray)1, null); }
        #endregion

        #region Common function implementations
        /// <summary>
        /// Copies all values from this NdArray to the output NdArray
        /// </summary>
        /// <param name="out">Optional target for addition, if null, a new array is created</param>
        /// <returns>An NdArray which is a copy of this array</returns>
        public OutArray Copy(OutArray @out = null) { return UFunc.Apply<T, NumCIL.CopyOp<T>>(this, @out); }
        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, op, @out); }
        /// <summary>
        /// Divides values of an NdArray with this NdArray and returns the modulo result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for modulo result, use to perform in-place modulo</param>
        /// <returns>An NdArray which is the modulo residues of dividing the two NdArrays</returns>
        public OutArray Mod(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mod>(this, op, @out); }
        /// <summary>
        /// Calculates the maximum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the max operation, use to perform in-place maximum calculation</param>
        /// <returns>An NdArray which is the maximum values of the two NdArrays</returns>
        public OutArray Max(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Max>(this, op, @out); }
        /// <summary>
        /// Calculates the minimum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the min operation, use to perform in-place minimum calculation</param>
        /// <returns>An NdArray which is the minimum values of the two NdArrays</returns>
        public OutArray Min(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Min>(this, op, @out); }

        /// <summary>
        /// Returns a new NdArray that is the result of calculating the square root for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the square root of all values</returns>
        public OutArray Sqrt(OutArray @out = null) { return UFunc.Apply<T, Sqrt>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the exponent for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the exponent of all values</returns>
        public OutArray Exp(OutArray @out = null) { return UFunc.Apply<T, Exp>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic of all values</returns>
        public OutArray Log(OutArray @out = null) { return UFunc.Apply<T, Log>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic-10 value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic-10 of all values</returns>
        public OutArray Log10(OutArray @out = null) { return UFunc.Apply<T, Log10>(this, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the mathcing element in the operand NdArray
        /// </summary>
        /// <param name="op">The power-of values</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the values in the operand NdArray</returns>
        public OutArray Pow(NdArray op, OutArray @out = null) { return UFunc.Apply<T, Pow>(this, op, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the scalar value
        /// </summary>
        /// <param name="value">The power-of value</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the scalar value</returns>
        public OutArray Pow(T value, OutArray @out = null)
        {
            if (value == 2)
                return UFunc.Apply<T, Mul>(this, this, @out);
            else
                return UFunc.Apply<T, Pow>(this, (OutArray)value, @out);
        }
        /// <summary>
        /// Performs matrix multiplication on the two elements
        /// </summary>
        /// <param name="arg">The right-hand-side argument in matrix multiplication</param>
        /// <param name="out">Optional target for the multiplication</param>
        /// <returns>The matrix multiplication result</returns>
        public OutArray MatrixMultiply(OutArray arg, OutArray @out = null) { return UFunc.Matmul<T, Add, Mul>(this, arg, @out); }
        #endregion


        #region F# support for missing implicit operators
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(T a, OutArray b) { return UFunc.Apply<T, Add>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, T b) { return UFunc.Apply<T, Add>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(T a, OutArray b) { return UFunc.Apply<T, Sub>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, T b) { return UFunc.Apply<T, Sub>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(T a, OutArray b) { return UFunc.Apply<T, Mul>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, T b) { return UFunc.Apply<T, Mul>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(T a, OutArray b) { return UFunc.Apply<T, Div>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, T b) { return UFunc.Apply<T, Div>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(T a, OutArray b) { return UFunc.Apply<T, Mod>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, T b) { return UFunc.Apply<T, Mod>(a, (OutArray)b, null); }

        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(T op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, (OutArray)op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(T op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, (OutArray)op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(T op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, (OutArray)op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(T op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, (OutArray)op, @out); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(T a, OutArray b) { return UFunc.Apply<T, bool, Equal>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, T b) { return UFunc.Apply<T, bool, Equal>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(T a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, T b) { return UFunc.Apply<T, bool, NotEqual>(a, (OutArray)b, null); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(T a, OutArray b) { return UFunc.Apply<T, bool, LessThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, T b) { return UFunc.Apply<T, bool, LessThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(T a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, T b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, (OutArray)b, null); }
        #endregion

        #region Appliers for custom UFuncs
        /// <summary>
        /// Applies a unary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        public OutArray Apply(Func<T, T> op, OutArray @out = null) { return UFunc.Apply(op, this, @out); }
        /// <summary>
        /// Applies a binary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="b">An input operand</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        public OutArray Apply(Func<T, T, T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray @out = null) where C : struct, IUnaryOp<T> { return UFunc.Apply<T, C>(this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray b, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Apply<T, C>(this, b, @out); }
        /// <summary>
        /// Applies a nullary function to each element in this NdArray
        /// Note that Nullary functions are performed in-place
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <returns>This NdArray</returns>
        public OutArray Apply(INullaryOp<T> op) { UFunc.Apply<T>(op, this); return this; }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IUnaryOp<T> op, OutArray @out = null) { return UFunc.Apply<T>(op, this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IBinaryOp<T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }

        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <typeparam name="C">The function to apply reduction with</typeparam>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the reduction in-place</param>
        /// <returns>An NdArray that is the result of reducing the selected axis</returns>
        public OutArray Reduce<C>(long axis = 0, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Reduce<T, C>(this, axis, @out); }
        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <param name="op">The function to apply reduction with</param>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>A reduced array</returns>
        public OutArray Reduce(IBinaryOp<T> op, long axis = 0, OutArray @out = null) { return UFunc.Reduce<T>(op, this, axis, @out); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <typeparam name="C">The operation to perform</typeparam>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate<C>() where C : struct, IBinaryOp<T> { return UFunc.Aggregate<T, C>(this); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <param name="op">The operation to perform</param>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate(IBinaryOp<T> op) { return UFunc.Aggregate<T>(op, this); }

        /// <summary>
        /// Calculates the sum of all elements
        /// </summary>
        /// <returns>A scalar value that is the sum of all elements</returns>
        public T Sum() { return UFunc.Aggregate<T, Add>(this); }
        /// <summary>
        /// Calculates the maximum of all elements
        /// </summary>
        /// <returns>A scalar value that is the maximum of all elements</returns>
        public T Max() { return UFunc.Aggregate<T, Max>(this); }

        /// <summary>
        /// Calculates the minimum of all elements
        /// </summary>
        /// <returns>A scalar value that is the minimum of all elements</returns>
        public T Min() { return UFunc.Aggregate<T, Min>(this); }
        #endregion

		#region Conversion operators
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Double"/></returns>
        public static implicit operator OutArray(NumCIL.Double.NdArray a) { return UFunc.Apply<double, T, ToUInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Single"/></returns>
        public static implicit operator OutArray(NumCIL.Float.NdArray a) { return UFunc.Apply<float, T, ToUInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.SByte"/></returns>
        public static explicit operator OutArray(NumCIL.Int8.NdArray a) { return UFunc.Apply<sbyte, T, ToUInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int16"/></returns>
        public static explicit operator OutArray(NumCIL.Int16.NdArray a) { return UFunc.Apply<short, T, ToUInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int32"/></returns>
        public static explicit operator OutArray(NumCIL.Int32.NdArray a) { return UFunc.Apply<int, T, ToUInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int64"/></returns>
        public static explicit operator OutArray(NumCIL.Int64.NdArray a) { return UFunc.Apply<long, T, ToUInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Byte"/></returns>
        public static explicit operator OutArray(NumCIL.UInt8.NdArray a) { return UFunc.Apply<byte, T, ToUInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt16"/></returns>
        public static explicit operator OutArray(NumCIL.UInt16.NdArray a) { return UFunc.Apply<ushort, T, ToUInt64>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt32"/></returns>
        public static explicit operator OutArray(NumCIL.UInt32.NdArray a) { return UFunc.Apply<uint, T, ToUInt64>(a); }
        		#endregion

		#region Logical/Bitwise operator overloads
        /// <summary>
        /// Calculates the and of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of and-ing the two input operands</returns>
        public static OutArray operator &(OutArray a, OutArray b) { return UFunc.Apply<T, And>(a, b, null); }
        /// <summary>
        /// Calculates the or of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of or-ing the two input operands</returns>
        public static OutArray operator |(OutArray a, OutArray b) { return UFunc.Apply<T, Or>(a, b, null); }
        /// <summary>
        /// Calculates the xor of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of xor-ing the two input operands</returns>
        public static OutArray operator ^(OutArray a, OutArray b) { return UFunc.Apply<T, Xor>(a, b, null); }
        /// <summary>
        /// Calculates the bitwise complement of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The bitwise complement of the input operand</returns>
        public static OutArray operator !(OutArray a) { return UFunc.Apply<T, Invert>(a, null); }
		#endregion

		#region Comparison operator overloads
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, OutArray b) { return UFunc.Apply<T, bool, Equal>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator ==(OutArray a, object b) { return ((object)a) == b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator !=(OutArray a, object b) { return ((object)a) != b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, b, null); }
		#endregion

		#region System.Object overrides
		/// <summary>
		/// Compares this object to another
		/// </summary>
		/// <returns>A value indicating if the two elements are equal</returns>
		public override bool Equals(object o)
		{
			return this == o;
		}

		/// <summary>
		/// Returns a hashcode for comparing this object to others
		/// </summary>
		/// <returns>A hash code for this instance</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}
		#endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly CopyOp<T> Copy;
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly Add Add;
        /// <summary>
        /// The subtraction operation
        /// </summary>
        public static readonly Sub Sub;
        /// <summary>
        /// The multiplication operation
        /// </summary>
        public static readonly Mul Mul;
        /// <summary>
        /// The division operation
        /// </summary>
        public static readonly Div Div;
        /// <summary>
        /// The modulo operation
        /// </summary>
        public static readonly Mod Mod;
        /// <summary>
        /// The maximum operation
        /// </summary>
        public static readonly Max Max;
        /// <summary>
        /// The minimum operation
        /// </summary>
        public static readonly Min Min;
        /// <summary>
        /// The square root operation
        /// </summary>
        public static readonly Sqrt Sqrt;
        /// <summary>
        /// The exponential operation
        /// </summary>
        public static readonly Exp Exp;
        /// <summary>
        /// The logarithmic operation
        /// </summary>
        public static readonly Log Log;
        /// <summary>
        /// The logarithmic-10 operation
        /// </summary>
        public static readonly Log10 Log10;
        /// <summary>
        /// The power operation
        /// </summary>
        public static readonly Pow Pow;
        /// <summary>
        /// The arc cosine operation
        /// </summary>
        public static readonly Acos Acos;
        /// <summary>
        /// The arc sine operation
        /// </summary>
        public static readonly Asin Asin;
        /// <summary>
        /// The arc tangent operation
        /// </summary>
        public static readonly Atan Atan;
        /// <summary>
        /// The cosine operation
        /// </summary>
        public static readonly Cos Cos;
        /// <summary>
        /// The sine operation
        /// </summary>
        public static readonly Sin Sin;
        /// <summary>
        /// The tangent operation
        /// </summary>
        public static readonly Tan Tan;
        /// <summary>
        /// The hyperbolic cosine operation
        /// </summary>
        public static readonly Cosh Cosh;
        /// <summary>
        /// The hyperbolic sine operation
        /// </summary>
        public static readonly Sinh Sihn;
        /// <summary>
        /// The hyperbolic tangent operation
        /// </summary>
        public static readonly Tanh Tanh;
        /// <summary>
        /// The and operation
        /// </summary>
        public static readonly And And;
        /// <summary>
        /// The or operation
        /// </summary>
        public static readonly Or Or;
        /// <summary>
        /// The xor operation
        /// </summary>
        public static readonly Xor Xor;
        /// <summary>
        /// The invert operation
        /// </summary>
        public static readonly Invert Invert;

    }
    #endregion

	#region Comparison operators
    /// <summary>
    /// The equal Equal implementation
    /// </summary>
    public struct Equal : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IEqual
    {
        /// <summary>
        /// Implementation of Equal test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a == b; }
		
        /// <summary>
        /// Applies the Equal operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, Equal>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThan implementation
    /// </summary>
    public struct GreaterThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThan
    {
        /// <summary>
        /// Implementation of GreaterThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a > b; }
		
        /// <summary>
        /// Applies the GreaterThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThan implementation
    /// </summary>
    public struct LessThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThan
    {
        /// <summary>
        /// Implementation of LessThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a < b; }
		
        /// <summary>
        /// Applies the LessThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThanOrEqual implementation
    /// </summary>
    public struct GreaterThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThanOrEqual
    {
        /// <summary>
        /// Implementation of GreaterThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a >= b; }
		
        /// <summary>
        /// Applies the GreaterThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThanOrEqual implementation
    /// </summary>
    public struct LessThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThanOrEqual
    {
        /// <summary>
        /// Implementation of LessThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a <= b; }
		
        /// <summary>
        /// Applies the LessThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal NotEqual implementation
    /// </summary>
    public struct NotEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.INotEqual
    {
        /// <summary>
        /// Implementation of NotEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a != b; }
		
        /// <summary>
        /// Applies the NotEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, NotEqual>(in1, in2, @out); }
    }

	#endregion

    #region Operator implementations
    /// <summary>
    /// The copy operator implementation
    /// </summary>
    public struct Copy
    {
        /// <summary>
        /// Applies the copy operation to the input operand
        /// </summary>
        /// <param name="in1">The input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise copy of the input view</returns>
        public static OutArray Apply(OutArray in1, OutArray @out = null)
        { return UFunc.Apply<T, NumCIL.CopyOp<T>>(in1, @out); }
    }

	#region Binary operation implementations
    /// <summary>
    /// The Add operator implementation
    /// </summary>
    public struct Add : IBinaryOp<T>, NumCIL.Generic.Operators.IAdd
    {
        /// <summary>
        /// Implementation of Add with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Add with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a + b); }
		
        /// <summary>
        /// Reduces the input array with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Add>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Add>(arg); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>(in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Add>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Sub operator implementation
    /// </summary>
    public struct Sub : IBinaryOp<T>, NumCIL.Generic.Operators.ISub
    {
        /// <summary>
        /// Implementation of Sub with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Sub with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a - b); }
		
        /// <summary>
        /// Reduces the input array with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Sub>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Sub>(arg); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>(in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Sub>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mul operator implementation
    /// </summary>
    public struct Mul : IBinaryOp<T>, NumCIL.Generic.Operators.IMul
    {
        /// <summary>
        /// Implementation of Mul with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mul with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a * b); }
		
        /// <summary>
        /// Reduces the input array with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mul>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mul>(arg); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mul>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Div operator implementation
    /// </summary>
    public struct Div : IBinaryOp<T>, NumCIL.Generic.Operators.IDiv
    {
        /// <summary>
        /// Implementation of Div with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Div with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a / b); }
		
        /// <summary>
        /// Reduces the input array with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Div>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Div>(arg); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>(in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Div>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mod operator implementation
    /// </summary>
    public struct Mod : IBinaryOp<T>, NumCIL.Generic.Operators.IMod
    {
        /// <summary>
        /// Implementation of Mod with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mod with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a % b); }
		
        /// <summary>
        /// Reduces the input array with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mod>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mod>(arg); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mod>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Min operator implementation
    /// </summary>
    public struct Min : IBinaryOp<T>, NumCIL.Generic.Operators.IMin
    {
        /// <summary>
        /// Implementation of Min with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Min with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Min(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Min>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Min>(arg); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>(in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Min>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Max operator implementation
    /// </summary>
    public struct Max : IBinaryOp<T>, NumCIL.Generic.Operators.IMax
    {
        /// <summary>
        /// Implementation of Max with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Max with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Max(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Max>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Max>(arg); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>(in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Max>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Pow operator implementation
    /// </summary>
    public struct Pow : IBinaryOp<T>, NumCIL.Generic.Operators.IPow
    {
        /// <summary>
        /// Implementation of Pow with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Pow with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Pow(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Pow>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Pow>(arg); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>(in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ 
			if (in2 == (T)2)
				return UFunc.Apply<T, Mul>(in1, in1, @out);
			else
				return UFunc.Apply<T, Pow>(in1, (OutArray)in2, @out);
		}
		
    }

    /// <summary>
    /// The And operator implementation
    /// </summary>
    public struct And : IBinaryOp<T>, NumCIL.Generic.Operators.IAnd
    {
        /// <summary>
        /// Implementation of And with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of And with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a & b); }
		
        /// <summary>
        /// Reduces the input array with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, And>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, And>(arg); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>(in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, And>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Or operator implementation
    /// </summary>
    public struct Or : IBinaryOp<T>, NumCIL.Generic.Operators.IOr
    {
        /// <summary>
        /// Implementation of Or with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Or with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a | b); }
		
        /// <summary>
        /// Reduces the input array with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Or>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Or>(arg); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>(in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Or>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Xor operator implementation
    /// </summary>
    public struct Xor : IBinaryOp<T>, NumCIL.Generic.Operators.IXor
    {
        /// <summary>
        /// Implementation of Xor with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Xor with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a ^ b); }
		
        /// <summary>
        /// Reduces the input array with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Xor>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Xor>(arg); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>(in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Xor>(in1, (OutArray)in2, @out); }
    }

	#endregion

	#region Unary operations implementation
    /// <summary>
    /// The Sqrt operation implementation
    /// </summary>
    public struct Sqrt : IUnaryOp<T>, NumCIL.Generic.Operators.ISqrt
    {
        /// <summary>
        /// Implementation of the Sqrt operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sqrt to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sqrt(a); }
		
        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>(@in, @out); }

        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Exp operation implementation
    /// </summary>
    public struct Exp : IUnaryOp<T>, NumCIL.Generic.Operators.IExp
    {
        /// <summary>
        /// Implementation of the Exp operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Exp to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Exp(a); }
		
        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>(@in, @out); }

        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sin operation implementation
    /// </summary>
    public struct Sin : IUnaryOp<T>, NumCIL.Generic.Operators.ISin
    {
        /// <summary>
        /// Implementation of the Sin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sin(a); }
		
        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>(@in, @out); }

        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cos operation implementation
    /// </summary>
    public struct Cos : IUnaryOp<T>, NumCIL.Generic.Operators.ICos
    {
        /// <summary>
        /// Implementation of the Cos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cos(a); }
		
        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>(@in, @out); }

        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tan operation implementation
    /// </summary>
    public struct Tan : IUnaryOp<T>, NumCIL.Generic.Operators.ITan
    {
        /// <summary>
        /// Implementation of the Tan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tan(a); }
		
        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>(@in, @out); }

        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Asin operation implementation
    /// </summary>
    public struct Asin : IUnaryOp<T>, NumCIL.Generic.Operators.IAsin
    {
        /// <summary>
        /// Implementation of the Asin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Asin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Asin(a); }
		
        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>(@in, @out); }

        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Acos operation implementation
    /// </summary>
    public struct Acos : IUnaryOp<T>, NumCIL.Generic.Operators.IAcos
    {
        /// <summary>
        /// Implementation of the Acos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Acos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Acos(a); }
		
        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>(@in, @out); }

        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Atan operation implementation
    /// </summary>
    public struct Atan : IUnaryOp<T>, NumCIL.Generic.Operators.IAtan
    {
        /// <summary>
        /// Implementation of the Atan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Atan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Atan(a); }
		
        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>(@in, @out); }

        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sinh operation implementation
    /// </summary>
    public struct Sinh : IUnaryOp<T>, NumCIL.Generic.Operators.ISinh
    {
        /// <summary>
        /// Implementation of the Sinh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sinh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sinh(a); }
		
        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>(@in, @out); }

        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cosh operation implementation
    /// </summary>
    public struct Cosh : IUnaryOp<T>, NumCIL.Generic.Operators.ICosh
    {
        /// <summary>
        /// Implementation of the Cosh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cosh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cosh(a); }
		
        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>(@in, @out); }

        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tanh operation implementation
    /// </summary>
    public struct Tanh : IUnaryOp<T>, NumCIL.Generic.Operators.ITanh
    {
        /// <summary>
        /// Implementation of the Tanh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tanh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tanh(a); }
		
        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>(@in, @out); }

        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log operation implementation
    /// </summary>
    public struct Log : IUnaryOp<T>, NumCIL.Generic.Operators.ILog
    {
        /// <summary>
        /// Implementation of the Log operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log(a); }
		
        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>(@in, @out); }

        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log10 operation implementation
    /// </summary>
    public struct Log10 : IUnaryOp<T>, NumCIL.Generic.Operators.ILog10
    {
        /// <summary>
        /// Implementation of the Log10 operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log10 to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log10(a); }
		
        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>(@in, @out); }

        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Invert operation implementation
    /// </summary>
    public struct Invert : IUnaryOp<T>, NumCIL.Generic.Operators.IInvert
    {
        /// <summary>
        /// Implementation of the Invert operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Invert to the operand</returns>
        public T Op(T a) 
		{ return (T)(~a); }
		
        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>(@in, @out); }

        /// <summary>
        /// Applies the Invert operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Invert>((OutArray)@in, @out); }
    }

	#endregion
	#endregion

    #region Generate mimics
    /// <summary>
    /// Generates basic initial arrays
    /// </summary>
    public static class Generate
    {
        /// <summary>
        /// The factory class that produces the NdArray instances
        /// </summary>
        public static NumCIL.Generic.IGenerator<T> Generator = new NumCIL.Generic.Generator<T, NumCIL.Generic.RandomGeneratorOpUInt64, NumCIL.Generic.RangeGeneratorOp<T, NumCIL.Generic.NumberConverterUInt64>, NumCIL.Generic.NumberConverterUInt64>();

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(Shape shape) { return Generator.Range(shape); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(Shape shape) { return Generator.Ones(shape); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(Shape shape) { return Generator.Zeroes(shape); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with uninitialized data</returns>
        public static OutArray Empty(Shape shape) { return Generator.Empty(shape); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to fill the array with</param>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, Shape shape) { return Generator.Same(value, shape); }
        /// <summary>
        /// Creates an array filled with the value random numbers
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to random numbers</returns>
        public static OutArray Random(Shape shape) { return Generator.Random(shape); }

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(params long[] dimensions) { return Generator.Range(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(params long[] dimensions) { return Generator.Ones(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(params long[] dimensions) { return Generator.Zeroes(dimensions); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with uninitialized values</returns>
        public static OutArray Empty(params long[] dimensions) { return Generator.Empty(dimensions); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to set fill the array with</param>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, params long[] dimensions) { return Generator.Same(value, dimensions); }
        /// <summary>
        /// Creates an array filled with random values
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to a random value</returns>
        public static OutArray Random(params long[] dimensions) { return Generator.Random(dimensions); }
    }
    #endregion

	#region Conversion operator
	/// <summary>
    /// Operator for converting a number to another type
    /// </summary>
	public struct ToUInt64 :
        IUnaryConvOp<double, T>, 
        IUnaryConvOp<float, T>, 
        IUnaryConvOp<sbyte, T>, 
        IUnaryConvOp<byte,T>, 
        IUnaryConvOp<short, T>, 
        IUnaryConvOp<ushort, T>, 
        IUnaryConvOp<int, T>, 
        IUnaryConvOp<uint,T>, 
        IUnaryConvOp<long, T>, 
		NumCIL.Generic.Operators.ITypeConversion
    {

        /// <summary>
        /// Converts the input from a <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(double a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(float a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(sbyte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(byte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ushort a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(short a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(uint a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(int a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(long a) { return (T)a; }
    }
	#endregion
}

namespace NumCIL.Float
{
    using T = System.Single;
    using InArray = NumCIL.Generic.NdArray<System.Single>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray : IEnumerable<InArray>
    {
        #region NdArray Mimics
        /// <summary>
        /// The value instance that gives access to values
        /// </summary>
        public InArray.ValueAccessor Value { get { return value.Value; } }
        /// <summary>
        /// A reference to the shape instance that describes this view
        /// </summary>
        public Shape Shape { get { return value.Shape; } }
        /// <summary>
        /// A reference to the underlying data storage
        /// </summary>
        public T[] AsArray() { return value.AsArray(); }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="index">The element to get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params long[] index] { get { return this.value[index]; } set { this.value[index] = value; } }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="ranges">The range get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params Range[] ranges] { get { return this.value[ranges]; } set { this.value[ranges] = value; } }
        /// <summary>
        /// Returns a flattened (1-d copy) of the current data view
        /// </summary>
        /// <returns>A flattened copy</returns>
        public OutArray Flatten() { return this.value.Flatten(); }
        /// <summary>
        /// Returns a copy of the underlying data, shaped as this view
        /// </summary>
        /// <returns>A copy of the view data</returns>
        public OutArray Clone() { return this.value.Clone(); }
        /// <summary>
        /// Generates a new view based on this array
        /// </summary>
        /// <param name="newshape">The new shape</param>
        /// <returns>The reshaped array</returns>
        public OutArray Reshape(Shape newshape) { return this.value.Reshape(newshape); }
        /// <summary>
        /// Returns a view that is a view of a single element
        /// </summary>
        /// <param name="element">The element to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(long element) { return this.value.Subview(element); }
        /// <summary>
        /// Returns a view that is a view of a range of elements
        /// </summary>
        /// <param name="range">The range to view</param>
        /// <param name="dimension">The dimension to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(Range range, long dimension) { return this.value.Subview(range, dimension); }
        /// <summary>
        /// Returnes a sliced subview of the data, optionally collapsing single element dimensions
        /// </summary>
        /// <param name="ranges">The ranges to view for each dimension</param>
        /// <param name="collapse">True if single element dimensions should be collapsed, false to retain all dimensions</param>
        /// <returns>A new view of the data</returns>
        public OutArray Subview(Range[] ranges, bool collapse) { return this.value.Subview(ranges, collapse); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<InArray> GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// A debug tag used for naming a view
        /// </summary>
        public string Name { get { return this.value.Name; } set { this.value.Name = value; } }
        /// <summary>
        /// The data accessor providing the data storage
        /// </summary>
        public NumCIL.Generic.IDataAccessor<T> DataAccessor { get { return this.value.DataAccessor; } }

        /// <summary>
        /// Constructs a NdArray that is a scalar wrapper,
        /// allows simple scalar operations on arbitrary
        /// NdArrays
        /// </summary>
        /// <param name="value">The scalar value</param>
        public NdArray(T value)
            : this(new NumCIL.Generic.DefaultAccessor<T>(new T[] { value }))
        {
        }

        /// <summary>
        /// Constructs a new NdArray with the specified shape
        /// </summary>
        /// <param name="shape">The shape of the new NdArray</param>
        public NdArray(Shape shape)
            : this(Generate.Empty(shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(T[] data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(NumCIL.Generic.IDataAccessor<T> data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="source">An existing array that will be re-shaped</param>
        /// <param name="newshape">The shape to view the array in</param>
        public NdArray(InArray source, Shape newshape)
            : this(new InArray(source, newshape))
        {
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.value.ToString();
        }

        /// <summary>
        /// Flushes pending operations on the array
        /// </summary>
        public void Flush() { this.value.Flush(); }

        /// <summary>
        /// Returns a transposed view of this array. If <paramref name="out"/> is supplied, the contents are copied into that array.
        /// </summary>
        /// <param name="out">Optional output array</param>
        /// <returns>A transposed view</returns>
        public OutArray Transpose(OutArray @out = null) { return value.Transpose(@out); }

        /// <summary>
        /// Gets or sets data in a transposed view
        /// </summary>
        public OutArray Transposed { get { return value.Transposed; } set { value.Transposed = this.value; } }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform</param>
        /// <param name="axis">The axis to repeat, if not speficied, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform in each axis</param>
        /// <param name="axis">The axis to repeat, if not specified, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long[] repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Concatenates an array onto this array, joined at the axis
        /// </summary>
        /// <param name="arg">The array to join</param>
        /// <param name="axis">The axis to join at</param>
        /// <returns>The joined array</returns>
        public OutArray Concatenate(OutArray arg, long axis = 0) { return this.value.Concatenate(arg, axis); }

        /// <summary>
        /// Sets the values viewed to the values from another array, i.e. copies the values
        /// </summary>
        /// <param name="arg">The data to copy</param>
        public void Set(OutArray arg) { this.value.Set(arg); }
        #endregion

        /// <summary>
        /// The only data member of the struct is a reference to the underlying view
        /// </summary>
        private readonly InArray value;
        /// <summary>
        /// Constructs a new typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array</param>
        public NdArray(InArray v) { this.value = v; }

        #region Implict conversion operators
        /// <summary>
        /// Implicit operator that returns a typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array to wrap</param>
        /// <returns>A wrapped array</returns>
        public static implicit operator OutArray(InArray v) { return v == null ? null : new OutArray(v); }
        /// <summary>
        /// Implicit operator that returns a basic array from a wrapped one
        /// </summary>
        /// <param name="v">The wrapper array</param>
        /// <returns>The basic array</returns>
        public static implicit operator InArray(NdArray v) { return ((object)v) == null ? null : v.value; }
        /// <summary>
        /// Implicit operator that returns a wrapped array from a scalar value
        /// </summary>
        /// <param name="v">The scalar value</param>
        /// <returns>A wrapped array representing the scalar value</returns>
        public static implicit operator OutArray(T v) { return new OutArray(v); }
        #endregion

        #region Operator implementations
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, OutArray b) { return UFunc.Apply<T, Add>(a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, OutArray b) { return UFunc.Apply<T, Sub>(a, b, null); }
        /// <summary>
        /// Calculates negation of the operand
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a) { return UFunc.Apply<T, Sub>(new OutArray((T)0), a, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, OutArray b) { return UFunc.Apply<T, Mul>(a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, OutArray b) { return UFunc.Apply<T, Div>(a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, OutArray b) { return UFunc.Apply<T, Mod>(a, b, null); }

        /// <summary>
        /// Calculates the incremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of incrementing each value</returns>
        public static OutArray operator ++(OutArray a) { return UFunc.Apply<T, Add>(a, (OutArray)1, null); }
        /// <summary>
        /// Calculates the decremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of decrementing each value</returns>
        public static OutArray operator --(OutArray a) { return UFunc.Apply<T, Sub>(a, (OutArray)1, null); }
        #endregion

        #region Common function implementations
        /// <summary>
        /// Copies all values from this NdArray to the output NdArray
        /// </summary>
        /// <param name="out">Optional target for addition, if null, a new array is created</param>
        /// <returns>An NdArray which is a copy of this array</returns>
        public OutArray Copy(OutArray @out = null) { return UFunc.Apply<T, NumCIL.CopyOp<T>>(this, @out); }
        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, op, @out); }
        /// <summary>
        /// Divides values of an NdArray with this NdArray and returns the modulo result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for modulo result, use to perform in-place modulo</param>
        /// <returns>An NdArray which is the modulo residues of dividing the two NdArrays</returns>
        public OutArray Mod(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mod>(this, op, @out); }
        /// <summary>
        /// Calculates the maximum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the max operation, use to perform in-place maximum calculation</param>
        /// <returns>An NdArray which is the maximum values of the two NdArrays</returns>
        public OutArray Max(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Max>(this, op, @out); }
        /// <summary>
        /// Calculates the minimum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the min operation, use to perform in-place minimum calculation</param>
        /// <returns>An NdArray which is the minimum values of the two NdArrays</returns>
        public OutArray Min(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Min>(this, op, @out); }

        /// <summary>
        /// Returns a new NdArray that is the result of rounding up all the elements in this NdArray to the nearest integer
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all values rounded up to the nearest integer</returns>
        public OutArray Ceiling(OutArray @out = null) { return UFunc.Apply<T, Ceiling>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of rounding down all the elements in this NdArray to the nearest integer
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all values rounded down to the nearest integer</returns>
        public OutArray Floor(OutArray @out = null) { return UFunc.Apply<T, Floor>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of rounding all the elements in this NdArray to the nearest integer
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all values rounded to the nearest integer</returns>
        public OutArray Round(OutArray @out = null) { return UFunc.Apply<T, Round>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the square root for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the square root of all values</returns>
        public OutArray Sqrt(OutArray @out = null) { return UFunc.Apply<T, Sqrt>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the exponent for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the exponent of all values</returns>
        public OutArray Exp(OutArray @out = null) { return UFunc.Apply<T, Exp>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the absolute value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all absolute values</returns>
        public OutArray Abs(OutArray @out = null) { return UFunc.Apply<T, Abs>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic of all values</returns>
        public OutArray Log(OutArray @out = null) { return UFunc.Apply<T, Log>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic-10 value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic-10 of all values</returns>
        public OutArray Log10(OutArray @out = null) { return UFunc.Apply<T, Log10>(this, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the mathcing element in the operand NdArray
        /// </summary>
        /// <param name="op">The power-of values</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the values in the operand NdArray</returns>
        public OutArray Pow(NdArray op, OutArray @out = null) { return UFunc.Apply<T, Pow>(this, op, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the scalar value
        /// </summary>
        /// <param name="value">The power-of value</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the scalar value</returns>
        public OutArray Pow(T value, OutArray @out = null)
        {
            if (value == 2)
                return UFunc.Apply<T, Mul>(this, this, @out);
            else
                return UFunc.Apply<T, Pow>(this, (OutArray)value, @out);
        }
        /// <summary>
        /// Performs matrix multiplication on the two elements
        /// </summary>
        /// <param name="arg">The right-hand-side argument in matrix multiplication</param>
        /// <param name="out">Optional target for the multiplication</param>
        /// <returns>The matrix multiplication result</returns>
        public OutArray MatrixMultiply(OutArray arg, OutArray @out = null) { return UFunc.Matmul<T, Add, Mul>(this, arg, @out); }
        #endregion


        #region F# support for missing implicit operators
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(T a, OutArray b) { return UFunc.Apply<T, Add>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, T b) { return UFunc.Apply<T, Add>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(T a, OutArray b) { return UFunc.Apply<T, Sub>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, T b) { return UFunc.Apply<T, Sub>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(T a, OutArray b) { return UFunc.Apply<T, Mul>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, T b) { return UFunc.Apply<T, Mul>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(T a, OutArray b) { return UFunc.Apply<T, Div>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, T b) { return UFunc.Apply<T, Div>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(T a, OutArray b) { return UFunc.Apply<T, Mod>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, T b) { return UFunc.Apply<T, Mod>(a, (OutArray)b, null); }

        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(T op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, (OutArray)op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(T op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, (OutArray)op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(T op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, (OutArray)op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(T op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, (OutArray)op, @out); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(T a, OutArray b) { return UFunc.Apply<T, bool, Equal>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, T b) { return UFunc.Apply<T, bool, Equal>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(T a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, T b) { return UFunc.Apply<T, bool, NotEqual>(a, (OutArray)b, null); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(T a, OutArray b) { return UFunc.Apply<T, bool, LessThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, T b) { return UFunc.Apply<T, bool, LessThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(T a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, T b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, (OutArray)b, null); }
        #endregion

        #region Appliers for custom UFuncs
        /// <summary>
        /// Applies a unary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        public OutArray Apply(Func<T, T> op, OutArray @out = null) { return UFunc.Apply(op, this, @out); }
        /// <summary>
        /// Applies a binary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="b">An input operand</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        public OutArray Apply(Func<T, T, T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray @out = null) where C : struct, IUnaryOp<T> { return UFunc.Apply<T, C>(this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray b, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Apply<T, C>(this, b, @out); }
        /// <summary>
        /// Applies a nullary function to each element in this NdArray
        /// Note that Nullary functions are performed in-place
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <returns>This NdArray</returns>
        public OutArray Apply(INullaryOp<T> op) { UFunc.Apply<T>(op, this); return this; }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IUnaryOp<T> op, OutArray @out = null) { return UFunc.Apply<T>(op, this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IBinaryOp<T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }

        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <typeparam name="C">The function to apply reduction with</typeparam>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the reduction in-place</param>
        /// <returns>An NdArray that is the result of reducing the selected axis</returns>
        public OutArray Reduce<C>(long axis = 0, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Reduce<T, C>(this, axis, @out); }
        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <param name="op">The function to apply reduction with</param>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>A reduced array</returns>
        public OutArray Reduce(IBinaryOp<T> op, long axis = 0, OutArray @out = null) { return UFunc.Reduce<T>(op, this, axis, @out); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <typeparam name="C">The operation to perform</typeparam>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate<C>() where C : struct, IBinaryOp<T> { return UFunc.Aggregate<T, C>(this); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <param name="op">The operation to perform</param>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate(IBinaryOp<T> op) { return UFunc.Aggregate<T>(op, this); }

        /// <summary>
        /// Calculates the sum of all elements
        /// </summary>
        /// <returns>A scalar value that is the sum of all elements</returns>
        public T Sum() { return UFunc.Aggregate<T, Add>(this); }
        /// <summary>
        /// Calculates the maximum of all elements
        /// </summary>
        /// <returns>A scalar value that is the maximum of all elements</returns>
        public T Max() { return UFunc.Aggregate<T, Max>(this); }

        /// <summary>
        /// Calculates the minimum of all elements
        /// </summary>
        /// <returns>A scalar value that is the minimum of all elements</returns>
        public T Min() { return UFunc.Aggregate<T, Min>(this); }
        #endregion

		#region Conversion operators
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Double"/></returns>
        public static implicit operator OutArray(NumCIL.Double.NdArray a) { return UFunc.Apply<double, T, ToFloat>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.SByte"/></returns>
        public static explicit operator OutArray(NumCIL.Int8.NdArray a) { return UFunc.Apply<sbyte, T, ToFloat>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int16"/></returns>
        public static explicit operator OutArray(NumCIL.Int16.NdArray a) { return UFunc.Apply<short, T, ToFloat>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int32"/></returns>
        public static explicit operator OutArray(NumCIL.Int32.NdArray a) { return UFunc.Apply<int, T, ToFloat>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int64"/></returns>
        public static explicit operator OutArray(NumCIL.Int64.NdArray a) { return UFunc.Apply<long, T, ToFloat>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Byte"/></returns>
        public static explicit operator OutArray(NumCIL.UInt8.NdArray a) { return UFunc.Apply<byte, T, ToFloat>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt16"/></returns>
        public static explicit operator OutArray(NumCIL.UInt16.NdArray a) { return UFunc.Apply<ushort, T, ToFloat>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt32"/></returns>
        public static explicit operator OutArray(NumCIL.UInt32.NdArray a) { return UFunc.Apply<uint, T, ToFloat>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt64"/></returns>
        public static explicit operator OutArray(NumCIL.UInt64.NdArray a) { return UFunc.Apply<ulong, T, ToFloat>(a); }
				#endregion


		#region Comparison operator overloads
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, OutArray b) { return UFunc.Apply<T, bool, Equal>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator ==(OutArray a, object b) { return ((object)a) == b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator !=(OutArray a, object b) { return ((object)a) != b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, b, null); }
		#endregion

		#region System.Object overrides
		/// <summary>
		/// Compares this object to another
		/// </summary>
		/// <returns>A value indicating if the two elements are equal</returns>
		public override bool Equals(object o)
		{
			return this == o;
		}

		/// <summary>
		/// Returns a hashcode for comparing this object to others
		/// </summary>
		/// <returns>A hash code for this instance</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}
		#endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly CopyOp<T> Copy;
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly Add Add;
        /// <summary>
        /// The subtraction operation
        /// </summary>
        public static readonly Sub Sub;
        /// <summary>
        /// The multiplication operation
        /// </summary>
        public static readonly Mul Mul;
        /// <summary>
        /// The division operation
        /// </summary>
        public static readonly Div Div;
        /// <summary>
        /// The modulo operation
        /// </summary>
        public static readonly Mod Mod;
        /// <summary>
        /// The maximum operation
        /// </summary>
        public static readonly Max Max;
        /// <summary>
        /// The minimum operation
        /// </summary>
        public static readonly Min Min;
        /// <summary>
        /// The floor operation
        /// </summary>
        public static readonly Floor Floor;
        /// <summary>
        /// The ceiling operation
        /// </summary>
        public static readonly Ceiling Ceiling;
        /// <summary>
        /// The round operation
        /// </summary>
        public static readonly Round Round;
        /// <summary>
        /// The absolute operation
        /// </summary>
        public static readonly Abs Abs;
        /// <summary>
        /// The square root operation
        /// </summary>
        public static readonly Sqrt Sqrt;
        /// <summary>
        /// The exponential operation
        /// </summary>
        public static readonly Exp Exp;
        /// <summary>
        /// The logarithmic operation
        /// </summary>
        public static readonly Log Log;
        /// <summary>
        /// The logarithmic-10 operation
        /// </summary>
        public static readonly Log10 Log10;
        /// <summary>
        /// The power operation
        /// </summary>
        public static readonly Pow Pow;
        /// <summary>
        /// The arc cosine operation
        /// </summary>
        public static readonly Acos Acos;
        /// <summary>
        /// The arc sine operation
        /// </summary>
        public static readonly Asin Asin;
        /// <summary>
        /// The arc tangent operation
        /// </summary>
        public static readonly Atan Atan;
        /// <summary>
        /// The cosine operation
        /// </summary>
        public static readonly Cos Cos;
        /// <summary>
        /// The sine operation
        /// </summary>
        public static readonly Sin Sin;
        /// <summary>
        /// The tangent operation
        /// </summary>
        public static readonly Tan Tan;
        /// <summary>
        /// The hyperbolic cosine operation
        /// </summary>
        public static readonly Cosh Cosh;
        /// <summary>
        /// The hyperbolic sine operation
        /// </summary>
        public static readonly Sinh Sihn;
        /// <summary>
        /// The hyperbolic tangent operation
        /// </summary>
        public static readonly Tanh Tanh;
    }
    #endregion

	#region Comparison operators
    /// <summary>
    /// The equal Equal implementation
    /// </summary>
    public struct Equal : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IEqual
    {
        /// <summary>
        /// Implementation of Equal test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a == b; }
		
        /// <summary>
        /// Applies the Equal operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, Equal>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThan implementation
    /// </summary>
    public struct GreaterThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThan
    {
        /// <summary>
        /// Implementation of GreaterThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a > b; }
		
        /// <summary>
        /// Applies the GreaterThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThan implementation
    /// </summary>
    public struct LessThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThan
    {
        /// <summary>
        /// Implementation of LessThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a < b; }
		
        /// <summary>
        /// Applies the LessThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThanOrEqual implementation
    /// </summary>
    public struct GreaterThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThanOrEqual
    {
        /// <summary>
        /// Implementation of GreaterThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a >= b; }
		
        /// <summary>
        /// Applies the GreaterThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThanOrEqual implementation
    /// </summary>
    public struct LessThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThanOrEqual
    {
        /// <summary>
        /// Implementation of LessThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a <= b; }
		
        /// <summary>
        /// Applies the LessThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal NotEqual implementation
    /// </summary>
    public struct NotEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.INotEqual
    {
        /// <summary>
        /// Implementation of NotEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a != b; }
		
        /// <summary>
        /// Applies the NotEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, NotEqual>(in1, in2, @out); }
    }

	#endregion

    #region Operator implementations
    /// <summary>
    /// The copy operator implementation
    /// </summary>
    public struct Copy
    {
        /// <summary>
        /// Applies the copy operation to the input operand
        /// </summary>
        /// <param name="in1">The input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise copy of the input view</returns>
        public static OutArray Apply(OutArray in1, OutArray @out = null)
        { return UFunc.Apply<T, NumCIL.CopyOp<T>>(in1, @out); }
    }

	#region Binary operation implementations
    /// <summary>
    /// The Add operator implementation
    /// </summary>
    public struct Add : IBinaryOp<T>, NumCIL.Generic.Operators.IAdd
    {
        /// <summary>
        /// Implementation of Add with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Add with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a + b); }
		
        /// <summary>
        /// Reduces the input array with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Add>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Add>(arg); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>(in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Add>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Sub operator implementation
    /// </summary>
    public struct Sub : IBinaryOp<T>, NumCIL.Generic.Operators.ISub
    {
        /// <summary>
        /// Implementation of Sub with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Sub with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a - b); }
		
        /// <summary>
        /// Reduces the input array with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Sub>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Sub>(arg); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>(in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Sub>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mul operator implementation
    /// </summary>
    public struct Mul : IBinaryOp<T>, NumCIL.Generic.Operators.IMul
    {
        /// <summary>
        /// Implementation of Mul with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mul with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a * b); }
		
        /// <summary>
        /// Reduces the input array with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mul>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mul>(arg); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mul>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Div operator implementation
    /// </summary>
    public struct Div : IBinaryOp<T>, NumCIL.Generic.Operators.IDiv
    {
        /// <summary>
        /// Implementation of Div with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Div with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a / b); }
		
        /// <summary>
        /// Reduces the input array with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Div>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Div>(arg); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>(in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Div>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mod operator implementation
    /// </summary>
    public struct Mod : IBinaryOp<T>, NumCIL.Generic.Operators.IMod
    {
        /// <summary>
        /// Implementation of Mod with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mod with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a % b); }
		
        /// <summary>
        /// Reduces the input array with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mod>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mod>(arg); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mod>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Min operator implementation
    /// </summary>
    public struct Min : IBinaryOp<T>, NumCIL.Generic.Operators.IMin
    {
        /// <summary>
        /// Implementation of Min with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Min with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Min(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Min>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Min>(arg); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>(in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Min>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Max operator implementation
    /// </summary>
    public struct Max : IBinaryOp<T>, NumCIL.Generic.Operators.IMax
    {
        /// <summary>
        /// Implementation of Max with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Max with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Max(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Max>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Max>(arg); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>(in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Max>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Pow operator implementation
    /// </summary>
    public struct Pow : IBinaryOp<T>, NumCIL.Generic.Operators.IPow
    {
        /// <summary>
        /// Implementation of Pow with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Pow with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Pow(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Pow>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Pow>(arg); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>(in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ 
			if (in2 == (T)2)
				return UFunc.Apply<T, Mul>(in1, in1, @out);
			else
				return UFunc.Apply<T, Pow>(in1, (OutArray)in2, @out);
		}
		
    }

	#endregion

	#region Unary operations implementation
    /// <summary>
    /// The Ceiling operation implementation
    /// </summary>
    public struct Ceiling : IUnaryOp<T>, NumCIL.Generic.Operators.ICeiling
    {
        /// <summary>
        /// Implementation of the Ceiling operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Ceiling to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Ceiling(a); }
		
        /// <summary>
        /// Applies the Ceiling operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Ceiling>(@in, @out); }

        /// <summary>
        /// Applies the Ceiling operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Ceiling>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Floor operation implementation
    /// </summary>
    public struct Floor : IUnaryOp<T>, NumCIL.Generic.Operators.IFloor
    {
        /// <summary>
        /// Implementation of the Floor operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Floor to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Floor(a); }
		
        /// <summary>
        /// Applies the Floor operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Floor>(@in, @out); }

        /// <summary>
        /// Applies the Floor operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Floor>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Round operation implementation
    /// </summary>
    public struct Round : IUnaryOp<T>, NumCIL.Generic.Operators.IRound
    {
        /// <summary>
        /// Implementation of the Round operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Round to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Round(a); }
		
        /// <summary>
        /// Applies the Round operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Round>(@in, @out); }

        /// <summary>
        /// Applies the Round operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Round>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sqrt operation implementation
    /// </summary>
    public struct Sqrt : IUnaryOp<T>, NumCIL.Generic.Operators.ISqrt
    {
        /// <summary>
        /// Implementation of the Sqrt operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sqrt to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sqrt(a); }
		
        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>(@in, @out); }

        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Exp operation implementation
    /// </summary>
    public struct Exp : IUnaryOp<T>, NumCIL.Generic.Operators.IExp
    {
        /// <summary>
        /// Implementation of the Exp operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Exp to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Exp(a); }
		
        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>(@in, @out); }

        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Abs operation implementation
    /// </summary>
    public struct Abs : IUnaryOp<T>, NumCIL.Generic.Operators.IAbs
    {
        /// <summary>
        /// Implementation of the Abs operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Abs to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Abs(a); }
		
        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>(@in, @out); }

        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sin operation implementation
    /// </summary>
    public struct Sin : IUnaryOp<T>, NumCIL.Generic.Operators.ISin
    {
        /// <summary>
        /// Implementation of the Sin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sin(a); }
		
        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>(@in, @out); }

        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cos operation implementation
    /// </summary>
    public struct Cos : IUnaryOp<T>, NumCIL.Generic.Operators.ICos
    {
        /// <summary>
        /// Implementation of the Cos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cos(a); }
		
        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>(@in, @out); }

        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tan operation implementation
    /// </summary>
    public struct Tan : IUnaryOp<T>, NumCIL.Generic.Operators.ITan
    {
        /// <summary>
        /// Implementation of the Tan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tan(a); }
		
        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>(@in, @out); }

        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Asin operation implementation
    /// </summary>
    public struct Asin : IUnaryOp<T>, NumCIL.Generic.Operators.IAsin
    {
        /// <summary>
        /// Implementation of the Asin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Asin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Asin(a); }
		
        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>(@in, @out); }

        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Acos operation implementation
    /// </summary>
    public struct Acos : IUnaryOp<T>, NumCIL.Generic.Operators.IAcos
    {
        /// <summary>
        /// Implementation of the Acos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Acos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Acos(a); }
		
        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>(@in, @out); }

        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Atan operation implementation
    /// </summary>
    public struct Atan : IUnaryOp<T>, NumCIL.Generic.Operators.IAtan
    {
        /// <summary>
        /// Implementation of the Atan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Atan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Atan(a); }
		
        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>(@in, @out); }

        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sinh operation implementation
    /// </summary>
    public struct Sinh : IUnaryOp<T>, NumCIL.Generic.Operators.ISinh
    {
        /// <summary>
        /// Implementation of the Sinh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sinh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sinh(a); }
		
        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>(@in, @out); }

        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cosh operation implementation
    /// </summary>
    public struct Cosh : IUnaryOp<T>, NumCIL.Generic.Operators.ICosh
    {
        /// <summary>
        /// Implementation of the Cosh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cosh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cosh(a); }
		
        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>(@in, @out); }

        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tanh operation implementation
    /// </summary>
    public struct Tanh : IUnaryOp<T>, NumCIL.Generic.Operators.ITanh
    {
        /// <summary>
        /// Implementation of the Tanh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tanh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tanh(a); }
		
        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>(@in, @out); }

        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log operation implementation
    /// </summary>
    public struct Log : IUnaryOp<T>, NumCIL.Generic.Operators.ILog
    {
        /// <summary>
        /// Implementation of the Log operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log(a); }
		
        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>(@in, @out); }

        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log10 operation implementation
    /// </summary>
    public struct Log10 : IUnaryOp<T>, NumCIL.Generic.Operators.ILog10
    {
        /// <summary>
        /// Implementation of the Log10 operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log10 to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log10(a); }
		
        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>(@in, @out); }

        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sign operation implementation
    /// </summary>
    public struct Sign : IUnaryOp<T>, NumCIL.Generic.Operators.ISign
    {
        /// <summary>
        /// Implementation of the Sign operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sign to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sign(a); }
		
        /// <summary>
        /// Applies the Sign operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sign>(@in, @out); }

        /// <summary>
        /// Applies the Sign operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sign>((OutArray)@in, @out); }
    }

	#endregion
	#endregion

    #region Generate mimics
    /// <summary>
    /// Generates basic initial arrays
    /// </summary>
    public static class Generate
    {
        /// <summary>
        /// The factory class that produces the NdArray instances
        /// </summary>
        public static NumCIL.Generic.IGenerator<T> Generator = new NumCIL.Generic.Generator<T, NumCIL.Generic.RandomGeneratorOpFloat, NumCIL.Generic.RangeGeneratorOp<T, NumCIL.Generic.NumberConverterFloat>, NumCIL.Generic.NumberConverterFloat>();

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(Shape shape) { return Generator.Range(shape); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(Shape shape) { return Generator.Ones(shape); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(Shape shape) { return Generator.Zeroes(shape); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with uninitialized data</returns>
        public static OutArray Empty(Shape shape) { return Generator.Empty(shape); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to fill the array with</param>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, Shape shape) { return Generator.Same(value, shape); }
        /// <summary>
        /// Creates an array filled with the value random numbers
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to random numbers</returns>
        public static OutArray Random(Shape shape) { return Generator.Random(shape); }

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(params long[] dimensions) { return Generator.Range(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(params long[] dimensions) { return Generator.Ones(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(params long[] dimensions) { return Generator.Zeroes(dimensions); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with uninitialized values</returns>
        public static OutArray Empty(params long[] dimensions) { return Generator.Empty(dimensions); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to set fill the array with</param>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, params long[] dimensions) { return Generator.Same(value, dimensions); }
        /// <summary>
        /// Creates an array filled with random values
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to a random value</returns>
        public static OutArray Random(params long[] dimensions) { return Generator.Random(dimensions); }
    }
    #endregion

	#region Conversion operator
	/// <summary>
    /// Operator for converting a number to another type
    /// </summary>
	public struct ToFloat :
        IUnaryConvOp<double, T>, 
        IUnaryConvOp<sbyte, T>, 
        IUnaryConvOp<byte,T>, 
        IUnaryConvOp<short, T>, 
        IUnaryConvOp<ushort, T>, 
        IUnaryConvOp<int, T>, 
        IUnaryConvOp<uint,T>, 
        IUnaryConvOp<long, T>, 
        IUnaryConvOp<ulong, T>,
		NumCIL.Generic.Operators.ITypeConversion
    {

        /// <summary>
        /// Converts the input from a <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(double a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(sbyte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(byte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ushort a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(short a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(uint a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(int a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ulong a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(long a) { return (T)a; }
    }
	#endregion
}

namespace NumCIL.Double
{
    using T = System.Double;
    using InArray = NumCIL.Generic.NdArray<System.Double>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray : IEnumerable<InArray>
    {
        #region NdArray Mimics
        /// <summary>
        /// The value instance that gives access to values
        /// </summary>
        public InArray.ValueAccessor Value { get { return value.Value; } }
        /// <summary>
        /// A reference to the shape instance that describes this view
        /// </summary>
        public Shape Shape { get { return value.Shape; } }
        /// <summary>
        /// A reference to the underlying data storage
        /// </summary>
        public T[] AsArray() { return value.AsArray(); }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="index">The element to get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params long[] index] { get { return this.value[index]; } set { this.value[index] = value; } }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="ranges">The range get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params Range[] ranges] { get { return this.value[ranges]; } set { this.value[ranges] = value; } }
        /// <summary>
        /// Returns a flattened (1-d copy) of the current data view
        /// </summary>
        /// <returns>A flattened copy</returns>
        public OutArray Flatten() { return this.value.Flatten(); }
        /// <summary>
        /// Returns a copy of the underlying data, shaped as this view
        /// </summary>
        /// <returns>A copy of the view data</returns>
        public OutArray Clone() { return this.value.Clone(); }
        /// <summary>
        /// Generates a new view based on this array
        /// </summary>
        /// <param name="newshape">The new shape</param>
        /// <returns>The reshaped array</returns>
        public OutArray Reshape(Shape newshape) { return this.value.Reshape(newshape); }
        /// <summary>
        /// Returns a view that is a view of a single element
        /// </summary>
        /// <param name="element">The element to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(long element) { return this.value.Subview(element); }
        /// <summary>
        /// Returns a view that is a view of a range of elements
        /// </summary>
        /// <param name="range">The range to view</param>
        /// <param name="dimension">The dimension to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(Range range, long dimension) { return this.value.Subview(range, dimension); }
        /// <summary>
        /// Returnes a sliced subview of the data, optionally collapsing single element dimensions
        /// </summary>
        /// <param name="ranges">The ranges to view for each dimension</param>
        /// <param name="collapse">True if single element dimensions should be collapsed, false to retain all dimensions</param>
        /// <returns>A new view of the data</returns>
        public OutArray Subview(Range[] ranges, bool collapse) { return this.value.Subview(ranges, collapse); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<InArray> GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// A debug tag used for naming a view
        /// </summary>
        public string Name { get { return this.value.Name; } set { this.value.Name = value; } }
        /// <summary>
        /// The data accessor providing the data storage
        /// </summary>
        public NumCIL.Generic.IDataAccessor<T> DataAccessor { get { return this.value.DataAccessor; } }

        /// <summary>
        /// Constructs a NdArray that is a scalar wrapper,
        /// allows simple scalar operations on arbitrary
        /// NdArrays
        /// </summary>
        /// <param name="value">The scalar value</param>
        public NdArray(T value)
            : this(new NumCIL.Generic.DefaultAccessor<T>(new T[] { value }))
        {
        }

        /// <summary>
        /// Constructs a new NdArray with the specified shape
        /// </summary>
        /// <param name="shape">The shape of the new NdArray</param>
        public NdArray(Shape shape)
            : this(Generate.Empty(shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(T[] data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(NumCIL.Generic.IDataAccessor<T> data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="source">An existing array that will be re-shaped</param>
        /// <param name="newshape">The shape to view the array in</param>
        public NdArray(InArray source, Shape newshape)
            : this(new InArray(source, newshape))
        {
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.value.ToString();
        }

        /// <summary>
        /// Flushes pending operations on the array
        /// </summary>
        public void Flush() { this.value.Flush(); }

        /// <summary>
        /// Returns a transposed view of this array. If <paramref name="out"/> is supplied, the contents are copied into that array.
        /// </summary>
        /// <param name="out">Optional output array</param>
        /// <returns>A transposed view</returns>
        public OutArray Transpose(OutArray @out = null) { return value.Transpose(@out); }

        /// <summary>
        /// Gets or sets data in a transposed view
        /// </summary>
        public OutArray Transposed { get { return value.Transposed; } set { value.Transposed = this.value; } }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform</param>
        /// <param name="axis">The axis to repeat, if not speficied, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform in each axis</param>
        /// <param name="axis">The axis to repeat, if not specified, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long[] repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Concatenates an array onto this array, joined at the axis
        /// </summary>
        /// <param name="arg">The array to join</param>
        /// <param name="axis">The axis to join at</param>
        /// <returns>The joined array</returns>
        public OutArray Concatenate(OutArray arg, long axis = 0) { return this.value.Concatenate(arg, axis); }

        /// <summary>
        /// Sets the values viewed to the values from another array, i.e. copies the values
        /// </summary>
        /// <param name="arg">The data to copy</param>
        public void Set(OutArray arg) { this.value.Set(arg); }
        #endregion

        /// <summary>
        /// The only data member of the struct is a reference to the underlying view
        /// </summary>
        private readonly InArray value;
        /// <summary>
        /// Constructs a new typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array</param>
        public NdArray(InArray v) { this.value = v; }

        #region Implict conversion operators
        /// <summary>
        /// Implicit operator that returns a typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array to wrap</param>
        /// <returns>A wrapped array</returns>
        public static implicit operator OutArray(InArray v) { return v == null ? null : new OutArray(v); }
        /// <summary>
        /// Implicit operator that returns a basic array from a wrapped one
        /// </summary>
        /// <param name="v">The wrapper array</param>
        /// <returns>The basic array</returns>
        public static implicit operator InArray(NdArray v) { return ((object)v) == null ? null : v.value; }
        /// <summary>
        /// Implicit operator that returns a wrapped array from a scalar value
        /// </summary>
        /// <param name="v">The scalar value</param>
        /// <returns>A wrapped array representing the scalar value</returns>
        public static implicit operator OutArray(T v) { return new OutArray(v); }
        #endregion

        #region Operator implementations
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, OutArray b) { return UFunc.Apply<T, Add>(a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, OutArray b) { return UFunc.Apply<T, Sub>(a, b, null); }
        /// <summary>
        /// Calculates negation of the operand
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a) { return UFunc.Apply<T, Sub>(new OutArray((T)0), a, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, OutArray b) { return UFunc.Apply<T, Mul>(a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, OutArray b) { return UFunc.Apply<T, Div>(a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, OutArray b) { return UFunc.Apply<T, Mod>(a, b, null); }

        /// <summary>
        /// Calculates the incremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of incrementing each value</returns>
        public static OutArray operator ++(OutArray a) { return UFunc.Apply<T, Add>(a, (OutArray)1, null); }
        /// <summary>
        /// Calculates the decremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of decrementing each value</returns>
        public static OutArray operator --(OutArray a) { return UFunc.Apply<T, Sub>(a, (OutArray)1, null); }
        #endregion

        #region Common function implementations
        /// <summary>
        /// Copies all values from this NdArray to the output NdArray
        /// </summary>
        /// <param name="out">Optional target for addition, if null, a new array is created</param>
        /// <returns>An NdArray which is a copy of this array</returns>
        public OutArray Copy(OutArray @out = null) { return UFunc.Apply<T, NumCIL.CopyOp<T>>(this, @out); }
        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, op, @out); }
        /// <summary>
        /// Divides values of an NdArray with this NdArray and returns the modulo result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for modulo result, use to perform in-place modulo</param>
        /// <returns>An NdArray which is the modulo residues of dividing the two NdArrays</returns>
        public OutArray Mod(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mod>(this, op, @out); }
        /// <summary>
        /// Calculates the maximum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the max operation, use to perform in-place maximum calculation</param>
        /// <returns>An NdArray which is the maximum values of the two NdArrays</returns>
        public OutArray Max(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Max>(this, op, @out); }
        /// <summary>
        /// Calculates the minimum values of each element in two NdArrays and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to compare with</param>
        /// <param name="out">Optional target for the min operation, use to perform in-place minimum calculation</param>
        /// <returns>An NdArray which is the minimum values of the two NdArrays</returns>
        public OutArray Min(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Min>(this, op, @out); }

        /// <summary>
        /// Returns a new NdArray that is the result of rounding up all the elements in this NdArray to the nearest integer
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all values rounded up to the nearest integer</returns>
        public OutArray Ceiling(OutArray @out = null) { return UFunc.Apply<T, Ceiling>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of rounding down all the elements in this NdArray to the nearest integer
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all values rounded down to the nearest integer</returns>
        public OutArray Floor(OutArray @out = null) { return UFunc.Apply<T, Floor>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of rounding all the elements in this NdArray to the nearest integer
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all values rounded to the nearest integer</returns>
        public OutArray Round(OutArray @out = null) { return UFunc.Apply<T, Round>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the square root for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the square root of all values</returns>
        public OutArray Sqrt(OutArray @out = null) { return UFunc.Apply<T, Sqrt>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the exponent for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the exponent of all values</returns>
        public OutArray Exp(OutArray @out = null) { return UFunc.Apply<T, Exp>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the absolute value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all absolute values</returns>
        public OutArray Abs(OutArray @out = null) { return UFunc.Apply<T, Abs>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic of all values</returns>
        public OutArray Log(OutArray @out = null) { return UFunc.Apply<T, Log>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic-10 value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic-10 of all values</returns>
        public OutArray Log10(OutArray @out = null) { return UFunc.Apply<T, Log10>(this, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the mathcing element in the operand NdArray
        /// </summary>
        /// <param name="op">The power-of values</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the values in the operand NdArray</returns>
        public OutArray Pow(NdArray op, OutArray @out = null) { return UFunc.Apply<T, Pow>(this, op, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the scalar value
        /// </summary>
        /// <param name="value">The power-of value</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the scalar value</returns>
        public OutArray Pow(T value, OutArray @out = null)
        {
            if (value == 2)
                return UFunc.Apply<T, Mul>(this, this, @out);
            else
                return UFunc.Apply<T, Pow>(this, (OutArray)value, @out);
        }
        /// <summary>
        /// Performs matrix multiplication on the two elements
        /// </summary>
        /// <param name="arg">The right-hand-side argument in matrix multiplication</param>
        /// <param name="out">Optional target for the multiplication</param>
        /// <returns>The matrix multiplication result</returns>
        public OutArray MatrixMultiply(OutArray arg, OutArray @out = null) { return UFunc.Matmul<T, Add, Mul>(this, arg, @out); }
        #endregion


        #region F# support for missing implicit operators
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(T a, OutArray b) { return UFunc.Apply<T, Add>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, T b) { return UFunc.Apply<T, Add>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(T a, OutArray b) { return UFunc.Apply<T, Sub>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, T b) { return UFunc.Apply<T, Sub>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(T a, OutArray b) { return UFunc.Apply<T, Mul>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, T b) { return UFunc.Apply<T, Mul>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(T a, OutArray b) { return UFunc.Apply<T, Div>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, T b) { return UFunc.Apply<T, Div>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(T a, OutArray b) { return UFunc.Apply<T, Mod>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates modulo of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The modulo result of dividing the two input operands</returns>
        public static OutArray operator %(OutArray a, T b) { return UFunc.Apply<T, Mod>(a, (OutArray)b, null); }

        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(T op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, (OutArray)op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(T op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, (OutArray)op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(T op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, (OutArray)op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(T op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, (OutArray)op, @out); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(T a, OutArray b) { return UFunc.Apply<T, bool, Equal>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, T b) { return UFunc.Apply<T, bool, Equal>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(T a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, T b) { return UFunc.Apply<T, bool, NotEqual>(a, (OutArray)b, null); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(T a, OutArray b) { return UFunc.Apply<T, bool, LessThan>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, T b) { return UFunc.Apply<T, bool, LessThan>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(T a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, T b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(T a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, T b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, (OutArray)b, null); }
        #endregion

        #region Appliers for custom UFuncs
        /// <summary>
        /// Applies a unary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        public OutArray Apply(Func<T, T> op, OutArray @out = null) { return UFunc.Apply(op, this, @out); }
        /// <summary>
        /// Applies a binary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="b">An input operand</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        public OutArray Apply(Func<T, T, T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray @out = null) where C : struct, IUnaryOp<T> { return UFunc.Apply<T, C>(this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray b, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Apply<T, C>(this, b, @out); }
        /// <summary>
        /// Applies a nullary function to each element in this NdArray
        /// Note that Nullary functions are performed in-place
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <returns>This NdArray</returns>
        public OutArray Apply(INullaryOp<T> op) { UFunc.Apply<T>(op, this); return this; }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IUnaryOp<T> op, OutArray @out = null) { return UFunc.Apply<T>(op, this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IBinaryOp<T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }

        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <typeparam name="C">The function to apply reduction with</typeparam>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the reduction in-place</param>
        /// <returns>An NdArray that is the result of reducing the selected axis</returns>
        public OutArray Reduce<C>(long axis = 0, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Reduce<T, C>(this, axis, @out); }
        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <param name="op">The function to apply reduction with</param>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>A reduced array</returns>
        public OutArray Reduce(IBinaryOp<T> op, long axis = 0, OutArray @out = null) { return UFunc.Reduce<T>(op, this, axis, @out); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <typeparam name="C">The operation to perform</typeparam>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate<C>() where C : struct, IBinaryOp<T> { return UFunc.Aggregate<T, C>(this); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <param name="op">The operation to perform</param>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate(IBinaryOp<T> op) { return UFunc.Aggregate<T>(op, this); }

        /// <summary>
        /// Calculates the sum of all elements
        /// </summary>
        /// <returns>A scalar value that is the sum of all elements</returns>
        public T Sum() { return UFunc.Aggregate<T, Add>(this); }
        /// <summary>
        /// Calculates the maximum of all elements
        /// </summary>
        /// <returns>A scalar value that is the maximum of all elements</returns>
        public T Max() { return UFunc.Aggregate<T, Max>(this); }

        /// <summary>
        /// Calculates the minimum of all elements
        /// </summary>
        /// <returns>A scalar value that is the minimum of all elements</returns>
        public T Min() { return UFunc.Aggregate<T, Min>(this); }
        #endregion

		#region Conversion operators
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Single"/></returns>
        public static explicit operator OutArray(NumCIL.Float.NdArray a) { return UFunc.Apply<float, T, ToDouble>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.SByte"/></returns>
        public static explicit operator OutArray(NumCIL.Int8.NdArray a) { return UFunc.Apply<sbyte, T, ToDouble>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int16"/></returns>
        public static explicit operator OutArray(NumCIL.Int16.NdArray a) { return UFunc.Apply<short, T, ToDouble>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int32"/></returns>
        public static explicit operator OutArray(NumCIL.Int32.NdArray a) { return UFunc.Apply<int, T, ToDouble>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int64"/></returns>
        public static explicit operator OutArray(NumCIL.Int64.NdArray a) { return UFunc.Apply<long, T, ToDouble>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Byte"/></returns>
        public static explicit operator OutArray(NumCIL.UInt8.NdArray a) { return UFunc.Apply<byte, T, ToDouble>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt16"/></returns>
        public static explicit operator OutArray(NumCIL.UInt16.NdArray a) { return UFunc.Apply<ushort, T, ToDouble>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt32"/></returns>
        public static explicit operator OutArray(NumCIL.UInt32.NdArray a) { return UFunc.Apply<uint, T, ToDouble>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt64"/></returns>
        public static explicit operator OutArray(NumCIL.UInt64.NdArray a) { return UFunc.Apply<ulong, T, ToDouble>(a); }
				#endregion


		#region Comparison operator overloads
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, OutArray b) { return UFunc.Apply<T, bool, Equal>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator ==(OutArray a, object b) { return ((object)a) == b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator !=(OutArray a, object b) { return ((object)a) != b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThan>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is greater than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator >=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, GreaterThanOrEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is less than or equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator <=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, LessThanOrEqual>(a, b, null); }
		#endregion

		#region System.Object overrides
		/// <summary>
		/// Compares this object to another
		/// </summary>
		/// <returns>A value indicating if the two elements are equal</returns>
		public override bool Equals(object o)
		{
			return this == o;
		}

		/// <summary>
		/// Returns a hashcode for comparing this object to others
		/// </summary>
		/// <returns>A hash code for this instance</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}
		#endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly CopyOp<T> Copy;
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly Add Add;
        /// <summary>
        /// The subtraction operation
        /// </summary>
        public static readonly Sub Sub;
        /// <summary>
        /// The multiplication operation
        /// </summary>
        public static readonly Mul Mul;
        /// <summary>
        /// The division operation
        /// </summary>
        public static readonly Div Div;
        /// <summary>
        /// The modulo operation
        /// </summary>
        public static readonly Mod Mod;
        /// <summary>
        /// The maximum operation
        /// </summary>
        public static readonly Max Max;
        /// <summary>
        /// The minimum operation
        /// </summary>
        public static readonly Min Min;
        /// <summary>
        /// The floor operation
        /// </summary>
        public static readonly Floor Floor;
        /// <summary>
        /// The ceiling operation
        /// </summary>
        public static readonly Ceiling Ceiling;
        /// <summary>
        /// The round operation
        /// </summary>
        public static readonly Round Round;
        /// <summary>
        /// The absolute operation
        /// </summary>
        public static readonly Abs Abs;
        /// <summary>
        /// The square root operation
        /// </summary>
        public static readonly Sqrt Sqrt;
        /// <summary>
        /// The exponential operation
        /// </summary>
        public static readonly Exp Exp;
        /// <summary>
        /// The logarithmic operation
        /// </summary>
        public static readonly Log Log;
        /// <summary>
        /// The logarithmic-10 operation
        /// </summary>
        public static readonly Log10 Log10;
        /// <summary>
        /// The power operation
        /// </summary>
        public static readonly Pow Pow;
        /// <summary>
        /// The arc cosine operation
        /// </summary>
        public static readonly Acos Acos;
        /// <summary>
        /// The arc sine operation
        /// </summary>
        public static readonly Asin Asin;
        /// <summary>
        /// The arc tangent operation
        /// </summary>
        public static readonly Atan Atan;
        /// <summary>
        /// The cosine operation
        /// </summary>
        public static readonly Cos Cos;
        /// <summary>
        /// The sine operation
        /// </summary>
        public static readonly Sin Sin;
        /// <summary>
        /// The tangent operation
        /// </summary>
        public static readonly Tan Tan;
        /// <summary>
        /// The hyperbolic cosine operation
        /// </summary>
        public static readonly Cosh Cosh;
        /// <summary>
        /// The hyperbolic sine operation
        /// </summary>
        public static readonly Sinh Sihn;
        /// <summary>
        /// The hyperbolic tangent operation
        /// </summary>
        public static readonly Tanh Tanh;
    }
    #endregion

	#region Comparison operators
    /// <summary>
    /// The equal Equal implementation
    /// </summary>
    public struct Equal : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IEqual
    {
        /// <summary>
        /// Implementation of Equal test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a == b; }
		
        /// <summary>
        /// Applies the Equal operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, Equal>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThan implementation
    /// </summary>
    public struct GreaterThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThan
    {
        /// <summary>
        /// Implementation of GreaterThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a > b; }
		
        /// <summary>
        /// Applies the GreaterThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThan implementation
    /// </summary>
    public struct LessThan : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThan
    {
        /// <summary>
        /// Implementation of LessThan test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a < b; }
		
        /// <summary>
        /// Applies the LessThan operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThan>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal GreaterThanOrEqual implementation
    /// </summary>
    public struct GreaterThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IGreaterThanOrEqual
    {
        /// <summary>
        /// Implementation of GreaterThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a >= b; }
		
        /// <summary>
        /// Applies the GreaterThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, GreaterThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal LessThanOrEqual implementation
    /// </summary>
    public struct LessThanOrEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.ILessThanOrEqual
    {
        /// <summary>
        /// Implementation of LessThanOrEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a <= b; }
		
        /// <summary>
        /// Applies the LessThanOrEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, LessThanOrEqual>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal NotEqual implementation
    /// </summary>
    public struct NotEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.INotEqual
    {
        /// <summary>
        /// Implementation of NotEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a != b; }
		
        /// <summary>
        /// Applies the NotEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, NotEqual>(in1, in2, @out); }
    }

	#endregion

    #region Operator implementations
    /// <summary>
    /// The copy operator implementation
    /// </summary>
    public struct Copy
    {
        /// <summary>
        /// Applies the copy operation to the input operand
        /// </summary>
        /// <param name="in1">The input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise copy of the input view</returns>
        public static OutArray Apply(OutArray in1, OutArray @out = null)
        { return UFunc.Apply<T, NumCIL.CopyOp<T>>(in1, @out); }
    }

	#region Binary operation implementations
    /// <summary>
    /// The Add operator implementation
    /// </summary>
    public struct Add : IBinaryOp<T>, NumCIL.Generic.Operators.IAdd
    {
        /// <summary>
        /// Implementation of Add with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Add with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a + b); }
		
        /// <summary>
        /// Reduces the input array with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Add>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Add>(arg); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>(in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Add>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Sub operator implementation
    /// </summary>
    public struct Sub : IBinaryOp<T>, NumCIL.Generic.Operators.ISub
    {
        /// <summary>
        /// Implementation of Sub with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Sub with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a - b); }
		
        /// <summary>
        /// Reduces the input array with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Sub>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Sub>(arg); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>(in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Sub>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mul operator implementation
    /// </summary>
    public struct Mul : IBinaryOp<T>, NumCIL.Generic.Operators.IMul
    {
        /// <summary>
        /// Implementation of Mul with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mul with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a * b); }
		
        /// <summary>
        /// Reduces the input array with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mul>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mul>(arg); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mul>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Div operator implementation
    /// </summary>
    public struct Div : IBinaryOp<T>, NumCIL.Generic.Operators.IDiv
    {
        /// <summary>
        /// Implementation of Div with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Div with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a / b); }
		
        /// <summary>
        /// Reduces the input array with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Div>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Div>(arg); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>(in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Div>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mod operator implementation
    /// </summary>
    public struct Mod : IBinaryOp<T>, NumCIL.Generic.Operators.IMod
    {
        /// <summary>
        /// Implementation of Mod with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mod with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a % b); }
		
        /// <summary>
        /// Reduces the input array with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mod>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mod operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mod>(arg); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mod>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mod operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mod>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Min operator implementation
    /// </summary>
    public struct Min : IBinaryOp<T>, NumCIL.Generic.Operators.IMin
    {
        /// <summary>
        /// Implementation of Min with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Min with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Min(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Min>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Min operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Min>(arg); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>(in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Min>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Min operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Min>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Max operator implementation
    /// </summary>
    public struct Max : IBinaryOp<T>, NumCIL.Generic.Operators.IMax
    {
        /// <summary>
        /// Implementation of Max with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Max with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Max(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Max>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Max operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Max>(arg); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>(in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Max>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Max operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Max>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Pow operator implementation
    /// </summary>
    public struct Pow : IBinaryOp<T>, NumCIL.Generic.Operators.IPow
    {
        /// <summary>
        /// Implementation of Pow with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Pow with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)Math.Pow(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Pow>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Pow>(arg); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>(in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ 
			if (in2 == (T)2)
				return UFunc.Apply<T, Mul>(in1, in1, @out);
			else
				return UFunc.Apply<T, Pow>(in1, (OutArray)in2, @out);
		}
		
    }

	#endregion

	#region Unary operations implementation
    /// <summary>
    /// The Ceiling operation implementation
    /// </summary>
    public struct Ceiling : IUnaryOp<T>, NumCIL.Generic.Operators.ICeiling
    {
        /// <summary>
        /// Implementation of the Ceiling operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Ceiling to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Ceiling(a); }
		
        /// <summary>
        /// Applies the Ceiling operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Ceiling>(@in, @out); }

        /// <summary>
        /// Applies the Ceiling operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Ceiling>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Floor operation implementation
    /// </summary>
    public struct Floor : IUnaryOp<T>, NumCIL.Generic.Operators.IFloor
    {
        /// <summary>
        /// Implementation of the Floor operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Floor to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Floor(a); }
		
        /// <summary>
        /// Applies the Floor operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Floor>(@in, @out); }

        /// <summary>
        /// Applies the Floor operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Floor>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Round operation implementation
    /// </summary>
    public struct Round : IUnaryOp<T>, NumCIL.Generic.Operators.IRound
    {
        /// <summary>
        /// Implementation of the Round operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Round to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Round(a); }
		
        /// <summary>
        /// Applies the Round operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Round>(@in, @out); }

        /// <summary>
        /// Applies the Round operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Round>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sqrt operation implementation
    /// </summary>
    public struct Sqrt : IUnaryOp<T>, NumCIL.Generic.Operators.ISqrt
    {
        /// <summary>
        /// Implementation of the Sqrt operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sqrt to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sqrt(a); }
		
        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>(@in, @out); }

        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Exp operation implementation
    /// </summary>
    public struct Exp : IUnaryOp<T>, NumCIL.Generic.Operators.IExp
    {
        /// <summary>
        /// Implementation of the Exp operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Exp to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Exp(a); }
		
        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>(@in, @out); }

        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Abs operation implementation
    /// </summary>
    public struct Abs : IUnaryOp<T>, NumCIL.Generic.Operators.IAbs
    {
        /// <summary>
        /// Implementation of the Abs operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Abs to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Abs(a); }
		
        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>(@in, @out); }

        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sin operation implementation
    /// </summary>
    public struct Sin : IUnaryOp<T>, NumCIL.Generic.Operators.ISin
    {
        /// <summary>
        /// Implementation of the Sin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sin(a); }
		
        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>(@in, @out); }

        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cos operation implementation
    /// </summary>
    public struct Cos : IUnaryOp<T>, NumCIL.Generic.Operators.ICos
    {
        /// <summary>
        /// Implementation of the Cos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cos(a); }
		
        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>(@in, @out); }

        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tan operation implementation
    /// </summary>
    public struct Tan : IUnaryOp<T>, NumCIL.Generic.Operators.ITan
    {
        /// <summary>
        /// Implementation of the Tan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tan(a); }
		
        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>(@in, @out); }

        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Asin operation implementation
    /// </summary>
    public struct Asin : IUnaryOp<T>, NumCIL.Generic.Operators.IAsin
    {
        /// <summary>
        /// Implementation of the Asin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Asin to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Asin(a); }
		
        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>(@in, @out); }

        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Acos operation implementation
    /// </summary>
    public struct Acos : IUnaryOp<T>, NumCIL.Generic.Operators.IAcos
    {
        /// <summary>
        /// Implementation of the Acos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Acos to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Acos(a); }
		
        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>(@in, @out); }

        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Atan operation implementation
    /// </summary>
    public struct Atan : IUnaryOp<T>, NumCIL.Generic.Operators.IAtan
    {
        /// <summary>
        /// Implementation of the Atan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Atan to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Atan(a); }
		
        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>(@in, @out); }

        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sinh operation implementation
    /// </summary>
    public struct Sinh : IUnaryOp<T>, NumCIL.Generic.Operators.ISinh
    {
        /// <summary>
        /// Implementation of the Sinh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sinh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sinh(a); }
		
        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>(@in, @out); }

        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cosh operation implementation
    /// </summary>
    public struct Cosh : IUnaryOp<T>, NumCIL.Generic.Operators.ICosh
    {
        /// <summary>
        /// Implementation of the Cosh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cosh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Cosh(a); }
		
        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>(@in, @out); }

        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tanh operation implementation
    /// </summary>
    public struct Tanh : IUnaryOp<T>, NumCIL.Generic.Operators.ITanh
    {
        /// <summary>
        /// Implementation of the Tanh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tanh to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Tanh(a); }
		
        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>(@in, @out); }

        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log operation implementation
    /// </summary>
    public struct Log : IUnaryOp<T>, NumCIL.Generic.Operators.ILog
    {
        /// <summary>
        /// Implementation of the Log operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log(a); }
		
        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>(@in, @out); }

        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log10 operation implementation
    /// </summary>
    public struct Log10 : IUnaryOp<T>, NumCIL.Generic.Operators.ILog10
    {
        /// <summary>
        /// Implementation of the Log10 operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log10 to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Log10(a); }
		
        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>(@in, @out); }

        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sign operation implementation
    /// </summary>
    public struct Sign : IUnaryOp<T>, NumCIL.Generic.Operators.ISign
    {
        /// <summary>
        /// Implementation of the Sign operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sign to the operand</returns>
        public T Op(T a) 
		{ return (T)Math.Sign(a); }
		
        /// <summary>
        /// Applies the Sign operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sign>(@in, @out); }

        /// <summary>
        /// Applies the Sign operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sign>((OutArray)@in, @out); }
    }

	#endregion
	#endregion

    #region Generate mimics
    /// <summary>
    /// Generates basic initial arrays
    /// </summary>
    public static class Generate
    {
        /// <summary>
        /// The factory class that produces the NdArray instances
        /// </summary>
        public static NumCIL.Generic.IGenerator<T> Generator = new NumCIL.Generic.Generator<T, NumCIL.Generic.RandomGeneratorOpDouble, NumCIL.Generic.RangeGeneratorOp<T, NumCIL.Generic.NumberConverterDouble>, NumCIL.Generic.NumberConverterDouble>();

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(Shape shape) { return Generator.Range(shape); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(Shape shape) { return Generator.Ones(shape); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(Shape shape) { return Generator.Zeroes(shape); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with uninitialized data</returns>
        public static OutArray Empty(Shape shape) { return Generator.Empty(shape); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to fill the array with</param>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, Shape shape) { return Generator.Same(value, shape); }
        /// <summary>
        /// Creates an array filled with the value random numbers
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to random numbers</returns>
        public static OutArray Random(Shape shape) { return Generator.Random(shape); }

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(params long[] dimensions) { return Generator.Range(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(params long[] dimensions) { return Generator.Ones(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(params long[] dimensions) { return Generator.Zeroes(dimensions); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with uninitialized values</returns>
        public static OutArray Empty(params long[] dimensions) { return Generator.Empty(dimensions); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to set fill the array with</param>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, params long[] dimensions) { return Generator.Same(value, dimensions); }
        /// <summary>
        /// Creates an array filled with random values
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to a random value</returns>
        public static OutArray Random(params long[] dimensions) { return Generator.Random(dimensions); }
    }
    #endregion

	#region Conversion operator
	/// <summary>
    /// Operator for converting a number to another type
    /// </summary>
	public struct ToDouble :
        IUnaryConvOp<float, T>, 
        IUnaryConvOp<sbyte, T>, 
        IUnaryConvOp<byte,T>, 
        IUnaryConvOp<short, T>, 
        IUnaryConvOp<ushort, T>, 
        IUnaryConvOp<int, T>, 
        IUnaryConvOp<uint,T>, 
        IUnaryConvOp<long, T>, 
        IUnaryConvOp<ulong, T>,
		NumCIL.Generic.Operators.ITypeConversion
    {

        /// <summary>
        /// Converts the input from a <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(float a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(sbyte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(byte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ushort a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(short a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(uint a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(int a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ulong a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(long a) { return (T)a; }
    }
	#endregion
}

namespace NumCIL.Boolean
{
    using T = System.Boolean;
    using InArray = NumCIL.Generic.NdArray<System.Boolean>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray : IEnumerable<InArray>
    {
        #region NdArray Mimics
        /// <summary>
        /// The value instance that gives access to values
        /// </summary>
        public InArray.ValueAccessor Value { get { return value.Value; } }
        /// <summary>
        /// A reference to the shape instance that describes this view
        /// </summary>
        public Shape Shape { get { return value.Shape; } }
        /// <summary>
        /// A reference to the underlying data storage
        /// </summary>
        public T[] AsArray() { return value.AsArray(); }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="index">The element to get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params long[] index] { get { return this.value[index]; } set { this.value[index] = value; } }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="ranges">The range get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params Range[] ranges] { get { return this.value[ranges]; } set { this.value[ranges] = value; } }
        /// <summary>
        /// Returns a flattened (1-d copy) of the current data view
        /// </summary>
        /// <returns>A flattened copy</returns>
        public OutArray Flatten() { return this.value.Flatten(); }
        /// <summary>
        /// Returns a copy of the underlying data, shaped as this view
        /// </summary>
        /// <returns>A copy of the view data</returns>
        public OutArray Clone() { return this.value.Clone(); }
        /// <summary>
        /// Generates a new view based on this array
        /// </summary>
        /// <param name="newshape">The new shape</param>
        /// <returns>The reshaped array</returns>
        public OutArray Reshape(Shape newshape) { return this.value.Reshape(newshape); }
        /// <summary>
        /// Returns a view that is a view of a single element
        /// </summary>
        /// <param name="element">The element to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(long element) { return this.value.Subview(element); }
        /// <summary>
        /// Returns a view that is a view of a range of elements
        /// </summary>
        /// <param name="range">The range to view</param>
        /// <param name="dimension">The dimension to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(Range range, long dimension) { return this.value.Subview(range, dimension); }
        /// <summary>
        /// Returnes a sliced subview of the data, optionally collapsing single element dimensions
        /// </summary>
        /// <param name="ranges">The ranges to view for each dimension</param>
        /// <param name="collapse">True if single element dimensions should be collapsed, false to retain all dimensions</param>
        /// <returns>A new view of the data</returns>
        public OutArray Subview(Range[] ranges, bool collapse) { return this.value.Subview(ranges, collapse); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<InArray> GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// A debug tag used for naming a view
        /// </summary>
        public string Name { get { return this.value.Name; } set { this.value.Name = value; } }
        /// <summary>
        /// The data accessor providing the data storage
        /// </summary>
        public NumCIL.Generic.IDataAccessor<T> DataAccessor { get { return this.value.DataAccessor; } }

        /// <summary>
        /// Constructs a NdArray that is a scalar wrapper,
        /// allows simple scalar operations on arbitrary
        /// NdArrays
        /// </summary>
        /// <param name="value">The scalar value</param>
        public NdArray(T value)
            : this(new NumCIL.Generic.DefaultAccessor<T>(new T[] { value }))
        {
        }

        /// <summary>
        /// Constructs a new NdArray with the specified shape
        /// </summary>
        /// <param name="shape">The shape of the new NdArray</param>
        public NdArray(Shape shape)
            : this(Generate.Empty(shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(T[] data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(NumCIL.Generic.IDataAccessor<T> data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="source">An existing array that will be re-shaped</param>
        /// <param name="newshape">The shape to view the array in</param>
        public NdArray(InArray source, Shape newshape)
            : this(new InArray(source, newshape))
        {
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.value.ToString();
        }

        /// <summary>
        /// Flushes pending operations on the array
        /// </summary>
        public void Flush() { this.value.Flush(); }

        /// <summary>
        /// Returns a transposed view of this array. If <paramref name="out"/> is supplied, the contents are copied into that array.
        /// </summary>
        /// <param name="out">Optional output array</param>
        /// <returns>A transposed view</returns>
        public OutArray Transpose(OutArray @out = null) { return value.Transpose(@out); }

        /// <summary>
        /// Gets or sets data in a transposed view
        /// </summary>
        public OutArray Transposed { get { return value.Transposed; } set { value.Transposed = this.value; } }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform</param>
        /// <param name="axis">The axis to repeat, if not speficied, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform in each axis</param>
        /// <param name="axis">The axis to repeat, if not specified, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long[] repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Concatenates an array onto this array, joined at the axis
        /// </summary>
        /// <param name="arg">The array to join</param>
        /// <param name="axis">The axis to join at</param>
        /// <returns>The joined array</returns>
        public OutArray Concatenate(OutArray arg, long axis = 0) { return this.value.Concatenate(arg, axis); }

        /// <summary>
        /// Sets the values viewed to the values from another array, i.e. copies the values
        /// </summary>
        /// <param name="arg">The data to copy</param>
        public void Set(OutArray arg) { this.value.Set(arg); }
        #endregion

        /// <summary>
        /// The only data member of the struct is a reference to the underlying view
        /// </summary>
        private readonly InArray value;
        /// <summary>
        /// Constructs a new typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array</param>
        public NdArray(InArray v) { this.value = v; }

        #region Implict conversion operators
        /// <summary>
        /// Implicit operator that returns a typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array to wrap</param>
        /// <returns>A wrapped array</returns>
        public static implicit operator OutArray(InArray v) { return v == null ? null : new OutArray(v); }
        /// <summary>
        /// Implicit operator that returns a basic array from a wrapped one
        /// </summary>
        /// <param name="v">The wrapper array</param>
        /// <returns>The basic array</returns>
        public static implicit operator InArray(NdArray v) { return ((object)v) == null ? null : v.value; }
        /// <summary>
        /// Implicit operator that returns a wrapped array from a scalar value
        /// </summary>
        /// <param name="v">The scalar value</param>
        /// <returns>A wrapped array representing the scalar value</returns>
        public static implicit operator OutArray(T v) { return new OutArray(v); }
        #endregion



        #region F# support for missing implicit operators

        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(T a, OutArray b) { return UFunc.Apply<T, bool, Equal>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, T b) { return UFunc.Apply<T, bool, Equal>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(T a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, T b) { return UFunc.Apply<T, bool, NotEqual>(a, (OutArray)b, null); }

        #endregion

        #region Appliers for custom UFuncs
        /// <summary>
        /// Applies a unary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        public OutArray Apply(Func<T, T> op, OutArray @out = null) { return UFunc.Apply(op, this, @out); }
        /// <summary>
        /// Applies a binary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="b">An input operand</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        public OutArray Apply(Func<T, T, T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray @out = null) where C : struct, IUnaryOp<T> { return UFunc.Apply<T, C>(this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray b, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Apply<T, C>(this, b, @out); }
        /// <summary>
        /// Applies a nullary function to each element in this NdArray
        /// Note that Nullary functions are performed in-place
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <returns>This NdArray</returns>
        public OutArray Apply(INullaryOp<T> op) { UFunc.Apply<T>(op, this); return this; }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IUnaryOp<T> op, OutArray @out = null) { return UFunc.Apply<T>(op, this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IBinaryOp<T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }

        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <typeparam name="C">The function to apply reduction with</typeparam>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the reduction in-place</param>
        /// <returns>An NdArray that is the result of reducing the selected axis</returns>
        public OutArray Reduce<C>(long axis = 0, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Reduce<T, C>(this, axis, @out); }
        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <param name="op">The function to apply reduction with</param>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>A reduced array</returns>
        public OutArray Reduce(IBinaryOp<T> op, long axis = 0, OutArray @out = null) { return UFunc.Reduce<T>(op, this, axis, @out); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <typeparam name="C">The operation to perform</typeparam>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate<C>() where C : struct, IBinaryOp<T> { return UFunc.Aggregate<T, C>(this); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <param name="op">The operation to perform</param>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate(IBinaryOp<T> op) { return UFunc.Aggregate<T>(op, this); }

        #endregion


		#region Logical/Bitwise operator overloads
        /// <summary>
        /// Calculates the and of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of and-ing the two input operands</returns>
        public static OutArray operator &(OutArray a, OutArray b) { return UFunc.Apply<T, And>(a, b, null); }
        /// <summary>
        /// Calculates the or of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of or-ing the two input operands</returns>
        public static OutArray operator |(OutArray a, OutArray b) { return UFunc.Apply<T, Or>(a, b, null); }
        /// <summary>
        /// Calculates the xor of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of xor-ing the two input operands</returns>
        public static OutArray operator ^(OutArray a, OutArray b) { return UFunc.Apply<T, Xor>(a, b, null); }
        /// <summary>
        /// Calculates the logical negation of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The logical negation of the input operand</returns>
        public static OutArray operator !(OutArray a) { return UFunc.Apply<T, Not>(a, null); }
		#endregion

		#region Comparison operator overloads
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, OutArray b) { return UFunc.Apply<T, bool, Equal>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator ==(OutArray a, object b) { return ((object)a) == b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator !=(OutArray a, object b) { return ((object)a) != b; }
		#endregion

		#region System.Object overrides
		/// <summary>
		/// Compares this object to another
		/// </summary>
		/// <returns>A value indicating if the two elements are equal</returns>
		public override bool Equals(object o)
		{
			return this == o;
		}

		/// <summary>
		/// Returns a hashcode for comparing this object to others
		/// </summary>
		/// <returns>A hash code for this instance</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}
		#endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly CopyOp<T> Copy;
        /// <summary>
        /// The and operation
        /// </summary>
        public static readonly And And;
        /// <summary>
        /// The or operation
        /// </summary>
        public static readonly Or Or;
        /// <summary>
        /// The xor operation
        /// </summary>
        public static readonly Xor Xor;
       
        /// <summary>
        /// The invert operation
        /// </summary>
        public static readonly Not Not;

    }
    #endregion

	#region Comparison operators
    /// <summary>
    /// The equal Equal implementation
    /// </summary>
    public struct Equal : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IEqual
    {
        /// <summary>
        /// Implementation of Equal test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a == b; }
		
        /// <summary>
        /// Applies the Equal operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, Equal>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal NotEqual implementation
    /// </summary>
    public struct NotEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.INotEqual
    {
        /// <summary>
        /// Implementation of NotEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a != b; }
		
        /// <summary>
        /// Applies the NotEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, NotEqual>(in1, in2, @out); }
    }

	#endregion

    #region Operator implementations
    /// <summary>
    /// The copy operator implementation
    /// </summary>
    public struct Copy
    {
        /// <summary>
        /// Applies the copy operation to the input operand
        /// </summary>
        /// <param name="in1">The input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise copy of the input view</returns>
        public static OutArray Apply(OutArray in1, OutArray @out = null)
        { return UFunc.Apply<T, NumCIL.CopyOp<T>>(in1, @out); }
    }

	#region Binary operation implementations
    /// <summary>
    /// The And operator implementation
    /// </summary>
    public struct And : IBinaryOp<T>, NumCIL.Generic.Operators.IAnd
    {
        /// <summary>
        /// Implementation of And with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of And with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a & b); }
		
        /// <summary>
        /// Reduces the input array with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, And>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the And operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, And>(arg); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>(in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, And>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the And operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, And>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Or operator implementation
    /// </summary>
    public struct Or : IBinaryOp<T>, NumCIL.Generic.Operators.IOr
    {
        /// <summary>
        /// Implementation of Or with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Or with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a | b); }
		
        /// <summary>
        /// Reduces the input array with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Or>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Or operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Or>(arg); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>(in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Or>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Or operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Or>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Xor operator implementation
    /// </summary>
    public struct Xor : IBinaryOp<T>, NumCIL.Generic.Operators.IXor
    {
        /// <summary>
        /// Implementation of Xor with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Xor with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a ^ b); }
		
        /// <summary>
        /// Reduces the input array with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Xor>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Xor operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Xor>(arg); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>(in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Xor>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Xor operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Xor>(in1, (OutArray)in2, @out); }
    }

	#endregion

	#region Unary operations implementation
    /// <summary>
    /// The Not operation implementation
    /// </summary>
    public struct Not : IUnaryOp<T>, NumCIL.Generic.Operators.INot
    {
        /// <summary>
        /// Implementation of the Not operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Not to the operand</returns>
        public T Op(T a) 
		{ return (T)(!a); }
		
        /// <summary>
        /// Applies the Not operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Not>(@in, @out); }

        /// <summary>
        /// Applies the Not operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Not>((OutArray)@in, @out); }
    }

	#endregion
	#endregion

    #region Generate mimics
    /// <summary>
    /// Generates basic initial arrays
    /// </summary>
    public static class Generate
    {
        /// <summary>
        /// The factory class that produces the NdArray instances
        /// </summary>
        public static NumCIL.Generic.IGenerator<T> Generator = new NumCIL.Generic.Generator<T, NumCIL.Generic.RandomGeneratorOpBoolean, NumCIL.Generic.RangeGeneratorOp<T, NumCIL.Generic.NumberConverterBoolean>, NumCIL.Generic.NumberConverterBoolean>();

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(Shape shape) { return Generator.Range(shape); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(Shape shape) { return Generator.Ones(shape); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(Shape shape) { return Generator.Zeroes(shape); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with uninitialized data</returns>
        public static OutArray Empty(Shape shape) { return Generator.Empty(shape); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to fill the array with</param>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, Shape shape) { return Generator.Same(value, shape); }
        /// <summary>
        /// Creates an array filled with the value random numbers
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to random numbers</returns>
        public static OutArray Random(Shape shape) { return Generator.Random(shape); }

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(params long[] dimensions) { return Generator.Range(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(params long[] dimensions) { return Generator.Ones(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(params long[] dimensions) { return Generator.Zeroes(dimensions); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with uninitialized values</returns>
        public static OutArray Empty(params long[] dimensions) { return Generator.Empty(dimensions); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to set fill the array with</param>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, params long[] dimensions) { return Generator.Same(value, dimensions); }
        /// <summary>
        /// Creates an array filled with random values
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to a random value</returns>
        public static OutArray Random(params long[] dimensions) { return Generator.Random(dimensions); }
    }
    #endregion

}

namespace NumCIL.Complex128
{
    using T = System.Numerics.Complex;
    using InArray = NumCIL.Generic.NdArray<System.Numerics.Complex>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray : IEnumerable<InArray>
    {
        #region NdArray Mimics
        /// <summary>
        /// The value instance that gives access to values
        /// </summary>
        public InArray.ValueAccessor Value { get { return value.Value; } }
        /// <summary>
        /// A reference to the shape instance that describes this view
        /// </summary>
        public Shape Shape { get { return value.Shape; } }
        /// <summary>
        /// A reference to the underlying data storage
        /// </summary>
        public T[] AsArray() { return value.AsArray(); }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="index">The element to get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params long[] index] { get { return this.value[index]; } set { this.value[index] = value; } }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="ranges">The range get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params Range[] ranges] { get { return this.value[ranges]; } set { this.value[ranges] = value; } }
        /// <summary>
        /// Returns a flattened (1-d copy) of the current data view
        /// </summary>
        /// <returns>A flattened copy</returns>
        public OutArray Flatten() { return this.value.Flatten(); }
        /// <summary>
        /// Returns a copy of the underlying data, shaped as this view
        /// </summary>
        /// <returns>A copy of the view data</returns>
        public OutArray Clone() { return this.value.Clone(); }
        /// <summary>
        /// Generates a new view based on this array
        /// </summary>
        /// <param name="newshape">The new shape</param>
        /// <returns>The reshaped array</returns>
        public OutArray Reshape(Shape newshape) { return this.value.Reshape(newshape); }
        /// <summary>
        /// Returns a view that is a view of a single element
        /// </summary>
        /// <param name="element">The element to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(long element) { return this.value.Subview(element); }
        /// <summary>
        /// Returns a view that is a view of a range of elements
        /// </summary>
        /// <param name="range">The range to view</param>
        /// <param name="dimension">The dimension to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(Range range, long dimension) { return this.value.Subview(range, dimension); }
        /// <summary>
        /// Returnes a sliced subview of the data, optionally collapsing single element dimensions
        /// </summary>
        /// <param name="ranges">The ranges to view for each dimension</param>
        /// <param name="collapse">True if single element dimensions should be collapsed, false to retain all dimensions</param>
        /// <returns>A new view of the data</returns>
        public OutArray Subview(Range[] ranges, bool collapse) { return this.value.Subview(ranges, collapse); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<InArray> GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// A debug tag used for naming a view
        /// </summary>
        public string Name { get { return this.value.Name; } set { this.value.Name = value; } }
        /// <summary>
        /// The data accessor providing the data storage
        /// </summary>
        public NumCIL.Generic.IDataAccessor<T> DataAccessor { get { return this.value.DataAccessor; } }

        /// <summary>
        /// Constructs a NdArray that is a scalar wrapper,
        /// allows simple scalar operations on arbitrary
        /// NdArrays
        /// </summary>
        /// <param name="value">The scalar value</param>
        public NdArray(T value)
            : this(new NumCIL.Generic.DefaultAccessor<T>(new T[] { value }))
        {
        }

        /// <summary>
        /// Constructs a new NdArray with the specified shape
        /// </summary>
        /// <param name="shape">The shape of the new NdArray</param>
        public NdArray(Shape shape)
            : this(Generate.Empty(shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(T[] data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(NumCIL.Generic.IDataAccessor<T> data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="source">An existing array that will be re-shaped</param>
        /// <param name="newshape">The shape to view the array in</param>
        public NdArray(InArray source, Shape newshape)
            : this(new InArray(source, newshape))
        {
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.value.ToString();
        }

        /// <summary>
        /// Flushes pending operations on the array
        /// </summary>
        public void Flush() { this.value.Flush(); }

        /// <summary>
        /// Returns a transposed view of this array. If <paramref name="out"/> is supplied, the contents are copied into that array.
        /// </summary>
        /// <param name="out">Optional output array</param>
        /// <returns>A transposed view</returns>
        public OutArray Transpose(OutArray @out = null) { return value.Transpose(@out); }

        /// <summary>
        /// Gets or sets data in a transposed view
        /// </summary>
        public OutArray Transposed { get { return value.Transposed; } set { value.Transposed = this.value; } }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform</param>
        /// <param name="axis">The axis to repeat, if not speficied, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform in each axis</param>
        /// <param name="axis">The axis to repeat, if not specified, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long[] repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Concatenates an array onto this array, joined at the axis
        /// </summary>
        /// <param name="arg">The array to join</param>
        /// <param name="axis">The axis to join at</param>
        /// <returns>The joined array</returns>
        public OutArray Concatenate(OutArray arg, long axis = 0) { return this.value.Concatenate(arg, axis); }

        /// <summary>
        /// Sets the values viewed to the values from another array, i.e. copies the values
        /// </summary>
        /// <param name="arg">The data to copy</param>
        public void Set(OutArray arg) { this.value.Set(arg); }
        #endregion

        /// <summary>
        /// The only data member of the struct is a reference to the underlying view
        /// </summary>
        private readonly InArray value;
        /// <summary>
        /// Constructs a new typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array</param>
        public NdArray(InArray v) { this.value = v; }

        #region Implict conversion operators
        /// <summary>
        /// Implicit operator that returns a typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array to wrap</param>
        /// <returns>A wrapped array</returns>
        public static implicit operator OutArray(InArray v) { return v == null ? null : new OutArray(v); }
        /// <summary>
        /// Implicit operator that returns a basic array from a wrapped one
        /// </summary>
        /// <param name="v">The wrapper array</param>
        /// <returns>The basic array</returns>
        public static implicit operator InArray(NdArray v) { return ((object)v) == null ? null : v.value; }
        /// <summary>
        /// Implicit operator that returns a wrapped array from a scalar value
        /// </summary>
        /// <param name="v">The scalar value</param>
        /// <returns>A wrapped array representing the scalar value</returns>
        public static implicit operator OutArray(T v) { return new OutArray(v); }
        #endregion

        #region Operator implementations
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, OutArray b) { return UFunc.Apply<T, Add>(a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, OutArray b) { return UFunc.Apply<T, Sub>(a, b, null); }
        /// <summary>
        /// Calculates negation of the operand
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a) { return UFunc.Apply<T, Sub>(new OutArray((T)0), a, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, OutArray b) { return UFunc.Apply<T, Mul>(a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, OutArray b) { return UFunc.Apply<T, Div>(a, b, null); }

        /// <summary>
        /// Calculates the incremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of incrementing each value</returns>
        public static OutArray operator ++(OutArray a) { return UFunc.Apply<T, Add>(a, (OutArray)1, null); }
        /// <summary>
        /// Calculates the decremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of decrementing each value</returns>
        public static OutArray operator --(OutArray a) { return UFunc.Apply<T, Sub>(a, (OutArray)1, null); }
        #endregion

        #region Common function implementations
        /// <summary>
        /// Copies all values from this NdArray to the output NdArray
        /// </summary>
        /// <param name="out">Optional target for addition, if null, a new array is created</param>
        /// <returns>An NdArray which is a copy of this array</returns>
        public OutArray Copy(OutArray @out = null) { return UFunc.Apply<T, NumCIL.CopyOp<T>>(this, @out); }
        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, op, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the square root for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the square root of all values</returns>
        public OutArray Sqrt(OutArray @out = null) { return UFunc.Apply<T, Sqrt>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the exponent for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the exponent of all values</returns>
        public OutArray Exp(OutArray @out = null) { return UFunc.Apply<T, Exp>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the absolute value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all absolute values</returns>
        public OutArray Abs(OutArray @out = null) { return UFunc.Apply<T, Abs>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic of all values</returns>
        public OutArray Log(OutArray @out = null) { return UFunc.Apply<T, Log>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic-10 value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic-10 of all values</returns>
        public OutArray Log10(OutArray @out = null) { return UFunc.Apply<T, Log10>(this, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the mathcing element in the operand NdArray
        /// </summary>
        /// <param name="op">The power-of values</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the values in the operand NdArray</returns>
        public OutArray Pow(NdArray op, OutArray @out = null) { return UFunc.Apply<T, Pow>(this, op, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the scalar value
        /// </summary>
        /// <param name="value">The power-of value</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the scalar value</returns>
        public OutArray Pow(T value, OutArray @out = null)
        {
            if (value == 2)
                return UFunc.Apply<T, Mul>(this, this, @out);
            else
                return UFunc.Apply<T, Pow>(this, (OutArray)value, @out);
        }
        /// <summary>
        /// Performs matrix multiplication on the two elements
        /// </summary>
        /// <param name="arg">The right-hand-side argument in matrix multiplication</param>
        /// <param name="out">Optional target for the multiplication</param>
        /// <returns>The matrix multiplication result</returns>
        public OutArray MatrixMultiply(OutArray arg, OutArray @out = null) { return UFunc.Matmul<T, Add, Mul>(this, arg, @out); }
        #endregion


        #region F# support for missing implicit operators
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(T a, OutArray b) { return UFunc.Apply<T, Add>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, T b) { return UFunc.Apply<T, Add>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(T a, OutArray b) { return UFunc.Apply<T, Sub>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, T b) { return UFunc.Apply<T, Sub>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(T a, OutArray b) { return UFunc.Apply<T, Mul>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, T b) { return UFunc.Apply<T, Mul>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(T a, OutArray b) { return UFunc.Apply<T, Div>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, T b) { return UFunc.Apply<T, Div>(a, (OutArray)b, null); }

        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(T op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, (OutArray)op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(T op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, (OutArray)op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(T op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, (OutArray)op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(T op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, (OutArray)op, @out); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(T a, OutArray b) { return UFunc.Apply<T, bool, Equal>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, T b) { return UFunc.Apply<T, bool, Equal>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(T a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, T b) { return UFunc.Apply<T, bool, NotEqual>(a, (OutArray)b, null); }

        #endregion

        #region Appliers for custom UFuncs
        /// <summary>
        /// Applies a unary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        public OutArray Apply(Func<T, T> op, OutArray @out = null) { return UFunc.Apply(op, this, @out); }
        /// <summary>
        /// Applies a binary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="b">An input operand</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        public OutArray Apply(Func<T, T, T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray @out = null) where C : struct, IUnaryOp<T> { return UFunc.Apply<T, C>(this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray b, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Apply<T, C>(this, b, @out); }
        /// <summary>
        /// Applies a nullary function to each element in this NdArray
        /// Note that Nullary functions are performed in-place
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <returns>This NdArray</returns>
        public OutArray Apply(INullaryOp<T> op) { UFunc.Apply<T>(op, this); return this; }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IUnaryOp<T> op, OutArray @out = null) { return UFunc.Apply<T>(op, this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IBinaryOp<T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }

        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <typeparam name="C">The function to apply reduction with</typeparam>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the reduction in-place</param>
        /// <returns>An NdArray that is the result of reducing the selected axis</returns>
        public OutArray Reduce<C>(long axis = 0, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Reduce<T, C>(this, axis, @out); }
        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <param name="op">The function to apply reduction with</param>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>A reduced array</returns>
        public OutArray Reduce(IBinaryOp<T> op, long axis = 0, OutArray @out = null) { return UFunc.Reduce<T>(op, this, axis, @out); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <typeparam name="C">The operation to perform</typeparam>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate<C>() where C : struct, IBinaryOp<T> { return UFunc.Aggregate<T, C>(this); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <param name="op">The operation to perform</param>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate(IBinaryOp<T> op) { return UFunc.Aggregate<T>(op, this); }

        /// <summary>
        /// Calculates the sum of all elements
        /// </summary>
        /// <returns>A scalar value that is the sum of all elements</returns>
        public T Sum() { return UFunc.Aggregate<T, Add>(this); }
        #endregion



		#region Comparison operator overloads
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, OutArray b) { return UFunc.Apply<T, bool, Equal>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator ==(OutArray a, object b) { return ((object)a) == b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator !=(OutArray a, object b) { return ((object)a) != b; }
		#endregion

		#region System.Object overrides
		/// <summary>
		/// Compares this object to another
		/// </summary>
		/// <returns>A value indicating if the two elements are equal</returns>
		public override bool Equals(object o)
		{
			return this == o;
		}

		/// <summary>
		/// Returns a hashcode for comparing this object to others
		/// </summary>
		/// <returns>A hash code for this instance</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}
		#endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly CopyOp<T> Copy;
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly Add Add;
        /// <summary>
        /// The subtraction operation
        /// </summary>
        public static readonly Sub Sub;
        /// <summary>
        /// The multiplication operation
        /// </summary>
        public static readonly Mul Mul;
        /// <summary>
        /// The division operation
        /// </summary>
        public static readonly Div Div;
        /// <summary>
        /// The absolute operation
        /// </summary>
        public static readonly Abs Abs;
        /// <summary>
        /// The square root operation
        /// </summary>
        public static readonly Sqrt Sqrt;
        /// <summary>
        /// The exponential operation
        /// </summary>
        public static readonly Exp Exp;
        /// <summary>
        /// The logarithmic operation
        /// </summary>
        public static readonly Log Log;
        /// <summary>
        /// The logarithmic-10 operation
        /// </summary>
        public static readonly Log10 Log10;
        /// <summary>
        /// The power operation
        /// </summary>
        public static readonly Pow Pow;
        /// <summary>
        /// The arc cosine operation
        /// </summary>
        public static readonly Acos Acos;
        /// <summary>
        /// The arc sine operation
        /// </summary>
        public static readonly Asin Asin;
        /// <summary>
        /// The arc tangent operation
        /// </summary>
        public static readonly Atan Atan;
        /// <summary>
        /// The cosine operation
        /// </summary>
        public static readonly Cos Cos;
        /// <summary>
        /// The sine operation
        /// </summary>
        public static readonly Sin Sin;
        /// <summary>
        /// The tangent operation
        /// </summary>
        public static readonly Tan Tan;
        /// <summary>
        /// The hyperbolic cosine operation
        /// </summary>
        public static readonly Cosh Cosh;
        /// <summary>
        /// The hyperbolic sine operation
        /// </summary>
        public static readonly Sinh Sihn;
        /// <summary>
        /// The hyperbolic tangent operation
        /// </summary>
        public static readonly Tanh Tanh;
    }
    #endregion

	#region Comparison operators
    /// <summary>
    /// The equal Equal implementation
    /// </summary>
    public struct Equal : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IEqual
    {
        /// <summary>
        /// Implementation of Equal test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a == b; }
		
        /// <summary>
        /// Applies the Equal operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, Equal>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal NotEqual implementation
    /// </summary>
    public struct NotEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.INotEqual
    {
        /// <summary>
        /// Implementation of NotEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a != b; }
		
        /// <summary>
        /// Applies the NotEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, NotEqual>(in1, in2, @out); }
    }

	#endregion

    #region Operator implementations
    /// <summary>
    /// The copy operator implementation
    /// </summary>
    public struct Copy
    {
        /// <summary>
        /// Applies the copy operation to the input operand
        /// </summary>
        /// <param name="in1">The input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise copy of the input view</returns>
        public static OutArray Apply(OutArray in1, OutArray @out = null)
        { return UFunc.Apply<T, NumCIL.CopyOp<T>>(in1, @out); }
    }

	#region Binary operation implementations
    /// <summary>
    /// The Add operator implementation
    /// </summary>
    public struct Add : IBinaryOp<T>, NumCIL.Generic.Operators.IAdd
    {
        /// <summary>
        /// Implementation of Add with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Add with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a + b); }
		
        /// <summary>
        /// Reduces the input array with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Add>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Add>(arg); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>(in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Add>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Sub operator implementation
    /// </summary>
    public struct Sub : IBinaryOp<T>, NumCIL.Generic.Operators.ISub
    {
        /// <summary>
        /// Implementation of Sub with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Sub with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a - b); }
		
        /// <summary>
        /// Reduces the input array with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Sub>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Sub>(arg); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>(in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Sub>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mul operator implementation
    /// </summary>
    public struct Mul : IBinaryOp<T>, NumCIL.Generic.Operators.IMul
    {
        /// <summary>
        /// Implementation of Mul with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mul with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a * b); }
		
        /// <summary>
        /// Reduces the input array with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mul>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mul>(arg); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mul>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Div operator implementation
    /// </summary>
    public struct Div : IBinaryOp<T>, NumCIL.Generic.Operators.IDiv
    {
        /// <summary>
        /// Implementation of Div with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Div with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a / b); }
		
        /// <summary>
        /// Reduces the input array with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Div>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Div>(arg); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>(in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Div>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Pow operator implementation
    /// </summary>
    public struct Pow : IBinaryOp<T>, NumCIL.Generic.Operators.IPow
    {
        /// <summary>
        /// Implementation of Pow with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Pow with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)T.Pow(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Pow>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Pow>(arg); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>(in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ 
			if (in2 == (T)2)
				return UFunc.Apply<T, Mul>(in1, in1, @out);
			else
				return UFunc.Apply<T, Pow>(in1, (OutArray)in2, @out);
		}
		
    }

	#endregion

	#region Unary operations implementation
    /// <summary>
    /// The Sqrt operation implementation
    /// </summary>
    public struct Sqrt : IUnaryOp<T>, NumCIL.Generic.Operators.ISqrt
    {
        /// <summary>
        /// Implementation of the Sqrt operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sqrt to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Sqrt(a); }
		
        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>(@in, @out); }

        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Exp operation implementation
    /// </summary>
    public struct Exp : IUnaryOp<T>, NumCIL.Generic.Operators.IExp
    {
        /// <summary>
        /// Implementation of the Exp operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Exp to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Exp(a); }
		
        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>(@in, @out); }

        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Abs operation implementation
    /// </summary>
    public struct Abs : IUnaryOp<T>, NumCIL.Generic.Operators.IAbs
    {
        /// <summary>
        /// Implementation of the Abs operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Abs to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Abs(a); }
		
        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>(@in, @out); }

        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sin operation implementation
    /// </summary>
    public struct Sin : IUnaryOp<T>, NumCIL.Generic.Operators.ISin
    {
        /// <summary>
        /// Implementation of the Sin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sin to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Sin(a); }
		
        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>(@in, @out); }

        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cos operation implementation
    /// </summary>
    public struct Cos : IUnaryOp<T>, NumCIL.Generic.Operators.ICos
    {
        /// <summary>
        /// Implementation of the Cos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cos to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Cos(a); }
		
        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>(@in, @out); }

        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tan operation implementation
    /// </summary>
    public struct Tan : IUnaryOp<T>, NumCIL.Generic.Operators.ITan
    {
        /// <summary>
        /// Implementation of the Tan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tan to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Tan(a); }
		
        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>(@in, @out); }

        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Asin operation implementation
    /// </summary>
    public struct Asin : IUnaryOp<T>, NumCIL.Generic.Operators.IAsin
    {
        /// <summary>
        /// Implementation of the Asin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Asin to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Asin(a); }
		
        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>(@in, @out); }

        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Acos operation implementation
    /// </summary>
    public struct Acos : IUnaryOp<T>, NumCIL.Generic.Operators.IAcos
    {
        /// <summary>
        /// Implementation of the Acos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Acos to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Acos(a); }
		
        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>(@in, @out); }

        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Atan operation implementation
    /// </summary>
    public struct Atan : IUnaryOp<T>, NumCIL.Generic.Operators.IAtan
    {
        /// <summary>
        /// Implementation of the Atan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Atan to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Atan(a); }
		
        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>(@in, @out); }

        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sinh operation implementation
    /// </summary>
    public struct Sinh : IUnaryOp<T>, NumCIL.Generic.Operators.ISinh
    {
        /// <summary>
        /// Implementation of the Sinh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sinh to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Sinh(a); }
		
        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>(@in, @out); }

        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cosh operation implementation
    /// </summary>
    public struct Cosh : IUnaryOp<T>, NumCIL.Generic.Operators.ICosh
    {
        /// <summary>
        /// Implementation of the Cosh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cosh to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Cosh(a); }
		
        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>(@in, @out); }

        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tanh operation implementation
    /// </summary>
    public struct Tanh : IUnaryOp<T>, NumCIL.Generic.Operators.ITanh
    {
        /// <summary>
        /// Implementation of the Tanh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tanh to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Tanh(a); }
		
        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>(@in, @out); }

        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log operation implementation
    /// </summary>
    public struct Log : IUnaryOp<T>, NumCIL.Generic.Operators.ILog
    {
        /// <summary>
        /// Implementation of the Log operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Log(a); }
		
        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>(@in, @out); }

        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log10 operation implementation
    /// </summary>
    public struct Log10 : IUnaryOp<T>, NumCIL.Generic.Operators.ILog10
    {
        /// <summary>
        /// Implementation of the Log10 operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log10 to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Log10(a); }
		
        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>(@in, @out); }

        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>((OutArray)@in, @out); }
    }

	#endregion
	#endregion

    #region Generate mimics
    /// <summary>
    /// Generates basic initial arrays
    /// </summary>
    public static class Generate
    {
        /// <summary>
        /// The factory class that produces the NdArray instances
        /// </summary>
        public static NumCIL.Generic.IGenerator<T> Generator = new NumCIL.Generic.Generator<T, NumCIL.Generic.RandomGeneratorOpComplex128, NumCIL.Generic.RangeGeneratorOp<T, NumCIL.Generic.NumberConverterComplex128>, NumCIL.Generic.NumberConverterComplex128>();

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(Shape shape) { return Generator.Range(shape); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(Shape shape) { return Generator.Ones(shape); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(Shape shape) { return Generator.Zeroes(shape); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with uninitialized data</returns>
        public static OutArray Empty(Shape shape) { return Generator.Empty(shape); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to fill the array with</param>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, Shape shape) { return Generator.Same(value, shape); }
        /// <summary>
        /// Creates an array filled with the value random numbers
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to random numbers</returns>
        public static OutArray Random(Shape shape) { return Generator.Random(shape); }

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(params long[] dimensions) { return Generator.Range(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(params long[] dimensions) { return Generator.Ones(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(params long[] dimensions) { return Generator.Zeroes(dimensions); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with uninitialized values</returns>
        public static OutArray Empty(params long[] dimensions) { return Generator.Empty(dimensions); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to set fill the array with</param>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, params long[] dimensions) { return Generator.Same(value, dimensions); }
        /// <summary>
        /// Creates an array filled with random values
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to a random value</returns>
        public static OutArray Random(params long[] dimensions) { return Generator.Random(dimensions); }
    }
    #endregion

}

namespace NumCIL.Complex64
{
    using T = NumCIL.Complex64.DataType;
    using InArray = NumCIL.Generic.NdArray<NumCIL.Complex64.DataType>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray : IEnumerable<InArray>
    {
        #region NdArray Mimics
        /// <summary>
        /// The value instance that gives access to values
        /// </summary>
        public InArray.ValueAccessor Value { get { return value.Value; } }
        /// <summary>
        /// A reference to the shape instance that describes this view
        /// </summary>
        public Shape Shape { get { return value.Shape; } }
        /// <summary>
        /// A reference to the underlying data storage
        /// </summary>
        public T[] AsArray() { return value.AsArray(); }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="index">The element to get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params long[] index] { get { return this.value[index]; } set { this.value[index] = value; } }
        /// <summary>
        /// Gets a subview on the array
        /// </summary>
        /// <param name="ranges">The range get the view from</param>
        /// <returns>A view on the selected element</returns>
        public OutArray this[params Range[] ranges] { get { return this.value[ranges]; } set { this.value[ranges] = value; } }
        /// <summary>
        /// Returns a flattened (1-d copy) of the current data view
        /// </summary>
        /// <returns>A flattened copy</returns>
        public OutArray Flatten() { return this.value.Flatten(); }
        /// <summary>
        /// Returns a copy of the underlying data, shaped as this view
        /// </summary>
        /// <returns>A copy of the view data</returns>
        public OutArray Clone() { return this.value.Clone(); }
        /// <summary>
        /// Generates a new view based on this array
        /// </summary>
        /// <param name="newshape">The new shape</param>
        /// <returns>The reshaped array</returns>
        public OutArray Reshape(Shape newshape) { return this.value.Reshape(newshape); }
        /// <summary>
        /// Returns a view that is a view of a single element
        /// </summary>
        /// <param name="element">The element to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(long element) { return this.value.Subview(element); }
        /// <summary>
        /// Returns a view that is a view of a range of elements
        /// </summary>
        /// <param name="range">The range to view</param>
        /// <param name="dimension">The dimension to view</param>
        /// <returns>The subview</returns>
        public OutArray Subview(Range range, long dimension) { return this.value.Subview(range, dimension); }
        /// <summary>
        /// Returnes a sliced subview of the data, optionally collapsing single element dimensions
        /// </summary>
        /// <param name="ranges">The ranges to view for each dimension</param>
        /// <param name="collapse">True if single element dimensions should be collapsed, false to retain all dimensions</param>
        /// <returns>A new view of the data</returns>
        public OutArray Subview(Range[] ranges, bool collapse) { return this.value.Subview(ranges, collapse); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.Generic.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<InArray> GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// Returns an enumerator that iterates through a collection.
        /// </summary>
        /// <returns>
        /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
        /// </returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.value.GetEnumerator(); }
        /// <summary>
        /// A debug tag used for naming a view
        /// </summary>
        public string Name { get { return this.value.Name; } set { this.value.Name = value; } }
        /// <summary>
        /// The data accessor providing the data storage
        /// </summary>
        public NumCIL.Generic.IDataAccessor<T> DataAccessor { get { return this.value.DataAccessor; } }

        /// <summary>
        /// Constructs a NdArray that is a scalar wrapper,
        /// allows simple scalar operations on arbitrary
        /// NdArrays
        /// </summary>
        /// <param name="value">The scalar value</param>
        public NdArray(T value)
            : this(new NumCIL.Generic.DefaultAccessor<T>(new T[] { value }))
        {
        }

        /// <summary>
        /// Constructs a new NdArray with the specified shape
        /// </summary>
        /// <param name="shape">The shape of the new NdArray</param>
        public NdArray(Shape shape)
            : this(Generate.Empty(shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(T[] data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="data">The data to wrap in a NdArray</param>
        /// <param name="shape">The shape to view the array in</param>
        public NdArray(NumCIL.Generic.IDataAccessor<T> data, Shape shape = null)
            : this(new InArray(data, shape))
        {
        }

        /// <summary>
        /// Constructs a new NdArray over a pre-allocated array and shapes it
        /// </summary>
        /// <param name="source">An existing array that will be re-shaped</param>
        /// <param name="newshape">The shape to view the array in</param>
        public NdArray(InArray source, Shape newshape)
            : this(new InArray(source, newshape))
        {
        }

        /// <summary>
        /// Returns a <see cref="System.String"/> that represents this instance.
        /// </summary>
        /// <returns>
        /// A <see cref="System.String"/> that represents this instance.
        /// </returns>
        public override string ToString()
        {
            return this.value.ToString();
        }

        /// <summary>
        /// Flushes pending operations on the array
        /// </summary>
        public void Flush() { this.value.Flush(); }

        /// <summary>
        /// Returns a transposed view of this array. If <paramref name="out"/> is supplied, the contents are copied into that array.
        /// </summary>
        /// <param name="out">Optional output array</param>
        /// <returns>A transposed view</returns>
        public OutArray Transpose(OutArray @out = null) { return value.Transpose(@out); }

        /// <summary>
        /// Gets or sets data in a transposed view
        /// </summary>
        public OutArray Transposed { get { return value.Transposed; } set { value.Transposed = this.value; } }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform</param>
        /// <param name="axis">The axis to repeat, if not speficied, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Repeats elements of the array
        /// </summary>
        /// <param name="repeats">The number of repeats to perform in each axis</param>
        /// <param name="axis">The axis to repeat, if not specified, repeat is done on a flattened array</param>
        /// <returns>A repeated copy of the input data</returns>
        public OutArray Repeat(long[] repeats, long? axis = null) { return value.Repeat(repeats, axis); }

        /// <summary>
        /// Concatenates an array onto this array, joined at the axis
        /// </summary>
        /// <param name="arg">The array to join</param>
        /// <param name="axis">The axis to join at</param>
        /// <returns>The joined array</returns>
        public OutArray Concatenate(OutArray arg, long axis = 0) { return this.value.Concatenate(arg, axis); }

        /// <summary>
        /// Sets the values viewed to the values from another array, i.e. copies the values
        /// </summary>
        /// <param name="arg">The data to copy</param>
        public void Set(OutArray arg) { this.value.Set(arg); }
        #endregion

        /// <summary>
        /// The only data member of the struct is a reference to the underlying view
        /// </summary>
        private readonly InArray value;
        /// <summary>
        /// Constructs a new typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array</param>
        public NdArray(InArray v) { this.value = v; }

        #region Implict conversion operators
        /// <summary>
        /// Implicit operator that returns a typed array from a basic one
        /// </summary>
        /// <param name="v">The basic array to wrap</param>
        /// <returns>A wrapped array</returns>
        public static implicit operator OutArray(InArray v) { return v == null ? null : new OutArray(v); }
        /// <summary>
        /// Implicit operator that returns a basic array from a wrapped one
        /// </summary>
        /// <param name="v">The wrapper array</param>
        /// <returns>The basic array</returns>
        public static implicit operator InArray(NdArray v) { return ((object)v) == null ? null : v.value; }
        /// <summary>
        /// Implicit operator that returns a wrapped array from a scalar value
        /// </summary>
        /// <param name="v">The scalar value</param>
        /// <returns>A wrapped array representing the scalar value</returns>
        public static implicit operator OutArray(T v) { return new OutArray(v); }
        #endregion

        #region Operator implementations
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, OutArray b) { return UFunc.Apply<T, Add>(a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, OutArray b) { return UFunc.Apply<T, Sub>(a, b, null); }
        /// <summary>
        /// Calculates negation of the operand
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a) { return UFunc.Apply<T, Sub>(new OutArray((T)0), a, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, OutArray b) { return UFunc.Apply<T, Mul>(a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, OutArray b) { return UFunc.Apply<T, Div>(a, b, null); }

        /// <summary>
        /// Calculates the incremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of incrementing each value</returns>
        public static OutArray operator ++(OutArray a) { return UFunc.Apply<T, Add>(a, (OutArray)1, null); }
        /// <summary>
        /// Calculates the decremented value of the operand
        /// </summary>
        /// <param name="a">An input operand</param>
        /// <returns>The result of decrementing each value</returns>
        public static OutArray operator --(OutArray a) { return UFunc.Apply<T, Sub>(a, (OutArray)1, null); }
        #endregion

        #region Common function implementations
        /// <summary>
        /// Copies all values from this NdArray to the output NdArray
        /// </summary>
        /// <param name="out">Optional target for addition, if null, a new array is created</param>
        /// <returns>An NdArray which is a copy of this array</returns>
        public OutArray Copy(OutArray @out = null) { return UFunc.Apply<T, NumCIL.CopyOp<T>>(this, @out); }
        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(OutArray op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, op, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the square root for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the square root of all values</returns>
        public OutArray Sqrt(OutArray @out = null) { return UFunc.Apply<T, Sqrt>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the exponent for all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the exponent of all values</returns>
        public OutArray Exp(OutArray @out = null) { return UFunc.Apply<T, Exp>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the absolute value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all absolute values</returns>
        public OutArray Abs(OutArray @out = null) { return UFunc.Apply<T, Abs>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic of all values</returns>
        public OutArray Log(OutArray @out = null) { return UFunc.Apply<T, Log>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that is the result of calculating the logarithmic-10 value of all the elements in this NdArray
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with the logarithmic-10 of all values</returns>
        public OutArray Log10(OutArray @out = null) { return UFunc.Apply<T, Log10>(this, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the mathcing element in the operand NdArray
        /// </summary>
        /// <param name="op">The power-of values</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the values in the operand NdArray</returns>
        public OutArray Pow(NdArray op, OutArray @out = null) { return UFunc.Apply<T, Pow>(this, op, @out); }
        /// <summary>
        /// Calculates each element in this NdArray as being raised to the power of the scalar value
        /// </summary>
        /// <param name="value">The power-of value</param>
        /// <param name="out">Optional target for the pow operation, use to perform in-place power-of calculation</param>
        /// <returns>An NdArray which is the values of this NdArray raised to the power of the scalar value</returns>
        public OutArray Pow(T value, OutArray @out = null)
        {
            if (value == 2)
                return UFunc.Apply<T, Mul>(this, this, @out);
            else
                return UFunc.Apply<T, Pow>(this, (OutArray)value, @out);
        }
        /// <summary>
        /// Performs matrix multiplication on the two elements
        /// </summary>
        /// <param name="arg">The right-hand-side argument in matrix multiplication</param>
        /// <param name="out">Optional target for the multiplication</param>
        /// <returns>The matrix multiplication result</returns>
        public OutArray MatrixMultiply(OutArray arg, OutArray @out = null) { return UFunc.Matmul<T, Add, Mul>(this, arg, @out); }
        #endregion


        #region F# support for missing implicit operators
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(T a, OutArray b) { return UFunc.Apply<T, Add>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates addition to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of adding the two input operands</returns>
        public static OutArray operator +(OutArray a, T b) { return UFunc.Apply<T, Add>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(T a, OutArray b) { return UFunc.Apply<T, Sub>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates subtraction of the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of subtracting the two input operands</returns>
        public static OutArray operator -(OutArray a, T b) { return UFunc.Apply<T, Sub>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(T a, OutArray b) { return UFunc.Apply<T, Mul>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates multiplication to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of multiplying the two input operands</returns>
        public static OutArray operator *(OutArray a, T b) { return UFunc.Apply<T, Mul>(a, (OutArray)b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(T a, OutArray b) { return UFunc.Apply<T, Div>((OutArray)a, b, null); }
        /// <summary>
        /// Calculates division of to the two operands
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of dividing the two input operands</returns>
        public static OutArray operator /(OutArray a, T b) { return UFunc.Apply<T, Div>(a, (OutArray)b, null); }

        /// <summary>
        /// Adds the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to add</param>
        /// <param name="out">Optional target for addition, use to perform in-place addition</param>
        /// <returns>An NdArray which is the result of adding the two NdArrays</returns>
        public OutArray Add(T op, OutArray @out = null) { return UFunc.Apply<T, Add>(this, (OutArray)op, @out); }
        /// <summary>
        /// Subtracts the values of an NdArray from this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to subtract</param>
        /// <param name="out">Optional target for addition, use to perform in-place subtraction</param>
        /// <returns>An NdArray which is the result of subtracting the two NdArrays</returns>
        public OutArray Sub(T op, OutArray @out = null) { return UFunc.Apply<T, Sub>(this, (OutArray)op, @out); }
        /// <summary>
        /// Multiplies the values of an NdArray to this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to multiply with</param>
        /// <param name="out">Optional target for multiplication, use to perform in-place multiplication</param>
        /// <returns>An NdArray which is the result of multiplying the two NdArrays</returns>
        public OutArray Mul(T op, OutArray @out = null) { return UFunc.Apply<T, Mul>(this, (OutArray)op, @out); }
        /// <summary>
        /// Divides the values of an NdArray with this NdArray and returns the result as a new NdArray
        /// </summary>
        /// <param name="op">The operand to divide with</param>
        /// <param name="out">Optional target for division, use to perform in-place division</param>
        /// <returns>An NdArray which is the result of dividing the two NdArrays</returns>
        public OutArray Div(T op, OutArray @out = null) { return UFunc.Apply<T, Div>(this, (OutArray)op, @out); }

        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(T a, OutArray b) { return UFunc.Apply<T, bool, Equal>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, T b) { return UFunc.Apply<T, bool, Equal>(a, (OutArray)b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(T a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>((OutArray)a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, T b) { return UFunc.Apply<T, bool, NotEqual>(a, (OutArray)b, null); }

        #endregion

        #region Appliers for custom UFuncs
        /// <summary>
        /// Applies a unary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        public OutArray Apply(Func<T, T> op, OutArray @out = null) { return UFunc.Apply(op, this, @out); }
        /// <summary>
        /// Applies a binary lambda function to each element in this NdArray
        /// </summary>
        /// <param name="op">The lamda function to apply</param>
        /// <param name="b">An input operand</param>
        /// <returns>An NdArray that is the result of applying the lambda function to each element</returns>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        public OutArray Apply(Func<T, T, T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray @out = null) where C : struct, IUnaryOp<T> { return UFunc.Apply<T, C>(this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <typeparam name="C">The function to apply</typeparam>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply<C>(OutArray b, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Apply<T, C>(this, b, @out); }
        /// <summary>
        /// Applies a nullary function to each element in this NdArray
        /// Note that Nullary functions are performed in-place
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <returns>This NdArray</returns>
        public OutArray Apply(INullaryOp<T> op) { UFunc.Apply<T>(op, this); return this; }
        /// <summary>
        /// Applies a unary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IUnaryOp<T> op, OutArray @out = null) { return UFunc.Apply<T>(op, this, @out); }
        /// <summary>
        /// Applies a binary function to each element in this NdArray
        /// </summary>
        /// <param name="op">The function to apply</param>
        /// <param name="b">An input operand</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>An NdArray that is the result of applying the function to each element</returns>
        public OutArray Apply(IBinaryOp<T> op, OutArray b, OutArray @out = null) { return UFunc.Apply<T>(op, this, b, @out); }

        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <typeparam name="C">The function to apply reduction with</typeparam>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the reduction in-place</param>
        /// <returns>An NdArray that is the result of reducing the selected axis</returns>
        public OutArray Reduce<C>(long axis = 0, OutArray @out = null) where C : struct, IBinaryOp<T> { return UFunc.Reduce<T, C>(this, axis, @out); }
        /// <summary>
        /// Performs a reduction operation on this array
        /// </summary>
        /// <param name="op">The function to apply reduction with</param>
        /// <param name="axis">The axis to remove</param>
        /// <param name="out">An optional output array, use this to perform the function in-place</param>
        /// <returns>A reduced array</returns>
        public OutArray Reduce(IBinaryOp<T> op, long axis = 0, OutArray @out = null) { return UFunc.Reduce<T>(op, this, axis, @out); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <typeparam name="C">The operation to perform</typeparam>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate<C>() where C : struct, IBinaryOp<T> { return UFunc.Aggregate<T, C>(this); }

        /// <summary>
        /// Calculates the scalar result of applying the binary operation to all elements
        /// </summary>
        /// <param name="op">The operation to perform</param>
        /// <returns>A scalar value that is the result of aggregating all elements</returns>
        public T Aggregate(IBinaryOp<T> op) { return UFunc.Aggregate<T>(op, this); }

        /// <summary>
        /// Calculates the sum of all elements
        /// </summary>
        /// <returns>A scalar value that is the sum of all elements</returns>
        public T Sum() { return UFunc.Aggregate<T, Add>(this); }
        #endregion



		#region Comparison operator overloads
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator ==(OutArray a, OutArray b) { return UFunc.Apply<T, bool, Equal>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator ==(OutArray a, object b) { return ((object)a) == b; }
        /// <summary>
        /// Compares the operands and returns a value indicating if a is not equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static NumCIL.Boolean.NdArray operator !=(OutArray a, OutArray b) { return UFunc.Apply<T, bool, NotEqual>(a, b, null); }
        /// <summary>
        /// Compares the operands and returns a value indicating if a equal to b
        /// </summary>
        /// <param name="a">One input operand</param>
        /// <param name="b">Another input operand</param>
        /// <returns>The result of comparing the two input operands</returns>
        public static bool operator !=(OutArray a, object b) { return ((object)a) != b; }
		#endregion

		#region System.Object overrides
		/// <summary>
		/// Compares this object to another
		/// </summary>
		/// <returns>A value indicating if the two elements are equal</returns>
		public override bool Equals(object o)
		{
			return this == o;
		}

		/// <summary>
		/// Returns a hashcode for comparing this object to others
		/// </summary>
		/// <returns>A hash code for this instance</returns>
		public override int GetHashCode()
		{
			return value.GetHashCode();
		}
		#endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly CopyOp<T> Copy;
        /// <summary>
        /// The addition operation
        /// </summary>
        public static readonly Add Add;
        /// <summary>
        /// The subtraction operation
        /// </summary>
        public static readonly Sub Sub;
        /// <summary>
        /// The multiplication operation
        /// </summary>
        public static readonly Mul Mul;
        /// <summary>
        /// The division operation
        /// </summary>
        public static readonly Div Div;
        /// <summary>
        /// The absolute operation
        /// </summary>
        public static readonly Abs Abs;
        /// <summary>
        /// The square root operation
        /// </summary>
        public static readonly Sqrt Sqrt;
        /// <summary>
        /// The exponential operation
        /// </summary>
        public static readonly Exp Exp;
        /// <summary>
        /// The logarithmic operation
        /// </summary>
        public static readonly Log Log;
        /// <summary>
        /// The logarithmic-10 operation
        /// </summary>
        public static readonly Log10 Log10;
        /// <summary>
        /// The power operation
        /// </summary>
        public static readonly Pow Pow;
        /// <summary>
        /// The arc cosine operation
        /// </summary>
        public static readonly Acos Acos;
        /// <summary>
        /// The arc sine operation
        /// </summary>
        public static readonly Asin Asin;
        /// <summary>
        /// The arc tangent operation
        /// </summary>
        public static readonly Atan Atan;
        /// <summary>
        /// The cosine operation
        /// </summary>
        public static readonly Cos Cos;
        /// <summary>
        /// The sine operation
        /// </summary>
        public static readonly Sin Sin;
        /// <summary>
        /// The tangent operation
        /// </summary>
        public static readonly Tan Tan;
        /// <summary>
        /// The hyperbolic cosine operation
        /// </summary>
        public static readonly Cosh Cosh;
        /// <summary>
        /// The hyperbolic sine operation
        /// </summary>
        public static readonly Sinh Sihn;
        /// <summary>
        /// The hyperbolic tangent operation
        /// </summary>
        public static readonly Tanh Tanh;
    }
    #endregion

	#region Comparison operators
    /// <summary>
    /// The equal Equal implementation
    /// </summary>
    public struct Equal : IBinaryCompareOp<T>, NumCIL.Generic.Operators.IEqual
    {
        /// <summary>
        /// Implementation of Equal test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a == b; }
		
        /// <summary>
        /// Applies the Equal operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, Equal>(in1, in2, @out); }
    }

    /// <summary>
    /// The equal NotEqual implementation
    /// </summary>
    public struct NotEqual : IBinaryCompareOp<T>, NumCIL.Generic.Operators.INotEqual
    {
        /// <summary>
        /// Implementation of NotEqual test
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>Elementwise result of the comparison</returns>
		public bool Op(T a, T b)
		{ return a != b; }
		
        /// <summary>
        /// Applies the NotEqual operation to the input operands
        /// </summary>
        /// <param name="in1">An input operand</param>
        /// <param name="in2">An input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise compare of the input view</returns>
        public static NumCIL.Boolean.NdArray Apply(OutArray in1, OutArray in2, NumCIL.Boolean.NdArray @out = null)
        { return UFunc.Apply<T, bool, NotEqual>(in1, in2, @out); }
    }

	#endregion

    #region Operator implementations
    /// <summary>
    /// The copy operator implementation
    /// </summary>
    public struct Copy
    {
        /// <summary>
        /// Applies the copy operation to the input operand
        /// </summary>
        /// <param name="in1">The input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is an element-wise copy of the input view</returns>
        public static OutArray Apply(OutArray in1, OutArray @out = null)
        { return UFunc.Apply<T, NumCIL.CopyOp<T>>(in1, @out); }
    }

	#region Binary operation implementations
    /// <summary>
    /// The Add operator implementation
    /// </summary>
    public struct Add : IBinaryOp<T>, NumCIL.Generic.Operators.IAdd
    {
        /// <summary>
        /// Implementation of Add with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Add with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a + b); }
		
        /// <summary>
        /// Reduces the input array with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Add>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Add operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Add>(arg); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>(in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Add>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Add operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Add>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Sub operator implementation
    /// </summary>
    public struct Sub : IBinaryOp<T>, NumCIL.Generic.Operators.ISub
    {
        /// <summary>
        /// Implementation of Sub with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Sub with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a - b); }
		
        /// <summary>
        /// Reduces the input array with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Sub>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Sub operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Sub>(arg); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>(in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Sub>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Sub operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Sub>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Mul operator implementation
    /// </summary>
    public struct Mul : IBinaryOp<T>, NumCIL.Generic.Operators.IMul
    {
        /// <summary>
        /// Implementation of Mul with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Mul with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a * b); }
		
        /// <summary>
        /// Reduces the input array with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Mul>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Mul operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Mul>(arg); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>(in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Mul>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Mul operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Mul>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Div operator implementation
    /// </summary>
    public struct Div : IBinaryOp<T>, NumCIL.Generic.Operators.IDiv
    {
        /// <summary>
        /// Implementation of Div with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Div with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)(a / b); }
		
        /// <summary>
        /// Reduces the input array with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Div>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Div operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Div>(arg); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>(in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Div>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Div operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ return UFunc.Apply<T, Div>(in1, (OutArray)in2, @out); }
    }

    /// <summary>
    /// The Pow operator implementation
    /// </summary>
    public struct Pow : IBinaryOp<T>, NumCIL.Generic.Operators.IPow
    {
        /// <summary>
        /// Implementation of Pow with two numbers
        /// </summary>
        /// <param name="a">One operand</param>
        /// <param name="b">Another operand</param>
        /// <returns>The result of Pow with two numbers</returns>
        public T Op(T a, T b)
		{ return (T)T.Pow(a, b); }
		
        /// <summary>
        /// Reduces the input array with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <param name="axis">The axis to reduce</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>A reduced NdArray</returns>
        public static OutArray Reduce(OutArray arg, long axis = 0, OutArray @out = null)
        { return UFunc.Reduce<T, Pow>(arg, axis, @out); }

        /// <summary>
        /// Reduces the input array to a scalar with the Pow operation
        /// </summary>
        /// <param name="arg">The input operand</param>
        /// <returns>The scalar result of the aggregation</returns>
        public static T Aggregate(OutArray arg)
        { return UFunc.Aggregate<T, Pow>(arg); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>(in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(T in1, OutArray in2, OutArray @out = null)
        { return UFunc.Apply<T, Pow>((OutArray)in1, in2, @out); }

        /// <summary>
        /// Applies the Pow operation to the input operands
        /// </summary>
        /// <param name="in1">One input operand</param>
        /// <param name="in2">Another input operand</param>
        /// <param name="out">An optional output array, use to perform the operation in-place</param>
        /// <returns>An NdArray that is the result of applying the operation to the two input operands</returns>
        public static OutArray Apply(OutArray in1, T in2, OutArray @out = null)
		{ 
			if (in2 == (T)2)
				return UFunc.Apply<T, Mul>(in1, in1, @out);
			else
				return UFunc.Apply<T, Pow>(in1, (OutArray)in2, @out);
		}
		
    }

	#endregion

	#region Unary operations implementation
    /// <summary>
    /// The Sqrt operation implementation
    /// </summary>
    public struct Sqrt : IUnaryOp<T>, NumCIL.Generic.Operators.ISqrt
    {
        /// <summary>
        /// Implementation of the Sqrt operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sqrt to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Sqrt(a); }
		
        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>(@in, @out); }

        /// <summary>
        /// Applies the Sqrt operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sqrt>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Exp operation implementation
    /// </summary>
    public struct Exp : IUnaryOp<T>, NumCIL.Generic.Operators.IExp
    {
        /// <summary>
        /// Implementation of the Exp operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Exp to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Exp(a); }
		
        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>(@in, @out); }

        /// <summary>
        /// Applies the Exp operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Exp>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Abs operation implementation
    /// </summary>
    public struct Abs : IUnaryOp<T>, NumCIL.Generic.Operators.IAbs
    {
        /// <summary>
        /// Implementation of the Abs operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Abs to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Abs(a); }
		
        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>(@in, @out); }

        /// <summary>
        /// Applies the Abs operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Abs>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sin operation implementation
    /// </summary>
    public struct Sin : IUnaryOp<T>, NumCIL.Generic.Operators.ISin
    {
        /// <summary>
        /// Implementation of the Sin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sin to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Sin(a); }
		
        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>(@in, @out); }

        /// <summary>
        /// Applies the Sin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cos operation implementation
    /// </summary>
    public struct Cos : IUnaryOp<T>, NumCIL.Generic.Operators.ICos
    {
        /// <summary>
        /// Implementation of the Cos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cos to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Cos(a); }
		
        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>(@in, @out); }

        /// <summary>
        /// Applies the Cos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tan operation implementation
    /// </summary>
    public struct Tan : IUnaryOp<T>, NumCIL.Generic.Operators.ITan
    {
        /// <summary>
        /// Implementation of the Tan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tan to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Tan(a); }
		
        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>(@in, @out); }

        /// <summary>
        /// Applies the Tan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Asin operation implementation
    /// </summary>
    public struct Asin : IUnaryOp<T>, NumCIL.Generic.Operators.IAsin
    {
        /// <summary>
        /// Implementation of the Asin operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Asin to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Asin(a); }
		
        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>(@in, @out); }

        /// <summary>
        /// Applies the Asin operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Asin>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Acos operation implementation
    /// </summary>
    public struct Acos : IUnaryOp<T>, NumCIL.Generic.Operators.IAcos
    {
        /// <summary>
        /// Implementation of the Acos operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Acos to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Acos(a); }
		
        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>(@in, @out); }

        /// <summary>
        /// Applies the Acos operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Acos>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Atan operation implementation
    /// </summary>
    public struct Atan : IUnaryOp<T>, NumCIL.Generic.Operators.IAtan
    {
        /// <summary>
        /// Implementation of the Atan operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Atan to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Atan(a); }
		
        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>(@in, @out); }

        /// <summary>
        /// Applies the Atan operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Atan>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Sinh operation implementation
    /// </summary>
    public struct Sinh : IUnaryOp<T>, NumCIL.Generic.Operators.ISinh
    {
        /// <summary>
        /// Implementation of the Sinh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Sinh to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Sinh(a); }
		
        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>(@in, @out); }

        /// <summary>
        /// Applies the Sinh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Sinh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Cosh operation implementation
    /// </summary>
    public struct Cosh : IUnaryOp<T>, NumCIL.Generic.Operators.ICosh
    {
        /// <summary>
        /// Implementation of the Cosh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Cosh to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Cosh(a); }
		
        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>(@in, @out); }

        /// <summary>
        /// Applies the Cosh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Cosh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Tanh operation implementation
    /// </summary>
    public struct Tanh : IUnaryOp<T>, NumCIL.Generic.Operators.ITanh
    {
        /// <summary>
        /// Implementation of the Tanh operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Tanh to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Tanh(a); }
		
        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>(@in, @out); }

        /// <summary>
        /// Applies the Tanh operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Tanh>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log operation implementation
    /// </summary>
    public struct Log : IUnaryOp<T>, NumCIL.Generic.Operators.ILog
    {
        /// <summary>
        /// Implementation of the Log operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Log(a); }
		
        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>(@in, @out); }

        /// <summary>
        /// Applies the Log operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log>((OutArray)@in, @out); }
    }

    /// <summary>
    /// The Log10 operation implementation
    /// </summary>
    public struct Log10 : IUnaryOp<T>, NumCIL.Generic.Operators.ILog10
    {
        /// <summary>
        /// Implementation of the Log10 operation
        /// </summary>
        /// <param name="a">The input operand</param>
        /// <returns>The result of applying Log10 to the operand</returns>
        public T Op(T a) 
		{ return (T)T.Log10(a); }
		
        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(OutArray @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>(@in, @out); }

        /// <summary>
        /// Applies the Log10 operation to the operand
        /// </summary>
        /// <param name="in">The input operand</param>
        /// <param name="out">An optional output operand, use to perform the operation in-place</param>
        /// <returns>The result of applying the operation to the input array</returns>
        public static OutArray Apply(T @in, OutArray @out = null)
        { return UFunc.Apply<T, Log10>((OutArray)@in, @out); }
    }

	#endregion
	#endregion

    #region Generate mimics
    /// <summary>
    /// Generates basic initial arrays
    /// </summary>
    public static class Generate
    {
        /// <summary>
        /// The factory class that produces the NdArray instances
        /// </summary>
        public static NumCIL.Generic.IGenerator<T> Generator = new NumCIL.Generic.Generator<T, NumCIL.Generic.RandomGeneratorOpComplex64, NumCIL.Generic.RangeGeneratorOp<T, NumCIL.Generic.NumberConverterComplex64>, NumCIL.Generic.NumberConverterComplex64>();

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(Shape shape) { return Generator.Range(shape); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(Shape shape) { return Generator.Ones(shape); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(Shape shape) { return Generator.Zeroes(shape); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with uninitialized data</returns>
        public static OutArray Empty(Shape shape) { return Generator.Empty(shape); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to fill the array with</param>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, Shape shape) { return Generator.Same(value, shape); }
        /// <summary>
        /// Creates an array filled with the value random numbers
        /// </summary>
        /// <param name="shape">The shape of the NdArray</param>
        /// <returns>A shaped array with all values set to random numbers</returns>
        public static OutArray Random(Shape shape) { return Generator.Random(shape); }

        /// <summary>
        /// Creates a range sequential integers, starting with zero
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with sequential numbers</returns>
        public static OutArray Range(params long[] dimensions) { return Generator.Range(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 1
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 1</returns>
        public static OutArray Ones(params long[] dimensions) { return Generator.Ones(dimensions); }
        /// <summary>
        /// Creates an array filled with the value 0
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to 0</returns>
        public static OutArray Zeroes(params long[] dimensions) { return Generator.Zeroes(dimensions); }
        /// <summary>
        /// Creates an uninitialized array
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with uninitialized values</returns>
        public static OutArray Empty(params long[] dimensions) { return Generator.Empty(dimensions); }
        /// <summary>
        /// Creates an array filled with the given value
        /// </summary>
        /// <param name="value">The value to set fill the array with</param>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to the given value</returns>
        public static OutArray Same(T value, params long[] dimensions) { return Generator.Same(value, dimensions); }
        /// <summary>
        /// Creates an array filled with random values
        /// </summary>
        /// <param name="dimensions">The size of each dimension</param>
        /// <returns>A shaped array with all values set to a random value</returns>
        public static OutArray Random(params long[] dimensions) { return Generator.Random(dimensions); }
    }
    #endregion

}


namespace NumCIL.Complex128
{
    using T = System.Numerics.Complex;
    using OutArray = NumCIL.Generic.NdArray<System.Numerics.Complex>;
    using InArray = NumCIL.Complex128.NdArray;
	using TComp = System.Double;
	using TCompArray = NumCIL.Double.NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray
    {
        #region Conversion operators
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(NumCIL.Double.NdArray a) { return UFunc.Apply<double, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(NumCIL.Float.NdArray a) { return UFunc.Apply<float, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(NumCIL.Int8.NdArray a) { return UFunc.Apply<sbyte, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(NumCIL.UInt8.NdArray a) { return UFunc.Apply<byte, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(NumCIL.UInt16.NdArray a) { return UFunc.Apply<ushort, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(NumCIL.Int16.NdArray a) { return UFunc.Apply<short, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(NumCIL.UInt32.NdArray a) { return UFunc.Apply<uint, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(NumCIL.Int32.NdArray a) { return UFunc.Apply<int, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(NumCIL.UInt64.NdArray a) { return UFunc.Apply<ulong, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(NumCIL.Int64.NdArray a) { return UFunc.Apply<long, T, ToComplex>(a); }

        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="NumCIL.Complex64.DataType"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(NumCIL.Complex64.NdArray a) { return UFunc.Apply<NumCIL.Complex64.DataType, T, ToComplex>(a); }

        #endregion

		#region Scalar conversion operators
        /// <summary>
        /// Converts a scalar from <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(double a) { return UFunc.Apply<double, T, ToComplex>((NumCIL.Double.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(NumCIL.Complex64.DataType a) { return UFunc.Apply<NumCIL.Complex64.DataType, T, ToComplex>((NumCIL.Complex64.NdArray)a); }
        /// <summary>
        /// Converts  scalar from <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(float a) { return UFunc.Apply<float, T, ToComplex>((NumCIL.Float.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(sbyte a) { return UFunc.Apply<sbyte, T, ToComplex>((NumCIL.Int8.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(byte a) { return UFunc.Apply<byte, T, ToComplex>((NumCIL.UInt8.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(ushort a) { return UFunc.Apply<ushort, T, ToComplex>((NumCIL.UInt16.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(short a) { return UFunc.Apply<short, T, ToComplex>((NumCIL.Int16.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(uint a) { return UFunc.Apply<uint, T, ToComplex>((NumCIL.UInt32.NdArray)a); }
        /// <summary>
        /// Converts a scalar NdArray from <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(int a) { return UFunc.Apply<int, T, ToComplex>((NumCIL.Int32.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(ulong a) { return UFunc.Apply<ulong, T, ToComplex>((NumCIL.UInt64.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Numerics.Complex"/></returns>
        public static implicit operator InArray(long a) { return UFunc.Apply<long, T, ToComplex>((NumCIL.Int64.NdArray)a); }		
		#endregion

        #region Complex conversion operators
        /// <summary>
        /// Returns a new NdArray that has the real component value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all real component values</returns>
        public TCompArray Real(NumCIL.Double.NdArray @out = null) { return UFunc.Apply<T, TComp, Real>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the imaginary component value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all imaginary component values</returns>
        public TCompArray Imaginary(NumCIL.Double.NdArray @out = null) { return UFunc.Apply<T, TComp, Imaginary>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the magnitude component value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all magnitude component values</returns>
        public TCompArray Magnitude(NumCIL.Double.NdArray @out = null) { return UFunc.Apply<T, TComp, Magnitude>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the phase component value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all phase component values</returns>
        public TCompArray Phase(NumCIL.Double.NdArray @out = null) { return UFunc.Apply<T, TComp, Phase>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the conjugate value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all conjugate values</returns>
        public OutArray Phase(OutArray @out = null) { return UFunc.Apply<T, Conjugate>(this, @out); }

        #endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The real operation
        /// </summary>
        public static readonly Real Real;
        /// <summary>
        /// The imaginary operation
        /// </summary>
        public static readonly Imaginary Imaginary;
        /// <summary>
        /// The magnitude operation
        /// </summary>
        public static readonly Magnitude Magnitude;
        /// <summary>
        /// The phase operation
        /// </summary>
        public static readonly Phase Phase;
        /// <summary>
        /// The conjugate operation
        /// </summary>
        public static readonly Conjugate Conjugate;
    }
    #endregion

    #region Conversion operators
    /// <summary>
    /// Operator for converting a value to complex number
    /// </summary>
    public struct ToComplex : 
		IUnaryConvOp<NumCIL.Complex64.DataType, T>, 
        IUnaryConvOp<double, T>, 
        IUnaryConvOp<float, T>, 
        IUnaryConvOp<sbyte, T>, 
        IUnaryConvOp<byte,T>, 
        IUnaryConvOp<short, T>, 
        IUnaryConvOp<ushort, T>, 
        IUnaryConvOp<int, T>, 
        IUnaryConvOp<uint,T>, 
        IUnaryConvOp<long, T>, 
        IUnaryConvOp<ulong, T>,
		NumCIL.Generic.Operators.ITypeConversion
    {
        /// <summary>
        /// Converts the input from a <see cref="NumCIL.Complex64.DataType"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(NumCIL.Complex64.DataType a) { return (T)a; }

        /// <summary>
        /// Converts the input from a <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(double a) { return (T)a; }

        /// <summary>
        /// Converts the input from a <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(float a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(sbyte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(byte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ushort a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(short a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(uint a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(int a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ulong a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(long a) { return (T)a; }
    }

    #endregion

    #region Complex conversion operators
    /// <summary>
    /// Operator for extracting the real component
    /// </summary>
    public struct Real : IUnaryConvOp<T, TComp>, NumCIL.Generic.Operators.IRealValue
    {
        /// <summary>
        /// Extracts the real component
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The real component valued</returns>
        public TComp Op(T a) { return a.Real; }
    }

    /// <summary>
    /// Operator for extracting the imaginary component
    /// </summary>
    public struct Imaginary : IUnaryConvOp<T, TComp>, NumCIL.Generic.Operators.IImaginaryValue
    {
        /// <summary>
        /// Extracts the imaginary component
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The imaginary component value</returns>
        public TComp Op(T a) { return a.Imaginary; }
    }

    /// <summary>
    /// Operator for extracting the magnitude component
    /// </summary>
    public struct Magnitude : IUnaryConvOp<T, TComp>
    {
        /// <summary>
        /// Extracts the magnitude component
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The magnitude component value</returns>
        public TComp Op(T a) { return a.Magnitude; }
    }

    /// <summary>
    /// Operator for extracting the phase component
    /// </summary>
    public struct Phase : IUnaryConvOp<T, TComp>
    {
        /// <summary>
        /// Extracts the phase component
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The phase component value</returns>
        public TComp Op(T a) { return a.Phase; }
    }

    /// <summary>
    /// Operator for calculating the conjugate
    /// </summary>
    public struct Conjugate : IUnaryOp<T>
    {
        /// <summary>
        /// Calculates the conjugate
        /// </summary>
        /// <param name="a">The input value</param>
        /// <returns>The conjugate value</returns>
        public T Op(T a) { return T.Conjugate(a); }
    }

    #endregion
}


namespace NumCIL.Complex64
{
    using T = NumCIL.Complex64.DataType;
    using OutArray = NumCIL.Generic.NdArray<NumCIL.Complex64.DataType>;
    using InArray = NumCIL.Complex64.NdArray;
	using TComp = System.Single;
	using TCompArray = NumCIL.Float.NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
    public partial class NdArray
    {
        #region Conversion operators
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static explicit operator InArray(NumCIL.Double.NdArray a) { return UFunc.Apply<double, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(NumCIL.Float.NdArray a) { return UFunc.Apply<float, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(NumCIL.Int8.NdArray a) { return UFunc.Apply<sbyte, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(NumCIL.UInt8.NdArray a) { return UFunc.Apply<byte, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(NumCIL.UInt16.NdArray a) { return UFunc.Apply<ushort, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(NumCIL.Int16.NdArray a) { return UFunc.Apply<short, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(NumCIL.UInt32.NdArray a) { return UFunc.Apply<uint, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(NumCIL.Int32.NdArray a) { return UFunc.Apply<int, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(NumCIL.UInt64.NdArray a) { return UFunc.Apply<ulong, T, ToComplex>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(NumCIL.Int64.NdArray a) { return UFunc.Apply<long, T, ToComplex>(a); }

        /// <summary>
        /// Converts all elements in the input NdArray from <see cref="NumCIL.Complex64.DataType"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static explicit operator InArray(NumCIL.Complex128.NdArray a) { return UFunc.Apply<System.Numerics.Complex, T, ToComplex>(a); }

        #endregion

		#region Scalar conversion operators
        /// <summary>
        /// Converts a scalar from <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static explicit operator InArray(double a) { return UFunc.Apply<double, T, ToComplex>((NumCIL.Double.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static explicit operator InArray(System.Numerics.Complex a) { return UFunc.Apply<System.Numerics.Complex, T, ToComplex>((NumCIL.Complex128.NdArray)a); }
        /// <summary>
        /// Converts  scalar from <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(float a) { return UFunc.Apply<float, T, ToComplex>((NumCIL.Float.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(sbyte a) { return UFunc.Apply<sbyte, T, ToComplex>((NumCIL.Int8.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(byte a) { return UFunc.Apply<byte, T, ToComplex>((NumCIL.UInt8.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(ushort a) { return UFunc.Apply<ushort, T, ToComplex>((NumCIL.UInt16.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(short a) { return UFunc.Apply<short, T, ToComplex>((NumCIL.Int16.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(uint a) { return UFunc.Apply<uint, T, ToComplex>((NumCIL.UInt32.NdArray)a); }
        /// <summary>
        /// Converts a scalar NdArray from <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(int a) { return UFunc.Apply<int, T, ToComplex>((NumCIL.Int32.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(ulong a) { return UFunc.Apply<ulong, T, ToComplex>((NumCIL.UInt64.NdArray)a); }
        /// <summary>
        /// Converts a scalar from <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="NumCIL.Complex64.DataType"/></returns>
        public static implicit operator InArray(long a) { return UFunc.Apply<long, T, ToComplex>((NumCIL.Int64.NdArray)a); }		
		#endregion

        #region Complex conversion operators
        /// <summary>
        /// Returns a new NdArray that has the real component value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all real component values</returns>
        public TCompArray Real(NumCIL.Float.NdArray @out = null) { return UFunc.Apply<T, TComp, Real>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the imaginary component value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all imaginary component values</returns>
        public TCompArray Imaginary(NumCIL.Float.NdArray @out = null) { return UFunc.Apply<T, TComp, Imaginary>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the magnitude component value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all magnitude component values</returns>
        public TCompArray Magnitude(NumCIL.Float.NdArray @out = null) { return UFunc.Apply<T, TComp, Magnitude>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the phase component value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all phase component values</returns>
        public TCompArray Phase(NumCIL.Float.NdArray @out = null) { return UFunc.Apply<T, TComp, Phase>(this, @out); }
        /// <summary>
        /// Returns a new NdArray that has the conjugate value of all elements in this array
        /// </summary>
        /// <param name="out">Optional target for the operation, use to perform the operation in-place</param>
        /// <returns>An NdArray with all conjugate values</returns>
        public OutArray Phase(OutArray @out = null) { return UFunc.Apply<T, Conjugate>(this, @out); }

        #endregion
    }

    #region Struct instances for common operations
    /// <summary>
    /// Collection of instantiated operation structs
    /// </summary>
    public partial struct Ops
    {
        /// <summary>
        /// The real operation
        /// </summary>
        public static readonly Real Real;
        /// <summary>
        /// The imaginary operation
        /// </summary>
        public static readonly Imaginary Imaginary;
        /// <summary>
        /// The magnitude operation
        /// </summary>
        public static readonly Magnitude Magnitude;
        /// <summary>
        /// The phase operation
        /// </summary>
        public static readonly Phase Phase;
        /// <summary>
        /// The conjugate operation
        /// </summary>
        public static readonly Conjugate Conjugate;
    }
    #endregion

    #region Conversion operators
    /// <summary>
    /// Operator for converting a value to complex number
    /// </summary>
    public struct ToComplex : 
		IUnaryConvOp<System.Numerics.Complex, T>, 
        IUnaryConvOp<double, T>, 
        IUnaryConvOp<float, T>, 
        IUnaryConvOp<sbyte, T>, 
        IUnaryConvOp<byte,T>, 
        IUnaryConvOp<short, T>, 
        IUnaryConvOp<ushort, T>, 
        IUnaryConvOp<int, T>, 
        IUnaryConvOp<uint,T>, 
        IUnaryConvOp<long, T>, 
        IUnaryConvOp<ulong, T>,
		NumCIL.Generic.Operators.ITypeConversion
    {
        /// <summary>
        /// Converts the input from a <see cref="System.Numerics.Complex"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(System.Numerics.Complex a) { return (T)a; }

        /// <summary>
        /// Converts the input from a <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(double a) { return (T)a; }

        /// <summary>
        /// Converts the input from a <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(float a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(sbyte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(byte a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ushort a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(short a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(uint a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(int a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(ulong a) { return (T)a; }
        /// <summary>
        /// Converts the input from a <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public T Op(long a) { return (T)a; }
    }

    #endregion

    #region Complex conversion operators
    /// <summary>
    /// Operator for extracting the real component
    /// </summary>
    public struct Real : IUnaryConvOp<T, TComp>, NumCIL.Generic.Operators.IRealValue
    {
        /// <summary>
        /// Extracts the real component
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The real component valued</returns>
        public TComp Op(T a) { return a.Real; }
    }

    /// <summary>
    /// Operator for extracting the imaginary component
    /// </summary>
    public struct Imaginary : IUnaryConvOp<T, TComp>, NumCIL.Generic.Operators.IImaginaryValue
    {
        /// <summary>
        /// Extracts the imaginary component
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The imaginary component value</returns>
        public TComp Op(T a) { return a.Imaginary; }
    }

    /// <summary>
    /// Operator for extracting the magnitude component
    /// </summary>
    public struct Magnitude : IUnaryConvOp<T, TComp>
    {
        /// <summary>
        /// Extracts the magnitude component
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The magnitude component value</returns>
        public TComp Op(T a) { return a.Magnitude; }
    }

    /// <summary>
    /// Operator for extracting the phase component
    /// </summary>
    public struct Phase : IUnaryConvOp<T, TComp>
    {
        /// <summary>
        /// Extracts the phase component
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The phase component value</returns>
        public TComp Op(T a) { return a.Phase; }
    }

    /// <summary>
    /// Operator for calculating the conjugate
    /// </summary>
    public struct Conjugate : IUnaryOp<T>
    {
        /// <summary>
        /// Calculates the conjugate
        /// </summary>
        /// <param name="a">The input value</param>
        /// <returns>The conjugate value</returns>
        public T Op(T a) { return T.Conjugate(a); }
    }

    #endregion
}


namespace NumCIL.Boolean
{
    using T = System.Boolean;
    using InArray = NumCIL.Generic.NdArray<System.Boolean>;
    using OutArray = NdArray;

    /// <summary>
    /// A wrapper for a basic NdArray to a similar one with typed operators
    /// </summary>
	public partial class NdArray
	{
		#region Conversion operators
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Double"/></returns>
        public static explicit operator NumCIL.Double.NdArray(OutArray a) { return UFunc.Apply<T, double, ToDouble>(a); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Single"/></returns>
        public static explicit operator NumCIL.Float.NdArray(OutArray a) { return UFunc.Apply<T, float, ToFloat>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.SByte"/></returns>
        public static explicit operator NumCIL.Int8.NdArray(OutArray a) { return UFunc.Apply<T, sbyte, ToInt8>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int16"/></returns>
        public static explicit operator NumCIL.Int16.NdArray(OutArray a) { return UFunc.Apply<T, short, ToInt16>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int32"/></returns>
        public static explicit operator NumCIL.Int32.NdArray(OutArray a) { return UFunc.Apply<T, int, ToInt32>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Int64"/></returns>
        public static explicit operator NumCIL.Int64.NdArray(OutArray a) { return UFunc.Apply<T, long, ToInt64>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.Byte"/></returns>
        public static explicit operator NumCIL.UInt8.NdArray(OutArray a) { return UFunc.Apply<T, byte, ToUInt8>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt16"/></returns>
        public static explicit operator NumCIL.UInt16.NdArray(OutArray a) { return UFunc.Apply<T, ushort, ToUInt16>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt32"/></returns>
        public static explicit operator NumCIL.UInt32.NdArray(OutArray a) { return UFunc.Apply<T, uint, ToUInt32>(a); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The input array</param>
        /// <returns>An NdArray of <see cref="System.UInt64"/></returns>
        public static explicit operator NumCIL.UInt64.NdArray(OutArray a) { return UFunc.Apply<T, ulong, ToUInt64>(a); }
		#endregion

		#region Conversion methods
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Double"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.Double"/></returns>
        public NumCIL.Double.NdArray ToDouble(NumCIL.Double.NdArray @out = null) { return UFunc.Apply<T, double, ToDouble>(this, @out); }
        /// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Single"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.Single"/></returns>
        public NumCIL.Float.NdArray ToFloat(NumCIL.Float.NdArray @out = null) { return UFunc.Apply<T, float, ToFloat>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.SByte"/></returns>
        public NumCIL.Int8.NdArray ToInt8(NumCIL.Int8.NdArray @out = null) { return UFunc.Apply<T, sbyte, ToInt8>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.Int16"/></returns>
        public NumCIL.Int16.NdArray ToInt16(NumCIL.Int16.NdArray @out = null) { return UFunc.Apply<T, short, ToInt16>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.Int32"/></returns>
        public NumCIL.Int32.NdArray ToInt32(NumCIL.Int32.NdArray @out = null) { return UFunc.Apply<T, int, ToInt32>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.Int64"/></returns>
        public NumCIL.Int64.NdArray ToInt64(NumCIL.Int64.NdArray @out = null) { return UFunc.Apply<T, long, ToInt64>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.Byte"/></returns>
        public NumCIL.UInt8.NdArray ToUInt8(NumCIL.UInt8.NdArray @out = null) { return UFunc.Apply<T, byte, ToUInt8>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.UInt16"/></returns>
        public NumCIL.UInt16.NdArray ToUInt16(NumCIL.UInt16.NdArray @out = null) { return UFunc.Apply<T, ushort, ToUInt16>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.UInt32"/></returns>
        public NumCIL.UInt32.NdArray ToUInt32(NumCIL.UInt32.NdArray @out = null) { return UFunc.Apply<T, uint, ToUInt32>(this, @out); }
		/// <summary>
        /// Converts all elements in the input NdArray to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="out">An optional output array</param>
        /// <returns>An NdArray of <see cref="System.UInt64"/></returns>
        public NumCIL.UInt64.NdArray ToUInt64(NumCIL.UInt64.NdArray @out = null) { return UFunc.Apply<T, ulong, ToUInt64>(this, @out); }
		#endregion	
	}
		
	#region Conversion operators
    /// <summary>
    /// Operator for converting a value to <see cref="System.Single"/>
    /// </summary>
    public struct ToFloat : IUnaryConvOp<T, float>, NumCIL.Generic.Operators.ITypeConversion 
    { 
        /// <summary>
        /// Converts the input value to <see cref="System.Single"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public float Op(T a) { return (float)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.Double"/>
    /// </summary>
    public struct ToDouble : IUnaryConvOp<T, double>, NumCIL.Generic.Operators.ITypeConversion
    {
        /// <summary>
        /// Converts the input value to <see cref="System.Double"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public double Op(T a) { return (double)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.SByte"/>
    /// </summary>
    public struct ToInt8 : IUnaryConvOp<T, sbyte>, NumCIL.Generic.Operators.ITypeConversion 
    {
        /// <summary>
        /// Converts the input value to <see cref="System.SByte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public sbyte Op(T a) { return (sbyte)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.Int16"/>
    /// </summary>
    public struct ToInt16 : IUnaryConvOp<T, short>, NumCIL.Generic.Operators.ITypeConversion
    {
        /// <summary>
        /// Converts the input value to <see cref="System.Int16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public short Op(T a) { return (short)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.Int32"/>
    /// </summary>
    public struct ToInt32 : IUnaryConvOp<T, int>, NumCIL.Generic.Operators.ITypeConversion 
    {
        /// <summary>
        /// Converts the input value to <see cref="System.Int32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public int Op(T a) { return (int)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.Int64"/>
    /// </summary>
    public struct ToInt64 : IUnaryConvOp<T, long>, NumCIL.Generic.Operators.ITypeConversion
    {
        /// <summary>
        /// Converts the input value to <see cref="System.Int64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public long Op(T a) { return (long)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.Byte"/>
    /// </summary>
    public struct ToUInt8 : IUnaryConvOp<T, byte>, NumCIL.Generic.Operators.ITypeConversion 
    {
        /// <summary>
        /// Converts the input value to <see cref="System.Byte"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public byte Op(T a) { return (byte)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.UInt16"/>
    /// </summary>
    public struct ToUInt16 : IUnaryConvOp<T, ushort>, NumCIL.Generic.Operators.ITypeConversion 
    {
        /// <summary>
        /// Converts the input value to <see cref="System.UInt16"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public ushort Op(T a) { return (ushort)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.UInt32"/>
    /// </summary>
    public struct ToUInt32 : IUnaryConvOp<T, uint>, NumCIL.Generic.Operators.ITypeConversion 
    {
        /// <summary>
        /// Converts the input value to <see cref="System.UInt32"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public uint Op(T a) { return (uint)(a ? 1 : 0); } 
    }

    /// <summary>
    /// Operator for converting a value to <see cref="System.UInt64"/>
    /// </summary>
    public struct ToUInt64 : IUnaryConvOp<T, ulong>, NumCIL.Generic.Operators.ITypeConversion 
    {
        /// <summary>
        /// Converts the input value to <see cref="System.UInt64"/>
        /// </summary>
        /// <param name="a">The value to convert</param>
        /// <returns>The converted valued</returns>
        public ulong Op(T a) { return (ulong)(a ? 1 : 0); } 
    }	
	#endregion
}